{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/google98f2983bc6265a15.html","path":"google98f2983bc6265a15.html","modified":0,"renderable":1},{"_id":"themes/next/source/robots.txt","path":"robots.txt","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/header.jpg","path":"images/header.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0}],"Cache":[{"_id":"source/robots.txt","hash":"45f857b2dbde307e2e3f4b9c8a246aa74b3d652e","modified":1603934079653},{"_id":"source/about/index.md","hash":"ded3f0116313e3d8673b5b42f7dc4786bdc6d9ab","modified":1603727162173},{"_id":"source/categories/index.md","hash":"31cc51d7f1a5de2e75ad64ed9675d6aa3fac46d5","modified":1603769092023},{"_id":"source/tags/index.md","hash":"301b325c4ddca4d6f7f18619b68c71a46a71c9e5","modified":1603769309360},{"_id":"source/_posts/Config/hexo_config.md","hash":"f5289b760c42d797747f5ef5a123ccb3f61ce1df","modified":1603768820112},{"_id":"source/_posts/Config/hexo_with_image.md","hash":"058a66c86d6a66ddd1d932428a32b3226858fa3f","modified":1603815409568},{"_id":"source/_posts/Kafka/2020-10-04-Kafka简介.md","hash":"131200721226639addd09e6d149c0049a2bd8377","modified":1602292121754},{"_id":"source/_posts/Config/hexo_google_site.md","hash":"6858163413334848b62a60ba668e218653e783f2","modified":1603935717685},{"_id":"source/_posts/Kafka/2020-10-04-比较.md","hash":"95a28ada75b73f0f4aeb8f0996a016a3ffd33842","modified":1603729248647},{"_id":"source/_posts/Filesystem/ZFS.md","hash":"4765a8b98f0c08ba3f431613c3eff340d93a4177","modified":1602643749388},{"_id":"source/_posts/Leetcode/1234.md","hash":"ff64c1402a518f800a3464364fc2db62eec0b3bd","modified":1603975788357},{"_id":"source/_posts/Leetcode/142.md","hash":"60f1253766c9c80ade2164a281051abc9e1e38e6","modified":1604242970639},{"_id":"source/_posts/Leetcode/523.md","hash":"a63d43021773b3fe1641e2136e32819c4b9a0a3c","modified":1604108797119},{"_id":"source/_posts/Leetcode/1616.md","hash":"1bf0ec295d43145a6d7fc44a13a8ca0548aa7561","modified":1604069399751},{"_id":"source/_posts/Leetcode/287.md","hash":"6f74dbd48675a2e349aa2f601f5c556cb66c332d","modified":1604247533202},{"_id":"source/_posts/Leetcode/567.md","hash":"5716a5ea42b326cd79445c4b47d9fdcbb246be33","modified":1604407113543},{"_id":"source/_posts/Leetcode/763.md","hash":"85f8cff024e77bc8b12dd4c94b6c64255419e016","modified":1603806703528},{"_id":"source/_posts/Leetcode/滑动窗口.md","hash":"d3baba090a016c016be7601ee95ddfeab061d0d6","modified":1602292121756},{"_id":"source/_posts/Leetcode/826.md","hash":"2f3fc0aae6e794b92530a5891e576008571913b3","modified":1603893822920},{"_id":"source/_posts/LinuxCmd/20200814-查看远程服务器的端口是否开放.md","hash":"76ba9055789ba4416749501973a68258e5928d00","modified":1602292121752},{"_id":"source/_posts/LinuxCmd/20200814netstat.md","hash":"ea5efc60f64d78456b6d17f9fcd9afe6b5599843","modified":1602292121753},{"_id":"source/_posts/LinuxCmd/使用GDB查看core文件.md","hash":"0fc72b76b456e99c89aee5f6456911bc1980ad84","modified":1602292121754},{"_id":"source/_posts/LeetcodeSummary/TwoPointer.md","hash":"d58a971def706b149b9789e3de654bc8b1dbc4ed","modified":1604408248384},{"_id":"source/_posts/Memory/Dynamic_memory_in_CPP.md","hash":"cf83ef9e27272da6e4389b0162b5d797f6c7e581","modified":1604540351126},{"_id":"source/_posts/Socket/2020-09-21-TCP最大连接数.md","hash":"52437761957f65d2187a6204bc956dd980ec1958","modified":1602292121752},{"_id":"source/_posts/Socket/20200914-socket_close_shutdown.md","hash":"56283b1530323efb12f55ced02055303d612f26b","modified":1602292121753},{"_id":"source/_posts/Config/hexo_google_site/could_not_fetch.jpg","hash":"c9b2db7533e5e4f89df9cb756c661cb647eca8d7","modified":1603873682886},{"_id":"source/_posts/Config/hexo_google_site/first.png","hash":"9de65aea68e6b2112290866ee983e7abdc54f587","modified":1603811050331},{"_id":"source/_posts/Config/hexo_google_site/add_sitemap.png","hash":"6ae5d75519b4b1947eff136621150c3513f18f83","modified":1603811419500},{"_id":"themes/next/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1602295777626},{"_id":"themes/next/.gitattributes","hash":"aeeca2f1e987d83232d7870d1435a4e3ed66b648","modified":1602295777627},{"_id":"themes/next/.eslintrc.json","hash":"611e15c3fcb41dc68fa8532ee595a1262a1b5a8a","modified":1602295777626},{"_id":"themes/next/.gitignore","hash":"03012748b175434345643bfe11515b4ad22a5be8","modified":1602295777635},{"_id":"themes/next/.npmignore","hash":"e726ec1241bfaed670bc6059172e048a53ad970d","modified":1602295777636},{"_id":"themes/next/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1602295777636},{"_id":"themes/next/LICENSE.md","hash":"2f8a566ace11a7042e18555041625017242d969e","modified":1602295777636},{"_id":"themes/next/README.md","hash":"88fb6fa93cf47eb787592677f8a93b5119d96a92","modified":1602295777637},{"_id":"themes/next/_config.yml","hash":"12f89424c997b01dfe4c2caceb829b1ae4ba1f81","modified":1604408548082},{"_id":"themes/next/_vendors.yml","hash":"27ab9721551bb0c7e369a8d6fd9922e81f19786d","modified":1602295777638},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1602295777638},{"_id":"themes/next/package.json","hash":"25e8c098400fca1d5486abc24a80007c6c52ff09","modified":1602295777679},{"_id":"themes/next/renovate.json","hash":"767b077c7b615e20af3cf865813cd64674a9bea6","modified":1602295777680},{"_id":"themes/next/docs/LICENSE.txt","hash":"71bcc7017bd259ac52f171b23530ab35ce810f6c","modified":1602295777640},{"_id":"themes/next/docs/AUTHORS.md","hash":"579014d47f45b27fd1618b9709f0efe9585c7449","modified":1602295777639},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1602295777639},{"_id":"themes/next/languages/README.md","hash":"b1c96465b3bc139bf5ba6200974b66581d8ff85a","modified":1602295777642},{"_id":"themes/next/languages/ar.yml","hash":"143234db25fd275133c9c2ab748b631961d12c31","modified":1602295777642},{"_id":"themes/next/languages/de.yml","hash":"02455e63ed994599c94907e2e2dd40cd4615a079","modified":1602295777643},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1602295777643},{"_id":"themes/next/languages/en.yml","hash":"7ad763a7ac5f05d10c45acca17ef33087495662f","modified":1602295777643},{"_id":"themes/next/languages/es.yml","hash":"d984dd6d65d4b1f95d20f0868639aacd7a35dc48","modified":1602295777644},{"_id":"themes/next/languages/fr.yml","hash":"fcf826ff8ef8c4805ec56393499773bf3919235b","modified":1602295777644},{"_id":"themes/next/languages/fa.yml","hash":"557b8a7a408bf34f17b598e426c7c2050e39e571","modified":1602295777644},{"_id":"themes/next/languages/id.yml","hash":"b22376ccce825fe4bcd935be4e19400fe51505ad","modified":1602295777645},{"_id":"themes/next/languages/it.yml","hash":"4b14448a4779d3826f785d1559b27fc328001dac","modified":1602295777645},{"_id":"themes/next/languages/ja.yml","hash":"7a2dfeb060a87a214e9e4da3ea9e0b1c96578bd4","modified":1602295777645},{"_id":"themes/next/languages/ko.yml","hash":"8707cc844a24b3aef9ae4c7b06b3f508d32442ff","modified":1602295777646},{"_id":"themes/next/languages/nl.yml","hash":"4646c4d7ffa1619a128b1a682aacd659da6dbe7e","modified":1602295777646},{"_id":"themes/next/languages/pt-BR.yml","hash":"1d724d9d8b86fe9aaa2757473ae4de12735248ee","modified":1602295777646},{"_id":"themes/next/languages/ru.yml","hash":"7b72d3c5b09d50b1f57db6c763130cecf429d18a","modified":1602295777647},{"_id":"themes/next/languages/pt.yml","hash":"d48ddb7c206d8f6e43631cb358a16dcaf5a6b5fe","modified":1602295777647},{"_id":"themes/next/languages/tr.yml","hash":"a1849c9de54ed28c0bb2bd3bf26049009fbb997f","modified":1602295777647},{"_id":"themes/next/languages/uk.yml","hash":"10a2166165beb7364310a917d14ecb27c48d7598","modified":1602295777648},{"_id":"themes/next/languages/vi.yml","hash":"b0c0b28dc988e15b0e11db3dd1707747695dec2c","modified":1602295777648},{"_id":"themes/next/languages/zh-CN.yml","hash":"5d773b4b85a299ceef08891a71d47a8255d81cf2","modified":1602295777649},{"_id":"themes/next/languages/zh-HK.yml","hash":"5ec324f0c41acee95f0ffd54605cde7cc82a20de","modified":1602295777649},{"_id":"themes/next/languages/zh-TW.yml","hash":"3f681da3f46fa66c54e0b9c1c75db601cd0369d7","modified":1602295777649},{"_id":"themes/next/layout/_layout.njk","hash":"04dff323c78a798eac860aec86a4c3fb929385cf","modified":1602295777650},{"_id":"themes/next/layout/category.njk","hash":"ba5787924897b38e1e43db8bb4486010cf56631a","modified":1602295777677},{"_id":"themes/next/layout/index.njk","hash":"a5e09e4406286ce7cb82f792f627218f9a3258b5","modified":1602295777678},{"_id":"themes/next/layout/archive.njk","hash":"c14909bd675974e2e013fe688b2799b03c435ed4","modified":1602295777677},{"_id":"themes/next/layout/page.njk","hash":"0bdaf1ed4aab19fa7c01a5145272bdc42ce9cd24","modified":1602295777678},{"_id":"themes/next/layout/post.njk","hash":"707a50e50b90df5fbeaf8407d12895d04163a290","modified":1602295777678},{"_id":"themes/next/layout/tag.njk","hash":"fb3bfb2a75e91ac8cd72baf9e43264fffd1e0e24","modified":1602295777679},{"_id":"themes/next/scripts/renderer.js","hash":"478275ebf0a8867b473b172dda812ea3d18a3518","modified":1602295777690},{"_id":"themes/next/source/google98f2983bc6265a15.html","hash":"ca760b946550415b58e28e8a5bdaa706cb6be814","modified":1603809115126},{"_id":"themes/next/source/robots.txt","hash":"2d7c3b49e2f164104086c2c6bd64150e55456a67","modified":1603871864804},{"_id":"themes/next/test/index.js","hash":"983a505399796b9d9e174ba46d89abbdde38f8ee","modified":1602295777750},{"_id":"themes/next/docs/ru/README.md","hash":"ebd5f816a18eda8e5a421690e674912ae974554d","modified":1602295777640},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"582f5f6b839a21e7498ca523c8c83178a0fda51b","modified":1602295777641},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"c1ba78b246349f79adcf06a940961bba8a8350cb","modified":1602295777641},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c5ffe8a17883a07b1055c09c7cb937591670cb07","modified":1602295777641},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"d9d8e6d7a6a8c80009dd5334cc17fd3e4977a008","modified":1602295777650},{"_id":"themes/next/layout/_macro/post.njk","hash":"c0301509e9b44f7dc0161537252a2dd7459c8273","modified":1602295777651},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"b3eb3b67859ddf15c7d2e23be373678249ad5c1e","modified":1602295777651},{"_id":"themes/next/layout/_partials/comments.njk","hash":"5e6d77ed00be8a0533fe2d7f7fc1daf79e961578","modified":1602295777652},{"_id":"themes/next/layout/_partials/footer.njk","hash":"07a897bda664a11d9302d017e50483db69b5dd11","modified":1603807308221},{"_id":"themes/next/layout/_partials/languages.njk","hash":"c3ea82604a5853fb44c5f4e4663cbe912aa5dcf8","modified":1602295777655},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"2de77d533c91532a8a4052000244d0c1693370df","modified":1602295777657},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"aceb0e3646501036b52a426e4f0c0bd474d5717c","modified":1602295777662},{"_id":"themes/next/layout/_scripts/index.njk","hash":"84801a0e858618eab1d352c76a89534766fcdbf7","modified":1602295777663},{"_id":"themes/next/layout/_scripts/noscript.njk","hash":"8da7b29b265669465fa77896384207d60e0f6e02","modified":1602295777663},{"_id":"themes/next/layout/_scripts/pjax.njk","hash":"0ab99e210c6c3446e7bcebdc2422f8acde035428","modified":1602295777663},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"6914d0bbba2bdc1fedbb30a8a17f539d75e2a047","modified":1602295777664},{"_id":"themes/next/layout/_third-party/baidu-push.njk","hash":"bd9ba0bf60cc3008ee14339fa395ee6af188e879","modified":1602295777666},{"_id":"themes/next/layout/_third-party/index.njk","hash":"9f485862a4faa11366e47e4be464deafd167d504","modified":1602295777670},{"_id":"themes/next/layout/_third-party/nprogress.njk","hash":"7ab092776259e511cac24535f671873afc1c0b0c","modified":1602295777671},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"28060f7bd99cc5d61521ecb6894ce5d63244c2a5","modified":1602295777672},{"_id":"themes/next/layout/_third-party/rating.njk","hash":"269102fc5e46bd1ce75abdcce161f0570ae70e2f","modified":1602295777672},{"_id":"themes/next/scripts/events/index.js","hash":"fb3feea03bacd679bccc1ec0a1ddeede5d2703df","modified":1602295777680},{"_id":"themes/next/scripts/filters/locals.js","hash":"e84d39780608dd72ea82b59e3fa893c6a7f10f4e","modified":1602295777687},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"0c9a1fe9906672724dbf274154a37bac1915ca2c","modified":1602295777686},{"_id":"themes/next/scripts/filters/minify.js","hash":"0626a00515b424c0f2f4bc2ed4d4564121adde98","modified":1602295777687},{"_id":"themes/next/scripts/filters/post.js","hash":"11f64f95837d0d44245768e0b72dc97b7e56d01f","modified":1602295777687},{"_id":"themes/next/scripts/helpers/engine.js","hash":"3198d59ec9b59a6fb8bf3f6eb8a983d17f119124","modified":1602295777688},{"_id":"themes/next/scripts/helpers/font.js","hash":"45490ac0527ca4e613d8dd950e24501744e24942","modified":1602295777688},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"4e2bea7c90e307231358530ee511d8beca4e53be","modified":1602295777689},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"ce3ea97dc80a9813f50a8db707063656c552ce89","modified":1602295777689},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"52acbc74c1ead8a77cd3bbcba4e033053683f7d0","modified":1602295777690},{"_id":"themes/next/scripts/tags/button.js","hash":"86c71c73a63744efbbbb367612871fede0d69529","modified":1602295777691},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"8e912c715702addaf0cefe63e580e45b97ae8c3f","modified":1602295777691},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"b4d12e6fe29089be0f43bafc9eea736602cd16bf","modified":1602295777692},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"a7fcf6e89fe195893ad9a924421d459b06d74b91","modified":1602295777692},{"_id":"themes/next/scripts/tags/index.js","hash":"255dd1090e8319b557eeca43571f0e4f8aab013b","modified":1602295777692},{"_id":"themes/next/scripts/tags/label.js","hash":"c18b0e619a779ed40be7f014db92af18f45fbd5c","modified":1602295777693},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"2ad94d9d9ea349f87ad53870abb032a8a4fab2fb","modified":1602295777693},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"96b5703f5b5042f703865723c6bdb2ec17dbd373","modified":1602295777693},{"_id":"themes/next/scripts/tags/note.js","hash":"b8669e3afc97188df46ca31997b6b205b79b6943","modified":1602295777694},{"_id":"themes/next/scripts/tags/pdf.js","hash":"7cfc7a582f44594be3a194917bc4e95b05f9dd4e","modified":1602295777694},{"_id":"themes/next/scripts/tags/tabs.js","hash":"a79d3503c1715329ffdc402cd8bcd1579ed1f191","modified":1602295777694},{"_id":"themes/next/scripts/tags/video.js","hash":"2b075ad9eff9456c3b875ca60339b41e6714a3f3","modified":1602295777695},{"_id":"themes/next/source/css/_colors.styl","hash":"f3368760774a02969bca9f99a97b5650be7daa88","modified":1602295777695},{"_id":"themes/next/source/css/_mixins.styl","hash":"e33c761d0a1db1cae304b70b153748bc479800d5","modified":1602295777726},{"_id":"themes/next/source/css/main.styl","hash":"815ef30987d02f3d76dbe4b5ee3a72135a152678","modified":1602295777737},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1602295777737},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1602295777738},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1602295777739},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1602295777740},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1602295777741},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1602295777740},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1602295777739},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1602295777741},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1602295777742},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1602295777742},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1602295777742},{"_id":"themes/next/source/images/header.jpg","hash":"23d2e50e241ffe6329bbfa70698d2ccaa5d8a48d","modified":1603726603198},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1602295777743},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1602295777743},{"_id":"themes/next/source/js/algolia-search.js","hash":"90cede179f8d58cc40b8c37883b0c02d85e0d770","modified":1602295777744},{"_id":"themes/next/source/js/bookmark.js","hash":"e808854cb650f5cd8b4ed97f41df122328b5bf08","modified":1602295777744},{"_id":"themes/next/source/js/local-search.js","hash":"ccd39fc8acb9cb50c4850469841edae02b358ba6","modified":1602295777745},{"_id":"themes/next/source/js/motion.js","hash":"20b979ebe3671cb415e6e7171485d65cc347086e","modified":1602295777745},{"_id":"themes/next/source/js/next-boot.js","hash":"75290feabb6ef0fd262da8800dfdb4f4da44476d","modified":1602295777746},{"_id":"themes/next/source/js/schedule.js","hash":"57645470647bdd1c6bb1c339404e40f4231a5595","modified":1602295777746},{"_id":"themes/next/source/js/utils.js","hash":"d3b8d810d6367327f1886af5426892009fdd3fca","modified":1602295777747},{"_id":"themes/next/test/helpers/font.js","hash":"7e44ac17d0f8efce19c38bfff332439cf8a2eb30","modified":1602295777749},{"_id":"themes/next/test/helpers/index.js","hash":"2fb58dca3df2fe53116ee2b1232fa26ebe7b2ce5","modified":1602295777749},{"_id":"themes/next/test/helpers/next-url.js","hash":"2dd87fe2acb9554ec5cf0ff6b818207c3a48efdb","modified":1602295777749},{"_id":"themes/next/test/tags/button.js","hash":"a50ca44eaec3d91c2958e3157d624cd3e68828c7","modified":1602295777750},{"_id":"themes/next/test/tags/caniuse.js","hash":"2852be850d9103c25114253a45e6c62e32517de4","modified":1602295777751},{"_id":"themes/next/test/tags/center-quote.js","hash":"2ac4b5a358681691a17e736de06fce0b640a7023","modified":1602295777751},{"_id":"themes/next/test/tags/group-pictures.js","hash":"498e9563f2d03e51726a305523d9a0cc4c55d8e2","modified":1602295777752},{"_id":"themes/next/test/tags/index.js","hash":"5cad001936a694bf32d59751cc2b68a66199f976","modified":1602295777752},{"_id":"themes/next/test/tags/link-grid.js","hash":"05c368349a5ebb385a0e6382ad19cab5e3d6528b","modified":1602295777753},{"_id":"themes/next/test/tags/label.js","hash":"6cad7d84c42511459a89cda3971e8ea5cdee0125","modified":1602295777753},{"_id":"themes/next/test/tags/mermaid.js","hash":"e4384f6a53d2af20968213bd027ad93c961d08c4","modified":1602295777753},{"_id":"themes/next/test/tags/note.js","hash":"d1d918fa0c52efe3b4763927460310e752f5b8e0","modified":1602295777754},{"_id":"themes/next/test/tags/pdf.js","hash":"161285ef5750de45c8ae5a3e01ad5c5abab5c6d9","modified":1602295777754},{"_id":"themes/next/test/tags/tabs.js","hash":"b19d2592347eae5d6a7a97ca7e8cec03e8f25b51","modified":1602295777754},{"_id":"themes/next/test/tags/video.js","hash":"246f9f212259f4eaa3f510c78f40a622bd67ec98","modified":1602295777755},{"_id":"themes/next/test/validate/index.js","hash":"e02ff921a05dfd6e5bae7558ca14705db9f57846","modified":1602295777755},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"424c285832681150191336c5771512813e808dfc","modified":1602295777652},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"681c4a545140468b89f75566aff966dcc90563c2","modified":1602295777653},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"111f2a1fcbc52738ba0dc86b0e6e20169db6ad42","modified":1602295777653},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"2f550b53372ec150c2538f216399995b8c003a21","modified":1602295777654},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"679a3c33dfeb8bff87e91b9397dfd741f2ebc3f0","modified":1602295777654},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"cb841a7a5db322dacd18c23074be300460aa6353","modified":1602295777654},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"940cad08a67e6c361214045096bd3cdffdf44fcf","modified":1602295777655},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"9c136edd2248e2d50c1f6110b75e2b75c299bbd7","modified":1602295777655},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"b352346dd2cb42f7eeaec5e39d9a2a353b029775","modified":1602295777656},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"61e8a5987ba86b30cf003fc34e8691f5669e98c0","modified":1602295777656},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"681c3f9f12ac4b6c807f8511d6bec6beab51733a","modified":1602295777657},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"752df7d12360a077c51a25609916a3ecc1763bb3","modified":1602295777657},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"0ebc0142abebbeef4278e32abb543c7d7fa75d88","modified":1602295777658},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"f6c7566a2ba6ce6812be0a88124a148b3c8941fc","modified":1602295777658},{"_id":"themes/next/layout/_partials/post/post-footer.njk","hash":"ce712c110b5ce8aacba7a86b0558ff89700675c9","modified":1602295777658},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"119a0d6c83fe1fba2e814beaeba61fe559bbc614","modified":1602295777659},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"6c80003141c9fe5f7621ba9eff12d15e1361db67","modified":1602295777660},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"bc7b047a6246df07767373644b1637d91c3a88b1","modified":1602295777659},{"_id":"themes/next/layout/_partials/search/algolia-search.njk","hash":"e955761f43b7ae6be84b0a264f77e4de7f0bca9b","modified":1602295777660},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"5a4b1cd1ffd5fd042c3d0db4a7374371eedac553","modified":1602295777661},{"_id":"themes/next/layout/_partials/search/localsearch.njk","hash":"d2e7e79dedc7f2efc13591b2f59ee50694b7615e","modified":1602295777661},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"14bdca97aca2065703546dde47a715f0c51320bc","modified":1602295777662},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"84adaadd83ce447fa9da2cff19006334c9fcbff9","modified":1602295777664},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"f7c4c6744bc304b7bb9a1621f8cdab541c56161a","modified":1602295777665},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"91c2cb900c76224c5814eeb842d1d5f517f9bf05","modified":1602295777665},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"693bd3f472d4080ba5a46b8671e5c04e2d88a6f7","modified":1602295777666},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"2642e8aef5afbe23a2a76efdc955dab2ee04ed48","modified":1602295777667},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"fb94ee487d75e484e59b7fba96e989f699ff8a83","modified":1602295777667},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"df02e478cebee56dcae1ce6db9513e859e591227","modified":1602295777668},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"71c728a386b8423b0926baea2de844943b5d77d8","modified":1602295777668},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"bd483e33585e511b4f2729a363813da395e49cad","modified":1602295777669},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"7a542a566a6d7da4ff0a16c2aaff8e144879a438","modified":1602295777669},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"897082f16c022f26803ff32235aacfe25225a95f","modified":1602295777669},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"53db57c67b3350c76a565058eb727d5f163caf2e","modified":1602295777670},{"_id":"themes/next/layout/_third-party/comments/valine.njk","hash":"3d7efb6b62aa5dec5ad19836303dcc2fe1dae314","modified":1602295777670},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"6eb39df7c30a17f1800897701cfc25403745fe49","modified":1602295777671},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"456d5b866d116bb4325536e604131e0c595a793e","modified":1602295777671},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"f84eaab792ce5a929d781483597782eddb4d1495","modified":1602295777673},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"58296a5c1883f26464c2a5ccf734c19f5fbf395a","modified":1602295777673},{"_id":"themes/next/layout/_third-party/search/swiftype.njk","hash":"aa6ab95b8b76611694613defb4bf25003d1b927f","modified":1602295777674},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"d97790e4b442a1e3ded7d7b4f84b8ee6cdb6e8ea","modified":1602295777674},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.njk","hash":"53a0760c75d5aaabb3ce8e8aa8e003510d59807f","modified":1602295777674},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"5936e8522562cdeaef27998cdb75522410a56ab8","modified":1602295777675},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"21e8a183c516ccfc05651da64a55331416792d57","modified":1602295777676},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"cc1134a92a8964747fb510282d8d32e2cc55bd1c","modified":1602295777676},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"34c5591b509756660bf2088c6f48ac397a10a4d3","modified":1602295777676},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"226e9d63bb34aca7e266c3ee9ceda9b8a0944a2f","modified":1602295777677},{"_id":"themes/next/scripts/events/lib/config.js","hash":"f6e61b13c10b4237cfd129a9317fdbba39ed2c31","modified":1602295777681},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"00cec6980cafd417def885f496371856cd524a25","modified":1602295777682},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"a150d57c6373a7cac7a18606d127173ee3d71884","modified":1602295777682},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"e3543af65817b31ed8c78289487bff0c0aae5af0","modified":1602295777682},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"87b3a02899f41aafbb59dfa9525daf384c054ccd","modified":1602295777682},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"981500bc00a7dde362cce008fa0da306e7056cc4","modified":1602295777683},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"713056d33dbcd8e9748205c5680b456c21174f4e","modified":1602295777683},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"1cb58aa6b88f7461c3c3f9605273686adcc30979","modified":1602295777684},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"e751658e87179062e9309fad0821af479d071ee3","modified":1602295777684},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"e0b77118de4d262a388ed919eb0b57fbbdbba380","modified":1602295777685},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"6f5135856163282c093fe54aa56fcbb5f920eb4d","modified":1602295777685},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"1d9cb9dec0ec4e26d9ef3ae36e11b38e9cec7383","modified":1602295777686},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"04ed7511d3566beb74dd17617b3576e5f761e527","modified":1602295777686},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"583ff1e7a2ca889f1f54eb0ca793894466823c7c","modified":1602295777735},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"1111372dde8ce520b1b5bcbd754c58640b3adb2a","modified":1602295777735},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"d3a8f6e71c86926d0c2a247a31d7446d829736d5","modified":1602295777735},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"58014a2d087c4126058a99b5b1cb7d8a2eb6224d","modified":1602295777736},{"_id":"themes/next/source/css/_variables/base.styl","hash":"e080014120856b419b31598873a9793ecb894e03","modified":1602295777737},{"_id":"themes/next/source/js/schemes/muse.js","hash":"7bcb48dcb4145cf16d4b7720cd8e140b4b4e0d72","modified":1602295777747},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"5dfdbb8616277ded731126038ba77c2e29f1b419","modified":1602295777697},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"151e5821defb9d43339b33ef2815782f7bf2230d","modified":1602295777697},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ad044edaf6d3d9402559129841061e3eaea173cb","modified":1602295777696},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"166300c5bcab8dec0fc37c5a8a9193569281bb76","modified":1602295777704},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"af6d62502b452b9a30a75318eaf87b8a535b2504","modified":1602295777713},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"b39a58d63606be5076bbbb2d9e20300a5dcfcde2","modified":1602295777713},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"fbf20cea2fc1b4507b11254845a095b9ed67dd4b","modified":1602295777718},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"f768ecb2fe3e9384777c1c115cd7409e9155edd7","modified":1602295777719},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"cf8446f4378dcab27b55ede1635c608ae6b8a5c8","modified":1602295777719},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1602295777720},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"a41ba94b7db24bd6f6f552ed107c6c3da37b88f2","modified":1602295777721},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1602295777721},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"6fd6e7d1f862238683a1591ade7aeb2b79a7599f","modified":1602295777722},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"90f7d3baab061e860172b536c9edc38c7fd2ef5c","modified":1602295777726},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"8061acb955cc8b7e2a8dd2544f65b218561d9feb","modified":1602295777727},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"b0c959561487976131edf28b1a487f5b283b09f5","modified":1602295777727},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"00366a6bd1a66f99f845c5ebfc9e8cf56651b815","modified":1602295777728},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"d369ec6137f37169b7232d1c7f89d2d717f9bedd","modified":1602295777728},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"459c3902e62444b4d9fa0c0aa7f1464d2ff6341d","modified":1602295777729},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"89bf3f6b82cb0fafbbd483431df8f450857c5a0b","modified":1602295777729},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"fd89988442f380cba907752fe3f608e3498f8c93","modified":1602295777730},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2e456f173e43baae3659a887e50984b465125899","modified":1602295777731},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"018b6a761e197086174c9f06b4d5ea21cc230951","modified":1602295777730},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"07fb7aba11843d43835e4de078492c848a508283","modified":1602295777730},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1602295777731},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1602295777731},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"6f87f78f90bac7e5275948cb21632ba99d3e5928","modified":1602295777732},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"9f60d501808f67d151af437221d0dfacc27c180c","modified":1602295777733},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"7074a552c1b471e66be1c48ae20173302fffc3c9","modified":1602295777733},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"abf2ccfb1ce8f06865e486f5d17498565c830233","modified":1602295777734},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"2814b52131cdca0e613344962de5735b5934f9ee","modified":1602295777734},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"7905f428b46d100ac5928875cb1e2b99fa86fc0b","modified":1602295777734},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fde10ce94e9ae21a03b60d41d532835b54abdcb1","modified":1602295777698},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1602295777698},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"80595d274f593b321c0b644a06f3165fe07b16f5","modified":1602295777698},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"d9409fee88f44901896d636761ea89226285eb20","modified":1602295777699},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"56d719bcdcba3d725141c55bbd4b168f3942f912","modified":1602295777699},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"d8bbe8571b9032b544d84430420a29247235fad8","modified":1602295777700},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"10b804d010c7102526473b6f7728d7d38ef0a85d","modified":1602295777700},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"b49e233cddd82804f58ebd772fcd3fc8bad24f3b","modified":1602295777701},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"784bfcff73afc0e184d7865ef40a4b4c6ec49c63","modified":1602295777701},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"c34936a17c3d8af6c0988ac6746d7509dc0b50eb","modified":1602295777701},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"b4c02a1555e8cba3d22d94e2ab7f6b6582eb4b47","modified":1602295777702},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"f5302b3a6ef8caf4c76c3bd4fe465231ce6dda10","modified":1602295777702},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"3f0375a2b6ea5eb596947f393bbab1387e25db66","modified":1602295777703},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b266d2ce5e2b117be01537889e839a69004dc0bb","modified":1602295777703},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"942943c7d5ea06b99d4e084aeb0ec2476f8586b6","modified":1602295777703},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"b87f4a06c0db893df4f756f24be182e1a4751f24","modified":1602295777704},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"fe0f1edf277b0cd23a8a4635cb0f476d165c17b7","modified":1602295777705},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"88f1b0e9034f6ef0a78ab61c7cbc02f4d65a4d83","modified":1602295777705},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"f6bd6c941f76394b43bfa883613729940587213c","modified":1602295777706},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"93dd1ea94fc4f2b2337b5ae5f0a8f7772b45b93e","modified":1602295777706},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"4f5edfecdd28dec515c1cc9e3b971da69386bb65","modified":1602295777708},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e56c5f475ed450becba48b19f2531e074538f2ec","modified":1602295777709},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"d5039344c977b41365310b52c924deabe5f4af4f","modified":1602295777709},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"46567765e0617189e09893ce017db01526bf3d2c","modified":1602295777711},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"af223db94a0785a2b308e222c5bb538f800a7a2f","modified":1602295777711},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"3ce09a0677293ba377eee13f9147cf0bed234e16","modified":1602295777711},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"8683311e79e3e5deb8f981e3aa044df4446ccfc2","modified":1602295777712},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2ce8d9b01e7ee52de4d2ac6956b5f7280b3ec356","modified":1602295777714},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"d8a028f532d562e6a86bb3b9c7b992e4b6dbbb51","modified":1602295777714},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"1c324d56ae83e96db2c4c6d63edd7ee51c936fc1","modified":1602295777715},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"0ff44ba9cec150aa204dd0b8c006b663f562dd8d","modified":1602295777715},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"6cb3b8e3d9b2751985ff429fbbadfed75879e7b0","modified":1602295777715},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"4588309bed0d9031010855b2d5a22c2027be25a1","modified":1602295777716},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"9e1d2760486c20c430190036b4c74434ca8abded","modified":1602295777716},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"782b06aad720a6225776a0c72e4a8b04633606ae","modified":1602295777717},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"8ec39a09f821cb71b21d1ab3f57346fb99cf6197","modified":1602295777717},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"e89d3a4200e517e250e8f419c1f60e4821451065","modified":1602295777718},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"a4003e1408844568cb5102a5a111046cb19b2d31","modified":1602295777720},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"172e517fa3bbd7009144bdb5640b8f535de527ad","modified":1602295777720},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"899fed183460e4648f1ffc5fab16909c70c022b7","modified":1602295777722},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"8d9218980e185210ce034e9769ab639b9630fd88","modified":1602295777723},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"474669399c6b4cca9f7a6c638eee196f4c8d479d","modified":1602295777723},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"2109f6cc249e9b504c9f9df1511e31a9cad0a740","modified":1602295777723},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"fd5af9b40afc126fea71d569b50b1fcfec8328a8","modified":1602295777724},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"2ca413420f1ce534f08ada8d23215df0afa21ee7","modified":1602295777724},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"03a5bcecc0b12231462ef6ffe432fa77ee71beff","modified":1602295777725},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"36ef19263872d426a471316905e8f34c6b1087e6","modified":1602295777725},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"25c639ea7fccc2982459e07ac9ceb8f1224c307d","modified":1602295777725},{"_id":"source/_posts/Leetcode/142/zhengming.png","hash":"96bfb8cdbad84c12839bc384ab61979cdda8dbe2","modified":1604242190431},{"_id":"public/baidusitemap.xml","hash":"7aed329898b688a852a7219e4f057fad035770d6","modified":1604814948552},{"_id":"public/atom.xml","hash":"ab8c932c14c5d16ce64e19645d328f794f090c6d","modified":1604814948552},{"_id":"public/search.xml","hash":"dc4877289d2611f249ec72ad9ddbef937c8e9e75","modified":1604814948552},{"_id":"public/sitemap.xml","hash":"87f4515f5baaedd7e9203adfd7f4061ec46712f0","modified":1604814948552},{"_id":"public/about/index.html","hash":"60f03fb9bf0df171ce7671ab18d3ac839d71af5a","modified":1604814948552},{"_id":"public/categories/index.html","hash":"8de24125925e9c52a96ecf18ca0ab0f3eba77da9","modified":1604814948552},{"_id":"public/tags/index.html","hash":"bcbfc26108acbc9fad51177ffaa9701ce8401f1c","modified":1604814948552},{"_id":"public/2020/10/27/LinuxCmd/20200814netstat/index.html","hash":"fdb8d92772eea90c70c136e66b895d7187f166c1","modified":1604814948552},{"_id":"public/archives/page/3/index.html","hash":"7dcec53d915319292b9f976188c6be4747deec4d","modified":1604814948552},{"_id":"public/archives/2020/page/3/index.html","hash":"015ea5950e2239fdc02b44758ae523105ee03dc4","modified":1604814948552},{"_id":"public/archives/2020/11/index.html","hash":"0e67955dc5712ac7a07a8bcecda1ba47cba278e4","modified":1604814948552},{"_id":"public/categories/配置/index.html","hash":"29c96ab06203e54604bd067a9d3a03f58c25ab32","modified":1604814948552},{"_id":"public/categories/leetcode/index.html","hash":"8b5132d91da8597c13b63a8a1f6a81984ce82618","modified":1604814948552},{"_id":"public/categories/leetcode-summary/index.html","hash":"b9a8ac80799414cbd753c41022b7acc57e28a087","modified":1604814948552},{"_id":"public/categories/Memory/index.html","hash":"4b27afd757355bd395e70215934efd9907ef7ff1","modified":1604814948552},{"_id":"public/tags/安装部署/index.html","hash":"41e4eebf4f350fb386eb494ee1dc0d4ac83084f2","modified":1604814948552},{"_id":"public/tags/配置/index.html","hash":"dcf82fc01387ea37aac54782396ee063577afdc0","modified":1604814948552},{"_id":"public/tags/two-pointer/index.html","hash":"f54d29e3a639b2f4d4b1a44b60bf322e2a88a0ba","modified":1604814948552},{"_id":"public/tags/algorithm/index.html","hash":"510f66287c23e22d7208907211b75590ed319659","modified":1604814948552},{"_id":"public/tags/greedy/index.html","hash":"9a55b3b255e43a9eda21e02c7faca2a746fb6bbd","modified":1604814948552},{"_id":"public/tags/dp/index.html","hash":"5da4960b0babc2a999b3d6b3537b3392c8982554","modified":1604814948552},{"_id":"public/tags/leetcode-summary/index.html","hash":"c8c41475fae1341c468e83e9288700e803f3229e","modified":1604814948552},{"_id":"public/tags/C/index.html","hash":"643140faa453fe2fc342ee0de0745d0932864548","modified":1604814948552},{"_id":"public/tags/Memory/index.html","hash":"b1f6373174cab3151f048ec74f2649d6093c6ad9","modified":1604814948552},{"_id":"public/2020/11/03/LeetcodeSummary/TwoPointer/index.html","hash":"51a27eb9c0e52602975d8ac88412a18cec1d170e","modified":1604814948552},{"_id":"public/2020/11/03/Leetcode/567/index.html","hash":"731c70e074cef171b84da0bd5b3547712105ab68","modified":1604814948552},{"_id":"public/2020/11/02/Leetcode/287/index.html","hash":"d54c6c007fd89a002a4cccd89036c72009a689aa","modified":1604814948552},{"_id":"public/2020/11/01/Leetcode/142/index.html","hash":"16f35239517684ec92d0504368b6e43170968525","modified":1604814948552},{"_id":"public/2020/10/31/Leetcode/523/index.html","hash":"e04c6bb90a38c591b1a7b282cbd086d704301441","modified":1604814948552},{"_id":"public/2020/10/30/Leetcode/1616/index.html","hash":"7d13f1abc7d7aac02d15f118383de8ab730cd5fa","modified":1604814948552},{"_id":"public/2020/10/30/Memory/Dynamic_memory_in_CPP/index.html","hash":"0f981f3a4f6f1efb5b76c873669a1efda24b621e","modified":1604814948552},{"_id":"public/2020/10/29/Leetcode/1234/index.html","hash":"1d1e0e2b8b12a1d04b071eb9ceb2d4e43a10d8a8","modified":1604814948552},{"_id":"public/2020/10/28/Leetcode/826/index.html","hash":"3dfc60d3abbaa51e67d6117813eb4c25894087b8","modified":1604814948552},{"_id":"public/2020/10/28/Config/hexo_with_image/index.html","hash":"f03cc70e72587502077bff8d73a583ebe0be64a2","modified":1604814948552},{"_id":"public/2020/10/27/Config/hexo_google_site/index.html","hash":"b79c71e1d8b51606bf44c4d7911a44dc5a2f1b6a","modified":1604814948552},{"_id":"public/2020/10/27/Leetcode/763/index.html","hash":"a2d86f2ea758bc5b55f5705eab940d53fc51d5fa","modified":1604814948552},{"_id":"public/2020/10/27/Config/hexo_config/index.html","hash":"58370ea141741f7a87d3fe6f1693da2e693d7285","modified":1604814948552},{"_id":"public/2020/10/27/Socket/20200914-socket_close_shutdown/index.html","hash":"22b7f4367a5284de7513cb7ac17e5387b353312d","modified":1604814948552},{"_id":"public/2020/10/27/Socket/2020-09-21-TCP最大连接数/index.html","hash":"3936318dcd35377f459005f71987ccc305c7835f","modified":1604814948552},{"_id":"public/2020/10/27/LinuxCmd/使用GDB查看core文件/index.html","hash":"20134775d2ef8e30536ea9ba05116a5078eca2e8","modified":1604814948552},{"_id":"public/2020/10/27/LinuxCmd/20200814-查看远程服务器的端口是否开放/index.html","hash":"9a78ec6ddacb7f796815751ad587154558a129ab","modified":1604814948552},{"_id":"public/2020/10/27/Leetcode/滑动窗口/index.html","hash":"b6b17a9349b6e941d078cac583e9a0050db34b1d","modified":1604814948552},{"_id":"public/2020/10/27/Kafka/2020-10-04-比较/index.html","hash":"f66852fb86d1760a171527da772ba8cb730beaa7","modified":1604814948552},{"_id":"public/2020/10/27/Kafka/2020-10-04-Kafka简介/index.html","hash":"cd145fb264e26baf6247688186f16208793ef2aa","modified":1604814948552},{"_id":"public/2020/10/27/Filesystem/ZFS/index.html","hash":"846e18a056a103387e7e6d5f441abab9e18dd533","modified":1604814948552},{"_id":"public/archives/index.html","hash":"cf6e3424f24b0dbce92f29d9fec6541886211612","modified":1604814948552},{"_id":"public/archives/page/2/index.html","hash":"8457fb60c03c2a301a93fced7abca60c1da8461e","modified":1604814948552},{"_id":"public/archives/2020/index.html","hash":"c99df1fc3866e54668d81f37d12a226183e23994","modified":1604814948552},{"_id":"public/archives/2020/page/2/index.html","hash":"cdf1bc262150409e912e5038b77e4596f5ce010d","modified":1604814948552},{"_id":"public/archives/2020/10/index.html","hash":"7b4533d50e8bd98aa8130bf32f4036771232f8c3","modified":1604814948552},{"_id":"public/archives/2020/10/page/2/index.html","hash":"ce78cbf7d429d67bdc2d8c225d44fecdfc275ece","modified":1604814948552},{"_id":"public/index.html","hash":"dd0d6fc7c384c7ecd8ba7dbaaa9893c57f0ed4c9","modified":1604814948552},{"_id":"public/page/2/index.html","hash":"5a1363c29736a872ec5ae104da1057505907eb9b","modified":1604814948552},{"_id":"public/page/3/index.html","hash":"6adb589696d402267ec901736d941ae3431c3708","modified":1604814948552},{"_id":"public/robots.txt","hash":"45f857b2dbde307e2e3f4b9c8a246aa74b3d652e","modified":1604408555392},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1604408555392},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1604408555392},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1604408555392},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1604408555392},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1604408555392},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1604408555392},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1604408555392},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1604408555392},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1604408555392},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1604408555392},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1604408555392},{"_id":"public/images/header.jpg","hash":"23d2e50e241ffe6329bbfa70698d2ccaa5d8a48d","modified":1604408555392},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1604408555392},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1604408555392},{"_id":"public/2020/10/27/Config/hexo_google_site/could_not_fetch.jpg","hash":"c9b2db7533e5e4f89df9cb756c661cb647eca8d7","modified":1604408555392},{"_id":"public/2020/10/27/Config/hexo_google_site/first.png","hash":"9de65aea68e6b2112290866ee983e7abdc54f587","modified":1604408555392},{"_id":"public/2020/10/27/Config/hexo_google_site/add_sitemap.png","hash":"6ae5d75519b4b1947eff136621150c3513f18f83","modified":1604408555392},{"_id":"public/google98f2983bc6265a15.html","hash":"ca760b946550415b58e28e8a5bdaa706cb6be814","modified":1604408555392},{"_id":"public/js/bookmark.js","hash":"e45e1fbb7c6d645e9c410759486216e570d02bef","modified":1604408555392},{"_id":"public/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1604408555392},{"_id":"public/js/algolia-search.js","hash":"a6f78c4cfffa976e4b8043e3486ce99aaba02bda","modified":1604408555392},{"_id":"public/js/next-boot.js","hash":"da67f3eed604dcdc4e89280c9db69fe1f62818e9","modified":1604408555392},{"_id":"public/js/local-search.js","hash":"9f4fe7bbe0f16be72d26ccb8b22bd33767f83cff","modified":1604408555392},{"_id":"public/js/schedule.js","hash":"ababd67895ce49049271601c6928fce56a1c6bbb","modified":1604408555392},{"_id":"public/js/utils.js","hash":"eed4ec020dbf499b6479cbe4e1a90b0b4fe4d1e8","modified":1604408555392},{"_id":"public/js/schemes/muse.js","hash":"d7a6c12bb534810eb748d0ba28aff67cccf0bb3f","modified":1604408555392},{"_id":"public/css/main.css","hash":"c4c98ed41aef17fc93d9b0acfe384d0a65954cbb","modified":1604408555392},{"_id":"public/2020/11/01/Leetcode/142/zhengming.png","hash":"96bfb8cdbad84c12839bc384ab61979cdda8dbe2","modified":1604408555392},{"_id":"source/_posts/Leetcode/986.md","hash":"838f4904ad98c74909c638d327a3475c166750cc","modified":1604499685980},{"_id":"public/2020/11/04/Leetcode/986/index.html","hash":"e770538138442a2b2e27624041b0bc35e58e7686","modified":1604814948552},{"_id":"source/_posts/NiceCode/142.md","hash":"06d8610c12c502d394bede84eb093c1408ce1cea","modified":1604543785015},{"_id":"public/2020/11/05/NiceCode/142/index.html","hash":"a404702e87049aff67bbbd7c2c2d3ba22b18dea4","modified":1604543792372},{"_id":"public/categories/nicecode/index.html","hash":"e337315478daca5bf6219ea14f4979bb71456813","modified":1604814948552},{"_id":"public/tags/data-structure/index.html","hash":"f8c4960f02b7fa197ba07c24869e47ad833d4b21","modified":1604814948552},{"_id":"public/tags/link-list/index.html","hash":"88d4fc612638d1d93107014509380f588288df67","modified":1604814948552},{"_id":"source/_posts/NiceCode/SkipList.md","hash":"c7b44ccafe44556f6337b1de6529917bbf61b1a6","modified":1604543959827},{"_id":"public/2020/11/05/NiceCode/SkipList/index.html","hash":"815adc72057fc003091de9de45924b9aea7e4f23","modified":1604814948552},{"_id":"source/_posts/Leetcode/925.md","hash":"241238b8e09c989f1b4e9bc5c333e8aaf925cd27","modified":1604590545183},{"_id":"public/2020/11/05/Leetcode/925/index.html","hash":"fba5e30e4362e17b42258192eb0f18a6ba246609","modified":1604814948552},{"_id":"source/_posts/Leetcode/844.md","hash":"7fd6efc9648835635b39750f5a377925ad6fc1fe","modified":1604814929174},{"_id":"public/categories/leetcode/page/2/index.html","hash":"9396fa7cee7939470b4aa5bb9064e75a7abee1ba","modified":1604814948552},{"_id":"public/tags/algorithm/page/2/index.html","hash":"a13c11cdc36584dd990bc67543ac680f17e4999b","modified":1604814948552},{"_id":"public/tags/two-pointer/page/2/index.html","hash":"7659a74bcd3ac3a5f874f74247324886656661bb","modified":1604814948552},{"_id":"public/2020/11/08/Leetcode/844/index.html","hash":"0704729e9499e29d704761cb7f3f00690bec90ab","modified":1604814948552}],"Category":[{"name":"配置","_id":"ckh1zfgyr00047ktib4wg5nun"},{"name":"leetcode","_id":"ckh1zfgyz000j7kti10l1cgzf"},{"name":"leetcode_summary","_id":"ckh1zfgzl002d7kti19cp8it3"},{"name":"Memory","_id":"ckh1zfgzn002h7ktidrnnd6c5"},{"name":"nicecode","_id":"ckh47y2n30001tgtibdz80rcj"}],"Data":[],"Page":[{"title":"about me","date":"2020-10-26T15:45:28.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about me\ndate: 2020-10-26 23:45:28\n---\n","updated":"2020-10-26T15:46:02.173Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckh1zfgym00007kti80yq58uw","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分类","date":"2020-10-26T15:43:20.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2020-10-26 23:43:20\ntype: \"categories\"\n---\n","updated":"2020-10-27T03:24:52.023Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckh1zfgyp00027ktifbbh4u6i","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2020-10-26T15:44:43.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2020-10-26 23:44:43\ntype: \"tags\"\n---\n","updated":"2020-10-27T03:28:29.360Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckh1zfgys00067kti0r3o02z1","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"hexo+github搭建个人博客","date":"2020-10-27T03:00:00.000Z","_content":"\n## 步骤\n1. 在电脑上搭建博客\n\n   ```she\n   hexo init xxx.github.io\n   ```\n\n   \n2. 修改配置文件_config.yml，添加如下内容：\n\n   ```shell\n   deploy:\n     type: git\n     repository: git@github.com:xxx/youname.github.io.git\n     branch: master\n   ```\n\n   \n3. 提交代码至仓库\n\n   ```shell\n   hexo clean # 清空缓存\n   hexo generate # 生成静态文件\n   hexo deploy # 部署至远程仓库\n   ```\n\n4.  创建分支用于保存原配置文件和原博客，因为hexo只会将它生成的静态文件上传，而不会上传相关配置文件和原markdown文件。\n\n   ```shell\n   git init\n   git checkout -b meta\n   ```\n\n5. 之后若有修改，则依次执行如下命令，**注意顺序，且在meta分支执行**\n\n   ```shell\n   hexo c && hexo g && hexo d\n   git add . && git commit -m \"change\" && git push origin meta\n   ```\n\n## 不同设备同步\n\n执行如下命令\n\n```shell\ngit clone -b meta https://github.com/XXX/xxx.git\ncd xxx.github.io\nnpm install\n\n# 之后若有修改，则执行\nhexo c && hexo g && hexo d\ngit add . && git commit -m \"change\" && git push origin meta\n```\n\n\n\n如果在别的设备上提交了，别忘了在提交之后先pull meta哈。","source":"_posts/Config/hexo_config.md","raw":"---\ntitle: hexo+github搭建个人博客\ndate: 2020-10-27 11:00:00\ntags:\n\t- 安装部署\n\t- 配置\ncategories: 配置\n---\n\n## 步骤\n1. 在电脑上搭建博客\n\n   ```she\n   hexo init xxx.github.io\n   ```\n\n   \n2. 修改配置文件_config.yml，添加如下内容：\n\n   ```shell\n   deploy:\n     type: git\n     repository: git@github.com:xxx/youname.github.io.git\n     branch: master\n   ```\n\n   \n3. 提交代码至仓库\n\n   ```shell\n   hexo clean # 清空缓存\n   hexo generate # 生成静态文件\n   hexo deploy # 部署至远程仓库\n   ```\n\n4.  创建分支用于保存原配置文件和原博客，因为hexo只会将它生成的静态文件上传，而不会上传相关配置文件和原markdown文件。\n\n   ```shell\n   git init\n   git checkout -b meta\n   ```\n\n5. 之后若有修改，则依次执行如下命令，**注意顺序，且在meta分支执行**\n\n   ```shell\n   hexo c && hexo g && hexo d\n   git add . && git commit -m \"change\" && git push origin meta\n   ```\n\n## 不同设备同步\n\n执行如下命令\n\n```shell\ngit clone -b meta https://github.com/XXX/xxx.git\ncd xxx.github.io\nnpm install\n\n# 之后若有修改，则执行\nhexo c && hexo g && hexo d\ngit add . && git commit -m \"change\" && git push origin meta\n```\n\n\n\n如果在别的设备上提交了，别忘了在提交之后先pull meta哈。","slug":"Config/hexo_config","published":1,"updated":"2020-10-27T03:20:20.112Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh1zfgyn00017ktidhf8e0sd","content":"<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><ol>\n<li><p>在电脑上搭建博客</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init xxx.github.io</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>修改配置文件_config.yml，添加如下内容：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository: git@github.com:xxx/youname.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>提交代码至仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean # 清空缓存</span><br><span class=\"line\">hexo generate # 生成静态文件</span><br><span class=\"line\">hexo deploy # 部署至远程仓库</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建分支用于保存原配置文件和原博客，因为hexo只会将它生成的静态文件上传，而不会上传相关配置文件和原markdown文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">git checkout -b meta</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>之后若有修改，则依次执行如下命令，<strong>注意顺序，且在meta分支执行</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo c &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class=\"line\">git add . &amp;&amp; git commit -m &quot;change&quot; &amp;&amp; git push origin meta</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"不同设备同步\"><a href=\"#不同设备同步\" class=\"headerlink\" title=\"不同设备同步\"></a>不同设备同步</h2><p>执行如下命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone -b meta https://github.com/XXX/xxx.git</span><br><span class=\"line\">cd xxx.github.io</span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 之后若有修改，则执行</span></span><br><span class=\"line\">hexo c &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class=\"line\">git add . &amp;&amp; git commit -m &quot;change&quot; &amp;&amp; git push origin meta</span><br></pre></td></tr></table></figure>\n\n\n\n<p>如果在别的设备上提交了，别忘了在提交之后先pull meta哈。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><ol>\n<li><p>在电脑上搭建博客</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init xxx.github.io</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>修改配置文件_config.yml，添加如下内容：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository: git@github.com:xxx/youname.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>提交代码至仓库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean # 清空缓存</span><br><span class=\"line\">hexo generate # 生成静态文件</span><br><span class=\"line\">hexo deploy # 部署至远程仓库</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建分支用于保存原配置文件和原博客，因为hexo只会将它生成的静态文件上传，而不会上传相关配置文件和原markdown文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">git checkout -b meta</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>之后若有修改，则依次执行如下命令，<strong>注意顺序，且在meta分支执行</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo c &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class=\"line\">git add . &amp;&amp; git commit -m &quot;change&quot; &amp;&amp; git push origin meta</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"不同设备同步\"><a href=\"#不同设备同步\" class=\"headerlink\" title=\"不同设备同步\"></a>不同设备同步</h2><p>执行如下命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone -b meta https://github.com/XXX/xxx.git</span><br><span class=\"line\">cd xxx.github.io</span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 之后若有修改，则执行</span></span><br><span class=\"line\">hexo c &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class=\"line\">git add . &amp;&amp; git commit -m &quot;change&quot; &amp;&amp; git push origin meta</span><br></pre></td></tr></table></figure>\n\n\n\n<p>如果在别的设备上提交了，别忘了在提交之后先pull meta哈。</p>\n"},{"title":"hexo 插入图片","date":"2020-10-27T16:09:12.000Z","_content":"\n本文主要介绍按照相对路径在hexo中插入图片的方法。\n\n## 主要步骤\n\n1. 安装插件\n\n   ```shell\n   npm install hexo-asset-image --save\n   ```\n\n2. 修改配置文件_config.yml，将如下选项该为true：\n\n   ```shell\n   post_asset_foler: true\n   ```\n   \n3. 更改文件内容：node_modules/hexo-asset-image/index.js为\n\n   ```js\n   'use strict';\n   var cheerio = require('cheerio');\n   \n   // http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string\n   function getPosition(str, m, i) {\n     return str.split(m, i).join(m).length;\n   }\n   \n   var version = String(hexo.version).split('.');\n   hexo.extend.filter.register('after_post_render', function(data){\n     var config = hexo.config;\n     if(config.post_asset_folder){\n           var link = data.permalink;\n       if(version.length > 0 && Number(version[0]) == 3)\n          var beginPos = getPosition(link, '/', 1) + 1;\n       else\n          var beginPos = getPosition(link, '/', 3) + 1;\n       // In hexo 3.1.1, the permalink of \"about\" page is like \".../about/index.html\".\n       var endPos = link.lastIndexOf('/') + 1;\n       link = link.substring(beginPos, endPos);\n   \n       var toprocess = ['excerpt', 'more', 'content'];\n       for(var i = 0; i < toprocess.length; i++){\n         var key = toprocess[i];\n    \n         var $ = cheerio.load(data[key], {\n           ignoreWhitespace: false,\n           xmlMode: false,\n           lowerCaseTags: false,\n           decodeEntities: false\n         });\n   \n         $('img').each(function(){\n           if ($(this).attr('src')){\n               // For windows style path, we replace '\\' to '/'.\n               var src = $(this).attr('src').replace('\\\\', '/');\n               if(!/http[s]*.*|\\/\\/.*/.test(src) &&\n                  !/^\\s*\\//.test(src)) {\n                 // For \"about\" page, the first part of \"src\" can't be removed.\n                 // In addition, to support multi-level local directory.\n                 var linkArray = link.split('/').filter(function(elem){\n                   return elem != '';\n                 });\n                 var srcArray = src.split('/').filter(function(elem){\n                   return elem != '' && elem != '.';\n                 });\n                 if(srcArray.length > 1)\n                   srcArray.shift();\n                 src = srcArray.join('/');\n                 $(this).attr('src', config.root + link + src);\n                 console.info&&console.info(\"update link as:-->\"+config.root + link + src);\n               }\n           }else{\n               console.info&&console.info(\"no src attr, skipped...\");\n               console.info&&console.info($(this));\n           }\n         });\n         data[key] = $.html();\n       }\n     }\n   });\n   ```\n\n   \n\n4. 至此配置完成，之后若hexo new post photo，则会在source/_posts文件夹下生成photo.md和photo文件夹，用户也可以在手动创建md文件的时候，创建对应名字的文件夹。\n\n5. 插入图片，假设photo文件夹下有如下文件图片：test.png，则用户可以在md文件中按照如下两种方式引用该图片。\n\n   ```txt\n   ![描述](test.png) # \n   ![描述](photo/test.png) # 该种方式在Typora中可以直接显示图片，推荐该种方式。\n   ```","source":"_posts/Config/hexo_with_image.md","raw":"---\ntitle: hexo 插入图片\ndate: 2020-10-28 00:09:12\ntags:\n\t- 安装部署\n\t- 配置\ncategories: 配置\n---\n\n本文主要介绍按照相对路径在hexo中插入图片的方法。\n\n## 主要步骤\n\n1. 安装插件\n\n   ```shell\n   npm install hexo-asset-image --save\n   ```\n\n2. 修改配置文件_config.yml，将如下选项该为true：\n\n   ```shell\n   post_asset_foler: true\n   ```\n   \n3. 更改文件内容：node_modules/hexo-asset-image/index.js为\n\n   ```js\n   'use strict';\n   var cheerio = require('cheerio');\n   \n   // http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string\n   function getPosition(str, m, i) {\n     return str.split(m, i).join(m).length;\n   }\n   \n   var version = String(hexo.version).split('.');\n   hexo.extend.filter.register('after_post_render', function(data){\n     var config = hexo.config;\n     if(config.post_asset_folder){\n           var link = data.permalink;\n       if(version.length > 0 && Number(version[0]) == 3)\n          var beginPos = getPosition(link, '/', 1) + 1;\n       else\n          var beginPos = getPosition(link, '/', 3) + 1;\n       // In hexo 3.1.1, the permalink of \"about\" page is like \".../about/index.html\".\n       var endPos = link.lastIndexOf('/') + 1;\n       link = link.substring(beginPos, endPos);\n   \n       var toprocess = ['excerpt', 'more', 'content'];\n       for(var i = 0; i < toprocess.length; i++){\n         var key = toprocess[i];\n    \n         var $ = cheerio.load(data[key], {\n           ignoreWhitespace: false,\n           xmlMode: false,\n           lowerCaseTags: false,\n           decodeEntities: false\n         });\n   \n         $('img').each(function(){\n           if ($(this).attr('src')){\n               // For windows style path, we replace '\\' to '/'.\n               var src = $(this).attr('src').replace('\\\\', '/');\n               if(!/http[s]*.*|\\/\\/.*/.test(src) &&\n                  !/^\\s*\\//.test(src)) {\n                 // For \"about\" page, the first part of \"src\" can't be removed.\n                 // In addition, to support multi-level local directory.\n                 var linkArray = link.split('/').filter(function(elem){\n                   return elem != '';\n                 });\n                 var srcArray = src.split('/').filter(function(elem){\n                   return elem != '' && elem != '.';\n                 });\n                 if(srcArray.length > 1)\n                   srcArray.shift();\n                 src = srcArray.join('/');\n                 $(this).attr('src', config.root + link + src);\n                 console.info&&console.info(\"update link as:-->\"+config.root + link + src);\n               }\n           }else{\n               console.info&&console.info(\"no src attr, skipped...\");\n               console.info&&console.info($(this));\n           }\n         });\n         data[key] = $.html();\n       }\n     }\n   });\n   ```\n\n   \n\n4. 至此配置完成，之后若hexo new post photo，则会在source/_posts文件夹下生成photo.md和photo文件夹，用户也可以在手动创建md文件的时候，创建对应名字的文件夹。\n\n5. 插入图片，假设photo文件夹下有如下文件图片：test.png，则用户可以在md文件中按照如下两种方式引用该图片。\n\n   ```txt\n   ![描述](test.png) # \n   ![描述](photo/test.png) # 该种方式在Typora中可以直接显示图片，推荐该种方式。\n   ```","slug":"Config/hexo_with_image","published":1,"updated":"2020-10-27T16:16:49.568Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh1zfgyp00037kti191cdodb","content":"<p>本文主要介绍按照相对路径在hexo中插入图片的方法。</p>\n<h2 id=\"主要步骤\"><a href=\"#主要步骤\" class=\"headerlink\" title=\"主要步骤\"></a>主要步骤</h2><ol>\n<li><p>安装插件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改配置文件_config.yml，将如下选项该为true：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">post_asset_foler: true</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更改文件内容：node_modules/hexo-asset-image/index.js为</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&#x27;use strict&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> cheerio = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;cheerio&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getPosition</span>(<span class=\"params\">str, m, i</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str.split(m, i).join(m).length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> version = <span class=\"built_in\">String</span>(hexo.version).split(<span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\">hexo.extend.filter.register(<span class=\"string\">&#x27;after_post_render&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> config = hexo.config;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(config.post_asset_folder)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> link = data.permalink;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(version.length &gt; <span class=\"number\">0</span> &amp;&amp; <span class=\"built_in\">Number</span>(version[<span class=\"number\">0</span>]) == <span class=\"number\">3</span>)</span><br><span class=\"line\">       <span class=\"keyword\">var</span> beginPos = getPosition(link, <span class=\"string\">&#x27;/&#x27;</span>, <span class=\"number\">1</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">       <span class=\"keyword\">var</span> beginPos = getPosition(link, <span class=\"string\">&#x27;/&#x27;</span>, <span class=\"number\">3</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> endPos = link.lastIndexOf(<span class=\"string\">&#x27;/&#x27;</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    link = link.substring(beginPos, endPos);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> toprocess = [<span class=\"string\">&#x27;excerpt&#x27;</span>, <span class=\"string\">&#x27;more&#x27;</span>, <span class=\"string\">&#x27;content&#x27;</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> key = toprocess[i];</span><br><span class=\"line\"> </span><br><span class=\"line\">      <span class=\"keyword\">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class=\"line\">        ignoreWhitespace: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        xmlMode: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        lowerCaseTags: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        decodeEntities: <span class=\"literal\">false</span></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">      $(<span class=\"string\">&#x27;img&#x27;</span>).each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ($(<span class=\"built_in\">this</span>).attr(<span class=\"string\">&#x27;src&#x27;</span>))&#123;</span><br><span class=\"line\">            <span class=\"comment\">// For windows style path, we replace &#x27;\\&#x27; to &#x27;/&#x27;.</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> src = $(<span class=\"built_in\">this</span>).attr(<span class=\"string\">&#x27;src&#x27;</span>).replace(<span class=\"string\">&#x27;\\\\&#x27;</span>, <span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!<span class=\"regexp\">/http[s]*.*|\\/\\/.*/</span>.test(src) &amp;&amp;</span><br><span class=\"line\">               !<span class=\"regexp\">/^\\s*\\//</span>.test(src)) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class=\"line\">              <span class=\"comment\">// In addition, to support multi-level local directory.</span></span><br><span class=\"line\">              <span class=\"keyword\">var</span> linkArray = link.split(<span class=\"string\">&#x27;/&#x27;</span>).filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">elem</span>)</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> elem != <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">              &#125;);</span><br><span class=\"line\">              <span class=\"keyword\">var</span> srcArray = src.split(<span class=\"string\">&#x27;/&#x27;</span>).filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">elem</span>)</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> elem != <span class=\"string\">&#x27;&#x27;</span> &amp;&amp; elem != <span class=\"string\">&#x27;.&#x27;</span>;</span><br><span class=\"line\">              &#125;);</span><br><span class=\"line\">              <span class=\"keyword\">if</span>(srcArray.length &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">                srcArray.shift();</span><br><span class=\"line\">              src = srcArray.join(<span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">              $(<span class=\"built_in\">this</span>).attr(<span class=\"string\">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class=\"line\">              <span class=\"built_in\">console</span>.info&amp;&amp;<span class=\"built_in\">console</span>.info(<span class=\"string\">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.info&amp;&amp;<span class=\"built_in\">console</span>.info(<span class=\"string\">&quot;no src attr, skipped...&quot;</span>);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.info&amp;&amp;<span class=\"built_in\">console</span>.info($(<span class=\"built_in\">this</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      data[key] = $.html();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"4\">\n<li><p>至此配置完成，之后若hexo new post photo，则会在source/_posts文件夹下生成photo.md和photo文件夹，用户也可以在手动创建md文件的时候，创建对应名字的文件夹。</p>\n</li>\n<li><p>插入图片，假设photo文件夹下有如下文件图片：test.png，则用户可以在md文件中按照如下两种方式引用该图片。</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![描述](test.png) # </span><br><span class=\"line\">![描述](photo/test.png) # 该种方式在Typora中可以直接显示图片，推荐该种方式。</span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>本文主要介绍按照相对路径在hexo中插入图片的方法。</p>\n<h2 id=\"主要步骤\"><a href=\"#主要步骤\" class=\"headerlink\" title=\"主要步骤\"></a>主要步骤</h2><ol>\n<li><p>安装插件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改配置文件_config.yml，将如下选项该为true：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">post_asset_foler: true</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更改文件内容：node_modules/hexo-asset-image/index.js为</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&#x27;use strict&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> cheerio = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;cheerio&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getPosition</span>(<span class=\"params\">str, m, i</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str.split(m, i).join(m).length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> version = <span class=\"built_in\">String</span>(hexo.version).split(<span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\">hexo.extend.filter.register(<span class=\"string\">&#x27;after_post_render&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> config = hexo.config;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(config.post_asset_folder)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> link = data.permalink;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(version.length &gt; <span class=\"number\">0</span> &amp;&amp; <span class=\"built_in\">Number</span>(version[<span class=\"number\">0</span>]) == <span class=\"number\">3</span>)</span><br><span class=\"line\">       <span class=\"keyword\">var</span> beginPos = getPosition(link, <span class=\"string\">&#x27;/&#x27;</span>, <span class=\"number\">1</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">       <span class=\"keyword\">var</span> beginPos = getPosition(link, <span class=\"string\">&#x27;/&#x27;</span>, <span class=\"number\">3</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> endPos = link.lastIndexOf(<span class=\"string\">&#x27;/&#x27;</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    link = link.substring(beginPos, endPos);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> toprocess = [<span class=\"string\">&#x27;excerpt&#x27;</span>, <span class=\"string\">&#x27;more&#x27;</span>, <span class=\"string\">&#x27;content&#x27;</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> key = toprocess[i];</span><br><span class=\"line\"> </span><br><span class=\"line\">      <span class=\"keyword\">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class=\"line\">        ignoreWhitespace: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        xmlMode: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        lowerCaseTags: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        decodeEntities: <span class=\"literal\">false</span></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">      $(<span class=\"string\">&#x27;img&#x27;</span>).each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ($(<span class=\"built_in\">this</span>).attr(<span class=\"string\">&#x27;src&#x27;</span>))&#123;</span><br><span class=\"line\">            <span class=\"comment\">// For windows style path, we replace &#x27;\\&#x27; to &#x27;/&#x27;.</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> src = $(<span class=\"built_in\">this</span>).attr(<span class=\"string\">&#x27;src&#x27;</span>).replace(<span class=\"string\">&#x27;\\\\&#x27;</span>, <span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!<span class=\"regexp\">/http[s]*.*|\\/\\/.*/</span>.test(src) &amp;&amp;</span><br><span class=\"line\">               !<span class=\"regexp\">/^\\s*\\//</span>.test(src)) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class=\"line\">              <span class=\"comment\">// In addition, to support multi-level local directory.</span></span><br><span class=\"line\">              <span class=\"keyword\">var</span> linkArray = link.split(<span class=\"string\">&#x27;/&#x27;</span>).filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">elem</span>)</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> elem != <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">              &#125;);</span><br><span class=\"line\">              <span class=\"keyword\">var</span> srcArray = src.split(<span class=\"string\">&#x27;/&#x27;</span>).filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">elem</span>)</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> elem != <span class=\"string\">&#x27;&#x27;</span> &amp;&amp; elem != <span class=\"string\">&#x27;.&#x27;</span>;</span><br><span class=\"line\">              &#125;);</span><br><span class=\"line\">              <span class=\"keyword\">if</span>(srcArray.length &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">                srcArray.shift();</span><br><span class=\"line\">              src = srcArray.join(<span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">              $(<span class=\"built_in\">this</span>).attr(<span class=\"string\">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class=\"line\">              <span class=\"built_in\">console</span>.info&amp;&amp;<span class=\"built_in\">console</span>.info(<span class=\"string\">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.info&amp;&amp;<span class=\"built_in\">console</span>.info(<span class=\"string\">&quot;no src attr, skipped...&quot;</span>);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.info&amp;&amp;<span class=\"built_in\">console</span>.info($(<span class=\"built_in\">this</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      data[key] = $.html();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"4\">\n<li><p>至此配置完成，之后若hexo new post photo，则会在source/_posts文件夹下生成photo.md和photo文件夹，用户也可以在手动创建md文件的时候，创建对应名字的文件夹。</p>\n</li>\n<li><p>插入图片，假设photo文件夹下有如下文件图片：test.png，则用户可以在md文件中按照如下两种方式引用该图片。</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![描述](test.png) # </span><br><span class=\"line\">![描述](photo/test.png) # 该种方式在Typora中可以直接显示图片，推荐该种方式。</span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"_content":"# 初识Kafka\n\n## Feture\n\n1. 消息保留：是Kafka的一个重要特性，Broker默认的消息保留策略是，要不保留一段时间，要不保留到消息到达一定的字节数。当消息总量达到这些上限时，旧消息就被过期并被删除。紧凑型日志，只有最后一个带有特定键的消息会被保留，因为，人们只关心最后时刻发生的改变。\n2. Kafka的消息复制机制只能在单个集群里进行，不能再多个集群之间进行。但是它提供一个叫做MirrorMaker的工具，可以用来实现集群之间的消息赋值。\n3. 亚秒级的消息延迟。\n\n## Kafka适用场景\n\n1. 多个生产者\n2. 多个消费者\n\n## Kafka的使用场景\n\n1. 活动跟踪，比如：用户网页访问次数和点击量。\n2. 传递消息，比如向用户发通知。使用公共组件的好处：在公共组件上做一些有趣的转换，比如把多个消息聚合成一个单独的通知，而这些工作是无法在其它地方完成的。\n3. 度量指标和日志记录。\n4. 提交日志。\n5. 流处理。\n\n# 生产者\n\n![Kafka生产者组件图](C:\\Users\\lwl\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201004160030424.png)\n\n# 消费者\n\n![消费者组群](C:\\Users\\lwl\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201005131625839.png)\n\n如果消费者组群中消费者的数量多于主题分区的个数，则会有部分消费者被闲置，不会接收到任何消息。\n\n# 深入Kafka\n\n## Controller\n\n1. Controller本质上也是一个broker，除了一般的broker的功能之外，它还负责首领的选举。集群中第一启动的Broker会在Zookeeper里创建一个临时节点/controller让自己成为控制器。\n2. Controller负责在节点加入或者离开集群时进行分区首领的选举，并且使用epoch来避免脑裂，脑裂是指两个节点同时任务自己是当前的控制器。\n\n## 复制\n\n1. Kafka是一个可分区的，可复制的提交日志服务。\n2.  副本\n   1. 首领副本：每个分区有且仅有一个首领副本，为了保证一致性，所有生产者请求和消费者请求都会经过这个副本\n   2. 跟随者副本：首领以外的副本都是跟随者副本，跟随者副本不处理来自客户端的的请求，它们唯一要做的就是从首领那里复制消息，保持与首领一致的状态，如果首领发生崩溃，则跟随者会被提升为新首领。\n\n# Broker处理请求的方式\n\n![image-20201005164403640](C:\\Users\\lwl\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201005164403640.png)\n\n![image-20201005164434878](C:\\Users\\lwl\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201005164434878.png)\n\nKafka有用其它语言实现的客户端，如C, Python， Go语言等。Kafka网站上有它们的完整清单，这些客户端就是使用二进制协议与broker通信的。\n\n\n\n## 分区分配\n\n## 文件管理\n\n1. Kafka将分区分为若干个片段。默认情况下，每个片段包含1GB或者一周的数据，以较小的那个为准。\n\n### 文件格式\n\n1. 我们把Kafka的消息和偏移量保存在文件中。\n\n2. 键、值、偏移量、消息大小、校验和、消息格式版本号、压缩算法和时间戳。时间戳可以是生产者发送消息的时间，也可以是消息到达broker的时间，这个时间是可配置的。\n\n3. 可以使用工具DUmpLogSegment来查看片段的内容，它可以显示每个消息的偏移量、校验和、魔术数、消息大小和压缩算法。\n\n   ```shell\n   bin/kafka-run-class.sh kafka.tools.DumpLogSegments\n   ```\n\n   ## 清理\n\n   1. P84页，103","source":"_posts/Kafka/2020-10-04-Kafka简介.md","raw":"# 初识Kafka\n\n## Feture\n\n1. 消息保留：是Kafka的一个重要特性，Broker默认的消息保留策略是，要不保留一段时间，要不保留到消息到达一定的字节数。当消息总量达到这些上限时，旧消息就被过期并被删除。紧凑型日志，只有最后一个带有特定键的消息会被保留，因为，人们只关心最后时刻发生的改变。\n2. Kafka的消息复制机制只能在单个集群里进行，不能再多个集群之间进行。但是它提供一个叫做MirrorMaker的工具，可以用来实现集群之间的消息赋值。\n3. 亚秒级的消息延迟。\n\n## Kafka适用场景\n\n1. 多个生产者\n2. 多个消费者\n\n## Kafka的使用场景\n\n1. 活动跟踪，比如：用户网页访问次数和点击量。\n2. 传递消息，比如向用户发通知。使用公共组件的好处：在公共组件上做一些有趣的转换，比如把多个消息聚合成一个单独的通知，而这些工作是无法在其它地方完成的。\n3. 度量指标和日志记录。\n4. 提交日志。\n5. 流处理。\n\n# 生产者\n\n![Kafka生产者组件图](C:\\Users\\lwl\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201004160030424.png)\n\n# 消费者\n\n![消费者组群](C:\\Users\\lwl\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201005131625839.png)\n\n如果消费者组群中消费者的数量多于主题分区的个数，则会有部分消费者被闲置，不会接收到任何消息。\n\n# 深入Kafka\n\n## Controller\n\n1. Controller本质上也是一个broker，除了一般的broker的功能之外，它还负责首领的选举。集群中第一启动的Broker会在Zookeeper里创建一个临时节点/controller让自己成为控制器。\n2. Controller负责在节点加入或者离开集群时进行分区首领的选举，并且使用epoch来避免脑裂，脑裂是指两个节点同时任务自己是当前的控制器。\n\n## 复制\n\n1. Kafka是一个可分区的，可复制的提交日志服务。\n2.  副本\n   1. 首领副本：每个分区有且仅有一个首领副本，为了保证一致性，所有生产者请求和消费者请求都会经过这个副本\n   2. 跟随者副本：首领以外的副本都是跟随者副本，跟随者副本不处理来自客户端的的请求，它们唯一要做的就是从首领那里复制消息，保持与首领一致的状态，如果首领发生崩溃，则跟随者会被提升为新首领。\n\n# Broker处理请求的方式\n\n![image-20201005164403640](C:\\Users\\lwl\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201005164403640.png)\n\n![image-20201005164434878](C:\\Users\\lwl\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201005164434878.png)\n\nKafka有用其它语言实现的客户端，如C, Python， Go语言等。Kafka网站上有它们的完整清单，这些客户端就是使用二进制协议与broker通信的。\n\n\n\n## 分区分配\n\n## 文件管理\n\n1. Kafka将分区分为若干个片段。默认情况下，每个片段包含1GB或者一周的数据，以较小的那个为准。\n\n### 文件格式\n\n1. 我们把Kafka的消息和偏移量保存在文件中。\n\n2. 键、值、偏移量、消息大小、校验和、消息格式版本号、压缩算法和时间戳。时间戳可以是生产者发送消息的时间，也可以是消息到达broker的时间，这个时间是可配置的。\n\n3. 可以使用工具DUmpLogSegment来查看片段的内容，它可以显示每个消息的偏移量、校验和、魔术数、消息大小和压缩算法。\n\n   ```shell\n   bin/kafka-run-class.sh kafka.tools.DumpLogSegments\n   ```\n\n   ## 清理\n\n   1. P84页，103","slug":"Kafka/2020-10-04-Kafka简介","published":1,"date":"2020-10-27T02:11:32.033Z","updated":"2020-10-10T01:08:41.754Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh1zfgys00077kticw5eh1kl","content":"<h1 id=\"初识Kafka\"><a href=\"#初识Kafka\" class=\"headerlink\" title=\"初识Kafka\"></a>初识Kafka</h1><h2 id=\"Feture\"><a href=\"#Feture\" class=\"headerlink\" title=\"Feture\"></a>Feture</h2><ol>\n<li>消息保留：是Kafka的一个重要特性，Broker默认的消息保留策略是，要不保留一段时间，要不保留到消息到达一定的字节数。当消息总量达到这些上限时，旧消息就被过期并被删除。紧凑型日志，只有最后一个带有特定键的消息会被保留，因为，人们只关心最后时刻发生的改变。</li>\n<li>Kafka的消息复制机制只能在单个集群里进行，不能再多个集群之间进行。但是它提供一个叫做MirrorMaker的工具，可以用来实现集群之间的消息赋值。</li>\n<li>亚秒级的消息延迟。</li>\n</ol>\n<h2 id=\"Kafka适用场景\"><a href=\"#Kafka适用场景\" class=\"headerlink\" title=\"Kafka适用场景\"></a>Kafka适用场景</h2><ol>\n<li>多个生产者</li>\n<li>多个消费者</li>\n</ol>\n<h2 id=\"Kafka的使用场景\"><a href=\"#Kafka的使用场景\" class=\"headerlink\" title=\"Kafka的使用场景\"></a>Kafka的使用场景</h2><ol>\n<li>活动跟踪，比如：用户网页访问次数和点击量。</li>\n<li>传递消息，比如向用户发通知。使用公共组件的好处：在公共组件上做一些有趣的转换，比如把多个消息聚合成一个单独的通知，而这些工作是无法在其它地方完成的。</li>\n<li>度量指标和日志记录。</li>\n<li>提交日志。</li>\n<li>流处理。</li>\n</ol>\n<h1 id=\"生产者\"><a href=\"#生产者\" class=\"headerlink\" title=\"生产者\"></a>生产者</h1><p><img src=\"/2020/10/27/Kafka/2020-10-04-Kafka%E7%AE%80%E4%BB%8B/Users\\lwl\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201004160030424.png\" alt=\"Kafka生产者组件图\"></p>\n<h1 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h1><p><img src=\"/2020/10/27/Kafka/2020-10-04-Kafka%E7%AE%80%E4%BB%8B/Users\\lwl\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201005131625839.png\" alt=\"消费者组群\"></p>\n<p>如果消费者组群中消费者的数量多于主题分区的个数，则会有部分消费者被闲置，不会接收到任何消息。</p>\n<h1 id=\"深入Kafka\"><a href=\"#深入Kafka\" class=\"headerlink\" title=\"深入Kafka\"></a>深入Kafka</h1><h2 id=\"Controller\"><a href=\"#Controller\" class=\"headerlink\" title=\"Controller\"></a>Controller</h2><ol>\n<li>Controller本质上也是一个broker，除了一般的broker的功能之外，它还负责首领的选举。集群中第一启动的Broker会在Zookeeper里创建一个临时节点/controller让自己成为控制器。</li>\n<li>Controller负责在节点加入或者离开集群时进行分区首领的选举，并且使用epoch来避免脑裂，脑裂是指两个节点同时任务自己是当前的控制器。</li>\n</ol>\n<h2 id=\"复制\"><a href=\"#复制\" class=\"headerlink\" title=\"复制\"></a>复制</h2><ol>\n<li>Kafka是一个可分区的，可复制的提交日志服务。</li>\n<li>副本<ol>\n<li>首领副本：每个分区有且仅有一个首领副本，为了保证一致性，所有生产者请求和消费者请求都会经过这个副本</li>\n<li>跟随者副本：首领以外的副本都是跟随者副本，跟随者副本不处理来自客户端的的请求，它们唯一要做的就是从首领那里复制消息，保持与首领一致的状态，如果首领发生崩溃，则跟随者会被提升为新首领。</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"Broker处理请求的方式\"><a href=\"#Broker处理请求的方式\" class=\"headerlink\" title=\"Broker处理请求的方式\"></a>Broker处理请求的方式</h1><p><img src=\"/2020/10/27/Kafka/2020-10-04-Kafka%E7%AE%80%E4%BB%8B/Users\\lwl\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201005164403640.png\" alt=\"image-20201005164403640\"></p>\n<p><img src=\"/2020/10/27/Kafka/2020-10-04-Kafka%E7%AE%80%E4%BB%8B/Users\\lwl\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201005164434878.png\" alt=\"image-20201005164434878\"></p>\n<p>Kafka有用其它语言实现的客户端，如C, Python， Go语言等。Kafka网站上有它们的完整清单，这些客户端就是使用二进制协议与broker通信的。</p>\n<h2 id=\"分区分配\"><a href=\"#分区分配\" class=\"headerlink\" title=\"分区分配\"></a>分区分配</h2><h2 id=\"文件管理\"><a href=\"#文件管理\" class=\"headerlink\" title=\"文件管理\"></a>文件管理</h2><ol>\n<li>Kafka将分区分为若干个片段。默认情况下，每个片段包含1GB或者一周的数据，以较小的那个为准。</li>\n</ol>\n<h3 id=\"文件格式\"><a href=\"#文件格式\" class=\"headerlink\" title=\"文件格式\"></a>文件格式</h3><ol>\n<li><p>我们把Kafka的消息和偏移量保存在文件中。</p>\n</li>\n<li><p>键、值、偏移量、消息大小、校验和、消息格式版本号、压缩算法和时间戳。时间戳可以是生产者发送消息的时间，也可以是消息到达broker的时间，这个时间是可配置的。</p>\n</li>\n<li><p>可以使用工具DUmpLogSegment来查看片段的内容，它可以显示每个消息的偏移量、校验和、魔术数、消息大小和压缩算法。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/kafka-run-class.sh kafka.tools.DumpLogSegments</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"清理\"><a href=\"#清理\" class=\"headerlink\" title=\"清理\"></a>清理</h2><ol>\n<li>P84页，103</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"初识Kafka\"><a href=\"#初识Kafka\" class=\"headerlink\" title=\"初识Kafka\"></a>初识Kafka</h1><h2 id=\"Feture\"><a href=\"#Feture\" class=\"headerlink\" title=\"Feture\"></a>Feture</h2><ol>\n<li>消息保留：是Kafka的一个重要特性，Broker默认的消息保留策略是，要不保留一段时间，要不保留到消息到达一定的字节数。当消息总量达到这些上限时，旧消息就被过期并被删除。紧凑型日志，只有最后一个带有特定键的消息会被保留，因为，人们只关心最后时刻发生的改变。</li>\n<li>Kafka的消息复制机制只能在单个集群里进行，不能再多个集群之间进行。但是它提供一个叫做MirrorMaker的工具，可以用来实现集群之间的消息赋值。</li>\n<li>亚秒级的消息延迟。</li>\n</ol>\n<h2 id=\"Kafka适用场景\"><a href=\"#Kafka适用场景\" class=\"headerlink\" title=\"Kafka适用场景\"></a>Kafka适用场景</h2><ol>\n<li>多个生产者</li>\n<li>多个消费者</li>\n</ol>\n<h2 id=\"Kafka的使用场景\"><a href=\"#Kafka的使用场景\" class=\"headerlink\" title=\"Kafka的使用场景\"></a>Kafka的使用场景</h2><ol>\n<li>活动跟踪，比如：用户网页访问次数和点击量。</li>\n<li>传递消息，比如向用户发通知。使用公共组件的好处：在公共组件上做一些有趣的转换，比如把多个消息聚合成一个单独的通知，而这些工作是无法在其它地方完成的。</li>\n<li>度量指标和日志记录。</li>\n<li>提交日志。</li>\n<li>流处理。</li>\n</ol>\n<h1 id=\"生产者\"><a href=\"#生产者\" class=\"headerlink\" title=\"生产者\"></a>生产者</h1><p><img src=\"/2020/10/27/Kafka/2020-10-04-Kafka%E7%AE%80%E4%BB%8B/Users\\lwl\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201004160030424.png\" alt=\"Kafka生产者组件图\"></p>\n<h1 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h1><p><img src=\"/2020/10/27/Kafka/2020-10-04-Kafka%E7%AE%80%E4%BB%8B/Users\\lwl\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201005131625839.png\" alt=\"消费者组群\"></p>\n<p>如果消费者组群中消费者的数量多于主题分区的个数，则会有部分消费者被闲置，不会接收到任何消息。</p>\n<h1 id=\"深入Kafka\"><a href=\"#深入Kafka\" class=\"headerlink\" title=\"深入Kafka\"></a>深入Kafka</h1><h2 id=\"Controller\"><a href=\"#Controller\" class=\"headerlink\" title=\"Controller\"></a>Controller</h2><ol>\n<li>Controller本质上也是一个broker，除了一般的broker的功能之外，它还负责首领的选举。集群中第一启动的Broker会在Zookeeper里创建一个临时节点/controller让自己成为控制器。</li>\n<li>Controller负责在节点加入或者离开集群时进行分区首领的选举，并且使用epoch来避免脑裂，脑裂是指两个节点同时任务自己是当前的控制器。</li>\n</ol>\n<h2 id=\"复制\"><a href=\"#复制\" class=\"headerlink\" title=\"复制\"></a>复制</h2><ol>\n<li>Kafka是一个可分区的，可复制的提交日志服务。</li>\n<li>副本<ol>\n<li>首领副本：每个分区有且仅有一个首领副本，为了保证一致性，所有生产者请求和消费者请求都会经过这个副本</li>\n<li>跟随者副本：首领以外的副本都是跟随者副本，跟随者副本不处理来自客户端的的请求，它们唯一要做的就是从首领那里复制消息，保持与首领一致的状态，如果首领发生崩溃，则跟随者会被提升为新首领。</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"Broker处理请求的方式\"><a href=\"#Broker处理请求的方式\" class=\"headerlink\" title=\"Broker处理请求的方式\"></a>Broker处理请求的方式</h1><p><img src=\"/2020/10/27/Kafka/2020-10-04-Kafka%E7%AE%80%E4%BB%8B/Users\\lwl\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201005164403640.png\" alt=\"image-20201005164403640\"></p>\n<p><img src=\"/2020/10/27/Kafka/2020-10-04-Kafka%E7%AE%80%E4%BB%8B/Users\\lwl\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201005164434878.png\" alt=\"image-20201005164434878\"></p>\n<p>Kafka有用其它语言实现的客户端，如C, Python， Go语言等。Kafka网站上有它们的完整清单，这些客户端就是使用二进制协议与broker通信的。</p>\n<h2 id=\"分区分配\"><a href=\"#分区分配\" class=\"headerlink\" title=\"分区分配\"></a>分区分配</h2><h2 id=\"文件管理\"><a href=\"#文件管理\" class=\"headerlink\" title=\"文件管理\"></a>文件管理</h2><ol>\n<li>Kafka将分区分为若干个片段。默认情况下，每个片段包含1GB或者一周的数据，以较小的那个为准。</li>\n</ol>\n<h3 id=\"文件格式\"><a href=\"#文件格式\" class=\"headerlink\" title=\"文件格式\"></a>文件格式</h3><ol>\n<li><p>我们把Kafka的消息和偏移量保存在文件中。</p>\n</li>\n<li><p>键、值、偏移量、消息大小、校验和、消息格式版本号、压缩算法和时间戳。时间戳可以是生产者发送消息的时间，也可以是消息到达broker的时间，这个时间是可配置的。</p>\n</li>\n<li><p>可以使用工具DUmpLogSegment来查看片段的内容，它可以显示每个消息的偏移量、校验和、魔术数、消息大小和压缩算法。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/kafka-run-class.sh kafka.tools.DumpLogSegments</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"清理\"><a href=\"#清理\" class=\"headerlink\" title=\"清理\"></a>清理</h2><ol>\n<li>P84页，103</li>\n</ol>\n</li>\n</ol>\n"},{"title":"hexo 博客被google收录","date":"2020-10-27T14:57:12.000Z","_content":"\n## 步骤\n1. 生成站点地图\n\n   ```shell\n   npm install hexo-generator-sitemap --save\n   ```\n\n2. 修改配置文件_config.yml，添加如下内容：\n\n   ```shell\n   urlgoogle: https://xxx.github.io/ \n   sitemap:\n     path: sitemap.xml\n   ```\n\n3. 修改_config.xml，设置url为你的github.io\n\n   ```xml\n   url: https://xxx.github.io\n   ```\n\n   \n\n4. 添加站点，登录[Google 网站站长](https://www.google.com/webmasters/)，进入```Search Console```，进入如下页面\n\n   ![首页](hexo_google_site/first.png)\n\n5. 选择网址前缀，输入https://xxx.github.io\n\n6. 之后，下载Google验证文件，放在```theme/next/source```目录中。\n\n7. 生成robots.xt文件，在hexo的source目录下，放入如下内容：\n\n   ```txt\n   User-agent: *\n   Allow: /\n   Allow: /home/\n   Allow: /archives/\n   Allow: /categories/\n   Allow: /tags/\n   \n   Disallow: /js/\n   Disallow: /css/\n   Disallow: /fonts/\n   \n   Sitemap: https://aerfalwl.github.io/sitemap.xml\n   ```\n\n   \n\n8. 重新生成和部署\n\n   ```shell\n   hexo clean && hexo generate && hexo deploy\n   ```\n\n9. 部署完成之后，进行验证即可，若操作无误，便会验证成功。\n\n10. 添加站点地图：\n\n   ![添加站点地图](hexo_google_site/add_sitemap.png)\n\n11. 为了加快Google扫描网站的速度，可以通过以下方式建立索引：\n\n    - 在浏览器中输入https://www.google.com/ping?sitemap=https://aerfalwl.github.io/sitemap.xml要求Google给网站建立索引；\n\n12. 等待几分钟，在Google中搜索site:aerfalwl.github.io检验是否能看到网站内容。\n\n","source":"_posts/Config/hexo_google_site.md","raw":"---\ntitle: hexo 博客被google收录\ndate: 2020-10-27 22:57:12\ntags:\n\t- 安装部署\n\t- 配置\ncategories: 配置\n---\n\n## 步骤\n1. 生成站点地图\n\n   ```shell\n   npm install hexo-generator-sitemap --save\n   ```\n\n2. 修改配置文件_config.yml，添加如下内容：\n\n   ```shell\n   urlgoogle: https://xxx.github.io/ \n   sitemap:\n     path: sitemap.xml\n   ```\n\n3. 修改_config.xml，设置url为你的github.io\n\n   ```xml\n   url: https://xxx.github.io\n   ```\n\n   \n\n4. 添加站点，登录[Google 网站站长](https://www.google.com/webmasters/)，进入```Search Console```，进入如下页面\n\n   ![首页](hexo_google_site/first.png)\n\n5. 选择网址前缀，输入https://xxx.github.io\n\n6. 之后，下载Google验证文件，放在```theme/next/source```目录中。\n\n7. 生成robots.xt文件，在hexo的source目录下，放入如下内容：\n\n   ```txt\n   User-agent: *\n   Allow: /\n   Allow: /home/\n   Allow: /archives/\n   Allow: /categories/\n   Allow: /tags/\n   \n   Disallow: /js/\n   Disallow: /css/\n   Disallow: /fonts/\n   \n   Sitemap: https://aerfalwl.github.io/sitemap.xml\n   ```\n\n   \n\n8. 重新生成和部署\n\n   ```shell\n   hexo clean && hexo generate && hexo deploy\n   ```\n\n9. 部署完成之后，进行验证即可，若操作无误，便会验证成功。\n\n10. 添加站点地图：\n\n   ![添加站点地图](hexo_google_site/add_sitemap.png)\n\n11. 为了加快Google扫描网站的速度，可以通过以下方式建立索引：\n\n    - 在浏览器中输入https://www.google.com/ping?sitemap=https://aerfalwl.github.io/sitemap.xml要求Google给网站建立索引；\n\n12. 等待几分钟，在Google中搜索site:aerfalwl.github.io检验是否能看到网站内容。\n\n","slug":"Config/hexo_google_site","published":1,"updated":"2020-10-29T01:41:57.685Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh1zfgyt00087kti62yx09td","content":"<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><ol>\n<li><p>生成站点地图</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改配置文件_config.yml，添加如下内容：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">urlgoogle: https://xxx.github.io/ </span><br><span class=\"line\">sitemap:</span><br><span class=\"line\">  path: sitemap.xml</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改_config.xml，设置url为你的github.io</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">url: https://xxx.github.io</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"4\">\n<li><p>添加站点，登录<a href=\"https://www.google.com/webmasters/\">Google 网站站长</a>，进入<code>Search Console</code>，进入如下页面</p>\n<p><img src=\"/2020/10/27/Config/hexo_google_site/first.png\" alt=\"首页\"></p>\n</li>\n<li><p>选择网址前缀，输入<a href=\"https://xxx.github.io/\">https://xxx.github.io</a></p>\n</li>\n<li><p>之后，下载Google验证文件，放在<code>theme/next/source</code>目录中。</p>\n</li>\n<li><p>生成robots.xt文件，在hexo的source目录下，放入如下内容：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">User-agent: *</span><br><span class=\"line\">Allow: /</span><br><span class=\"line\">Allow: /home/</span><br><span class=\"line\">Allow: /archives/</span><br><span class=\"line\">Allow: /categories/</span><br><span class=\"line\">Allow: /tags/</span><br><span class=\"line\"></span><br><span class=\"line\">Disallow: /js/</span><br><span class=\"line\">Disallow: /css/</span><br><span class=\"line\">Disallow: /fonts/</span><br><span class=\"line\"></span><br><span class=\"line\">Sitemap: https://aerfalwl.github.io/sitemap.xml</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"8\">\n<li><p>重新生成和部署</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>部署完成之后，进行验证即可，若操作无误，便会验证成功。</p>\n</li>\n<li><p>添加站点地图：</p>\n<p><img src=\"/2020/10/27/Config/hexo_google_site/add_sitemap.png\" alt=\"添加站点地图\"></p>\n</li>\n<li><p>为了加快Google扫描网站的速度，可以通过以下方式建立索引：</p>\n<ul>\n<li>在浏览器中输入<a href=\"https://www.google.com/ping?sitemap=https://aerfalwl.github.io/sitemap.xml%E8%A6%81%E6%B1%82Google%E7%BB%99%E7%BD%91%E7%AB%99%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%EF%BC%9B\">https://www.google.com/ping?sitemap=https://aerfalwl.github.io/sitemap.xml要求Google给网站建立索引；</a></li>\n</ul>\n</li>\n<li><p>等待几分钟，在Google中搜索site:aerfalwl.github.io检验是否能看到网站内容。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><ol>\n<li><p>生成站点地图</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改配置文件_config.yml，添加如下内容：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">urlgoogle: https://xxx.github.io/ </span><br><span class=\"line\">sitemap:</span><br><span class=\"line\">  path: sitemap.xml</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改_config.xml，设置url为你的github.io</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">url: https://xxx.github.io</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"4\">\n<li><p>添加站点，登录<a href=\"https://www.google.com/webmasters/\">Google 网站站长</a>，进入<code>Search Console</code>，进入如下页面</p>\n<p><img src=\"/2020/10/27/Config/hexo_google_site/first.png\" alt=\"首页\"></p>\n</li>\n<li><p>选择网址前缀，输入<a href=\"https://xxx.github.io/\">https://xxx.github.io</a></p>\n</li>\n<li><p>之后，下载Google验证文件，放在<code>theme/next/source</code>目录中。</p>\n</li>\n<li><p>生成robots.xt文件，在hexo的source目录下，放入如下内容：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">User-agent: *</span><br><span class=\"line\">Allow: /</span><br><span class=\"line\">Allow: /home/</span><br><span class=\"line\">Allow: /archives/</span><br><span class=\"line\">Allow: /categories/</span><br><span class=\"line\">Allow: /tags/</span><br><span class=\"line\"></span><br><span class=\"line\">Disallow: /js/</span><br><span class=\"line\">Disallow: /css/</span><br><span class=\"line\">Disallow: /fonts/</span><br><span class=\"line\"></span><br><span class=\"line\">Sitemap: https://aerfalwl.github.io/sitemap.xml</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"8\">\n<li><p>重新生成和部署</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>部署完成之后，进行验证即可，若操作无误，便会验证成功。</p>\n</li>\n<li><p>添加站点地图：</p>\n<p><img src=\"/2020/10/27/Config/hexo_google_site/add_sitemap.png\" alt=\"添加站点地图\"></p>\n</li>\n<li><p>为了加快Google扫描网站的速度，可以通过以下方式建立索引：</p>\n<ul>\n<li>在浏览器中输入<a href=\"https://www.google.com/ping?sitemap=https://aerfalwl.github.io/sitemap.xml%E8%A6%81%E6%B1%82Google%E7%BB%99%E7%BD%91%E7%AB%99%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%EF%BC%9B\">https://www.google.com/ping?sitemap=https://aerfalwl.github.io/sitemap.xml要求Google给网站建立索引；</a></li>\n</ul>\n</li>\n<li><p>等待几分钟，在Google中搜索site:aerfalwl.github.io检验是否能看到网站内容。</p>\n</li>\n</ol>\n"},{"_content":"## Kafka与Broker不同\n\n1. 消息定期清理。各个主题设置单独的保留规则，以便满足不同消费者的需求，各个主题可以保留不同数量的消息。\n2. 多个消费者可以重复消费同一条消息。\n3. Kafka可以在如下情况下自动创建主题：当一个生产者开始往主题写入消息时，当一个消费者开始从主题读取消息时，当任意一个客户端向主题发送元数据请求时。\n4. 客户端为了优化网络和磁盘空间，会对消息进行压缩，服务器需要对消息进行批量解压，设置偏移量，然后重新进行批量压缩，再保存在磁盘上。\n5. kafka允许主题的名字为null, Refactor不允许。\n6. Kafka的Consumer属于消费者组群。\n7. 消费者组群之间允许重复消费消息。![image-20201005132432782](C:\\Users\\lwl\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201005132432782.png)\n8. Kafka中所有broker都缓存了元数据，因此，客户端可以向任何一个broker发送**元数据请求**，并得到客户端所感兴趣的主题所在分区，每个分区都包含哪些副本，以及哪个副本是首领。因此，consumer需要时不时的向broker发送元数据请求来刷新本地缓存的信息。\n9. \n\n# Kafka的一些Feture\n\n1. Kafka的所有消息保存在磁盘上，存放这些日志片段的目录是通过log.dirs指定的，它是一组用逗号分割的本地文件系统路径。如果指定了多个路径，那么Broker会根据最少使用原则，把统一分区的日志片段保存在同一路径下。要注意：Broker会往拥有最少数据分区的路径新增分区，而不是往拥有最少磁盘空间的路径新增分区。\n\n2. 提供二进制连接协议，即用户直接向Kafka网络端口发送适当的字节序列，就可以实现从Kafka读取消息或往Kafka写消息\n\n3. 用户可以从指定偏移量开始读数据，例如seekToBeginning和seekToEnd\n\n4. 消费者既可以依赖于组群存在，也可以独立存在。\n\n5. 消费者请求数据的时候，可以设置broker返回数据的上限，也可以设置下限。这样可以在主题消息流量不是很大的情况下，减少CPU和网络开销。\n\n6. 日志压缩是Kafka的一个高级特性，因为有了这个特性，Kafka可以用来长时间保存数据。\n\n   \n\n## 问题处理\n\n1. Kafka也需人为设置BrokerID,需要使用者自己保证该ID是唯一的，如果两个broker使用相同的BrokerID，则第二个broker就无法启动。在Broker启动时，它通过创建临时节点把自己的ID注册到Zookeeper。Kafka组件订阅Zookeeper的/brokers/ids路径（broker在Zookeeper上的注册路径），当有broker加入集群或者退出集群时，这些组件就能获得通知。\n\n\n\n# Refactor一些可以改进的地方\n\n1. 发送消息长度超过MESSAGE_LENGTH时，返回错误码；\n2. Consumer请求的topic不在此broker上，返回相关错误码；\n\n\n\n# 日志维护\n\n## 小收获\n\n1. 除了设置socket 外，还需要设置TCP soc ke t 的读写缓冲区，它们的参数分别是net.i.pv4.tcp_wmem和net . i.pv4 . tc p_ wmem 。这些参数的值由3 个整数组成，它们使用空格分隔，分别表示最小值、默认值和最大值。最大值不能大于net.core.wmem_max可以和net.core.rmem_max指定的大小。例如，“4096 65536 204800。”表示最小值是4KB、默认值是64KB、最大值是2MB 。根据Kafka 服务器接收流量的实际情况，可能需要设置更高的最大值，为网络连接提供更大的缓冲空间。还有其他一些有用的网络参数。例如， 把net.ipv4.tcp_window_scaling 设为l ，启用TCP时间窗扩展，可以提升客户端传输数据的效率，传输的数据可以在服务器端进行缓冲。把net.1.pv4.tcp_max_syn_backlog 设为比默认值1024 更大的值，可以接受更多的井发连接, 把net.core.netdev_max_backlog 设为比默认值1000 更大的值，有助于应对网络流量的爆发，特别是在使用千兆网络的情况下，允许更多的数据包排队等待内核处理。\n2. ","source":"_posts/Kafka/2020-10-04-比较.md","raw":"## Kafka与Broker不同\n\n1. 消息定期清理。各个主题设置单独的保留规则，以便满足不同消费者的需求，各个主题可以保留不同数量的消息。\n2. 多个消费者可以重复消费同一条消息。\n3. Kafka可以在如下情况下自动创建主题：当一个生产者开始往主题写入消息时，当一个消费者开始从主题读取消息时，当任意一个客户端向主题发送元数据请求时。\n4. 客户端为了优化网络和磁盘空间，会对消息进行压缩，服务器需要对消息进行批量解压，设置偏移量，然后重新进行批量压缩，再保存在磁盘上。\n5. kafka允许主题的名字为null, Refactor不允许。\n6. Kafka的Consumer属于消费者组群。\n7. 消费者组群之间允许重复消费消息。![image-20201005132432782](C:\\Users\\lwl\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201005132432782.png)\n8. Kafka中所有broker都缓存了元数据，因此，客户端可以向任何一个broker发送**元数据请求**，并得到客户端所感兴趣的主题所在分区，每个分区都包含哪些副本，以及哪个副本是首领。因此，consumer需要时不时的向broker发送元数据请求来刷新本地缓存的信息。\n9. \n\n# Kafka的一些Feture\n\n1. Kafka的所有消息保存在磁盘上，存放这些日志片段的目录是通过log.dirs指定的，它是一组用逗号分割的本地文件系统路径。如果指定了多个路径，那么Broker会根据最少使用原则，把统一分区的日志片段保存在同一路径下。要注意：Broker会往拥有最少数据分区的路径新增分区，而不是往拥有最少磁盘空间的路径新增分区。\n\n2. 提供二进制连接协议，即用户直接向Kafka网络端口发送适当的字节序列，就可以实现从Kafka读取消息或往Kafka写消息\n\n3. 用户可以从指定偏移量开始读数据，例如seekToBeginning和seekToEnd\n\n4. 消费者既可以依赖于组群存在，也可以独立存在。\n\n5. 消费者请求数据的时候，可以设置broker返回数据的上限，也可以设置下限。这样可以在主题消息流量不是很大的情况下，减少CPU和网络开销。\n\n6. 日志压缩是Kafka的一个高级特性，因为有了这个特性，Kafka可以用来长时间保存数据。\n\n   \n\n## 问题处理\n\n1. Kafka也需人为设置BrokerID,需要使用者自己保证该ID是唯一的，如果两个broker使用相同的BrokerID，则第二个broker就无法启动。在Broker启动时，它通过创建临时节点把自己的ID注册到Zookeeper。Kafka组件订阅Zookeeper的/brokers/ids路径（broker在Zookeeper上的注册路径），当有broker加入集群或者退出集群时，这些组件就能获得通知。\n\n\n\n# Refactor一些可以改进的地方\n\n1. 发送消息长度超过MESSAGE_LENGTH时，返回错误码；\n2. Consumer请求的topic不在此broker上，返回相关错误码；\n\n\n\n# 日志维护\n\n## 小收获\n\n1. 除了设置socket 外，还需要设置TCP soc ke t 的读写缓冲区，它们的参数分别是net.i.pv4.tcp_wmem和net . i.pv4 . tc p_ wmem 。这些参数的值由3 个整数组成，它们使用空格分隔，分别表示最小值、默认值和最大值。最大值不能大于net.core.wmem_max可以和net.core.rmem_max指定的大小。例如，“4096 65536 204800。”表示最小值是4KB、默认值是64KB、最大值是2MB 。根据Kafka 服务器接收流量的实际情况，可能需要设置更高的最大值，为网络连接提供更大的缓冲空间。还有其他一些有用的网络参数。例如， 把net.ipv4.tcp_window_scaling 设为l ，启用TCP时间窗扩展，可以提升客户端传输数据的效率，传输的数据可以在服务器端进行缓冲。把net.1.pv4.tcp_max_syn_backlog 设为比默认值1024 更大的值，可以接受更多的井发连接, 把net.core.netdev_max_backlog 设为比默认值1000 更大的值，有助于应对网络流量的爆发，特别是在使用千兆网络的情况下，允许更多的数据包排队等待内核处理。\n2. ","slug":"Kafka/2020-10-04-比较","published":1,"date":"2020-10-27T02:11:32.043Z","updated":"2020-10-26T16:20:48.647Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh1zfgyu00097kti4jru7k2o","content":"<h2 id=\"Kafka与Broker不同\"><a href=\"#Kafka与Broker不同\" class=\"headerlink\" title=\"Kafka与Broker不同\"></a>Kafka与Broker不同</h2><ol>\n<li>消息定期清理。各个主题设置单独的保留规则，以便满足不同消费者的需求，各个主题可以保留不同数量的消息。</li>\n<li>多个消费者可以重复消费同一条消息。</li>\n<li>Kafka可以在如下情况下自动创建主题：当一个生产者开始往主题写入消息时，当一个消费者开始从主题读取消息时，当任意一个客户端向主题发送元数据请求时。</li>\n<li>客户端为了优化网络和磁盘空间，会对消息进行压缩，服务器需要对消息进行批量解压，设置偏移量，然后重新进行批量压缩，再保存在磁盘上。</li>\n<li>kafka允许主题的名字为null, Refactor不允许。</li>\n<li>Kafka的Consumer属于消费者组群。</li>\n<li>消费者组群之间允许重复消费消息。<img src=\"/2020/10/27/Kafka/2020-10-04-%E6%AF%94%E8%BE%83/Users\\lwl\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201005132432782.png\" alt=\"image-20201005132432782\"></li>\n<li>Kafka中所有broker都缓存了元数据，因此，客户端可以向任何一个broker发送<strong>元数据请求</strong>，并得到客户端所感兴趣的主题所在分区，每个分区都包含哪些副本，以及哪个副本是首领。因此，consumer需要时不时的向broker发送元数据请求来刷新本地缓存的信息。</li>\n<li></li>\n</ol>\n<h1 id=\"Kafka的一些Feture\"><a href=\"#Kafka的一些Feture\" class=\"headerlink\" title=\"Kafka的一些Feture\"></a>Kafka的一些Feture</h1><ol>\n<li><p>Kafka的所有消息保存在磁盘上，存放这些日志片段的目录是通过log.dirs指定的，它是一组用逗号分割的本地文件系统路径。如果指定了多个路径，那么Broker会根据最少使用原则，把统一分区的日志片段保存在同一路径下。要注意：Broker会往拥有最少数据分区的路径新增分区，而不是往拥有最少磁盘空间的路径新增分区。</p>\n</li>\n<li><p>提供二进制连接协议，即用户直接向Kafka网络端口发送适当的字节序列，就可以实现从Kafka读取消息或往Kafka写消息</p>\n</li>\n<li><p>用户可以从指定偏移量开始读数据，例如seekToBeginning和seekToEnd</p>\n</li>\n<li><p>消费者既可以依赖于组群存在，也可以独立存在。</p>\n</li>\n<li><p>消费者请求数据的时候，可以设置broker返回数据的上限，也可以设置下限。这样可以在主题消息流量不是很大的情况下，减少CPU和网络开销。</p>\n</li>\n<li><p>日志压缩是Kafka的一个高级特性，因为有了这个特性，Kafka可以用来长时间保存数据。</p>\n</li>\n</ol>\n<h2 id=\"问题处理\"><a href=\"#问题处理\" class=\"headerlink\" title=\"问题处理\"></a>问题处理</h2><ol>\n<li>Kafka也需人为设置BrokerID,需要使用者自己保证该ID是唯一的，如果两个broker使用相同的BrokerID，则第二个broker就无法启动。在Broker启动时，它通过创建临时节点把自己的ID注册到Zookeeper。Kafka组件订阅Zookeeper的/brokers/ids路径（broker在Zookeeper上的注册路径），当有broker加入集群或者退出集群时，这些组件就能获得通知。</li>\n</ol>\n<h1 id=\"Refactor一些可以改进的地方\"><a href=\"#Refactor一些可以改进的地方\" class=\"headerlink\" title=\"Refactor一些可以改进的地方\"></a>Refactor一些可以改进的地方</h1><ol>\n<li>发送消息长度超过MESSAGE_LENGTH时，返回错误码；</li>\n<li>Consumer请求的topic不在此broker上，返回相关错误码；</li>\n</ol>\n<h1 id=\"日志维护\"><a href=\"#日志维护\" class=\"headerlink\" title=\"日志维护\"></a>日志维护</h1><h2 id=\"小收获\"><a href=\"#小收获\" class=\"headerlink\" title=\"小收获\"></a>小收获</h2><ol>\n<li>除了设置socket 外，还需要设置TCP soc ke t 的读写缓冲区，它们的参数分别是net.i.pv4.tcp_wmem和net . i.pv4 . tc p_ wmem 。这些参数的值由3 个整数组成，它们使用空格分隔，分别表示最小值、默认值和最大值。最大值不能大于net.core.wmem_max可以和net.core.rmem_max指定的大小。例如，“4096 65536 204800。”表示最小值是4KB、默认值是64KB、最大值是2MB 。根据Kafka 服务器接收流量的实际情况，可能需要设置更高的最大值，为网络连接提供更大的缓冲空间。还有其他一些有用的网络参数。例如， 把net.ipv4.tcp_window_scaling 设为l ，启用TCP时间窗扩展，可以提升客户端传输数据的效率，传输的数据可以在服务器端进行缓冲。把net.1.pv4.tcp_max_syn_backlog 设为比默认值1024 更大的值，可以接受更多的井发连接, 把net.core.netdev_max_backlog 设为比默认值1000 更大的值，有助于应对网络流量的爆发，特别是在使用千兆网络的情况下，允许更多的数据包排队等待内核处理。</li>\n<li></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Kafka与Broker不同\"><a href=\"#Kafka与Broker不同\" class=\"headerlink\" title=\"Kafka与Broker不同\"></a>Kafka与Broker不同</h2><ol>\n<li>消息定期清理。各个主题设置单独的保留规则，以便满足不同消费者的需求，各个主题可以保留不同数量的消息。</li>\n<li>多个消费者可以重复消费同一条消息。</li>\n<li>Kafka可以在如下情况下自动创建主题：当一个生产者开始往主题写入消息时，当一个消费者开始从主题读取消息时，当任意一个客户端向主题发送元数据请求时。</li>\n<li>客户端为了优化网络和磁盘空间，会对消息进行压缩，服务器需要对消息进行批量解压，设置偏移量，然后重新进行批量压缩，再保存在磁盘上。</li>\n<li>kafka允许主题的名字为null, Refactor不允许。</li>\n<li>Kafka的Consumer属于消费者组群。</li>\n<li>消费者组群之间允许重复消费消息。<img src=\"/2020/10/27/Kafka/2020-10-04-%E6%AF%94%E8%BE%83/Users\\lwl\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201005132432782.png\" alt=\"image-20201005132432782\"></li>\n<li>Kafka中所有broker都缓存了元数据，因此，客户端可以向任何一个broker发送<strong>元数据请求</strong>，并得到客户端所感兴趣的主题所在分区，每个分区都包含哪些副本，以及哪个副本是首领。因此，consumer需要时不时的向broker发送元数据请求来刷新本地缓存的信息。</li>\n<li></li>\n</ol>\n<h1 id=\"Kafka的一些Feture\"><a href=\"#Kafka的一些Feture\" class=\"headerlink\" title=\"Kafka的一些Feture\"></a>Kafka的一些Feture</h1><ol>\n<li><p>Kafka的所有消息保存在磁盘上，存放这些日志片段的目录是通过log.dirs指定的，它是一组用逗号分割的本地文件系统路径。如果指定了多个路径，那么Broker会根据最少使用原则，把统一分区的日志片段保存在同一路径下。要注意：Broker会往拥有最少数据分区的路径新增分区，而不是往拥有最少磁盘空间的路径新增分区。</p>\n</li>\n<li><p>提供二进制连接协议，即用户直接向Kafka网络端口发送适当的字节序列，就可以实现从Kafka读取消息或往Kafka写消息</p>\n</li>\n<li><p>用户可以从指定偏移量开始读数据，例如seekToBeginning和seekToEnd</p>\n</li>\n<li><p>消费者既可以依赖于组群存在，也可以独立存在。</p>\n</li>\n<li><p>消费者请求数据的时候，可以设置broker返回数据的上限，也可以设置下限。这样可以在主题消息流量不是很大的情况下，减少CPU和网络开销。</p>\n</li>\n<li><p>日志压缩是Kafka的一个高级特性，因为有了这个特性，Kafka可以用来长时间保存数据。</p>\n</li>\n</ol>\n<h2 id=\"问题处理\"><a href=\"#问题处理\" class=\"headerlink\" title=\"问题处理\"></a>问题处理</h2><ol>\n<li>Kafka也需人为设置BrokerID,需要使用者自己保证该ID是唯一的，如果两个broker使用相同的BrokerID，则第二个broker就无法启动。在Broker启动时，它通过创建临时节点把自己的ID注册到Zookeeper。Kafka组件订阅Zookeeper的/brokers/ids路径（broker在Zookeeper上的注册路径），当有broker加入集群或者退出集群时，这些组件就能获得通知。</li>\n</ol>\n<h1 id=\"Refactor一些可以改进的地方\"><a href=\"#Refactor一些可以改进的地方\" class=\"headerlink\" title=\"Refactor一些可以改进的地方\"></a>Refactor一些可以改进的地方</h1><ol>\n<li>发送消息长度超过MESSAGE_LENGTH时，返回错误码；</li>\n<li>Consumer请求的topic不在此broker上，返回相关错误码；</li>\n</ol>\n<h1 id=\"日志维护\"><a href=\"#日志维护\" class=\"headerlink\" title=\"日志维护\"></a>日志维护</h1><h2 id=\"小收获\"><a href=\"#小收获\" class=\"headerlink\" title=\"小收获\"></a>小收获</h2><ol>\n<li>除了设置socket 外，还需要设置TCP soc ke t 的读写缓冲区，它们的参数分别是net.i.pv4.tcp_wmem和net . i.pv4 . tc p_ wmem 。这些参数的值由3 个整数组成，它们使用空格分隔，分别表示最小值、默认值和最大值。最大值不能大于net.core.wmem_max可以和net.core.rmem_max指定的大小。例如，“4096 65536 204800。”表示最小值是4KB、默认值是64KB、最大值是2MB 。根据Kafka 服务器接收流量的实际情况，可能需要设置更高的最大值，为网络连接提供更大的缓冲空间。还有其他一些有用的网络参数。例如， 把net.ipv4.tcp_window_scaling 设为l ，启用TCP时间窗扩展，可以提升客户端传输数据的效率，传输的数据可以在服务器端进行缓冲。把net.1.pv4.tcp_max_syn_backlog 设为比默认值1024 更大的值，可以接受更多的井发连接, 把net.core.netdev_max_backlog 设为比默认值1000 更大的值，有助于应对网络流量的爆发，特别是在使用千兆网络的情况下，允许更多的数据包排队等待内核处理。</li>\n<li></li>\n</ol>\n"},{"_content":"## Introduction to the Kernel\n\n1. 参考书籍The Design and Implementation of the FreeBSD Operating System, 2nd\n   Edition\n\n# Introduction to the Zettabyte Filesystem\n\n1. 开始于Solaries。\n2. Solaris是Sun Microsystem开发的一个Unix版本的操作系统；\n   - 它是以下两种操作系统的合并版：SunOs和System V4\n3. Sun需要解决的问题是：传统的操作系统在处理大数据的时候，显现出了很大的缺点，因为大数据使得系统需要大量的磁盘。\n4. 为解决以上问题，Sun写了ZFS:\n   - Log Structured Filesystem，由Berkeley开发，展现出了它处理大问题大数据的一些优势\n   - 文件系统不可重复写的特性，给了它很多比较好的特性。\n\n# ZFS的演变过程\n\n1. 首先出现于OpenSolaris,  该操作系统是一款Solaris开源的操作系统，包括核心科技：ZFS和DTrace\n2. 随后，ZFS出现在了FreeBSD（一款Unix操作系统）中；\n3. 之后，Sun被Oracle收购，但是Larry Ellison不是一个开源爱好者，他不同意ZFS继续开源，但是已经开源的早期版本还在流传；\n4. 于是一些公司继续开发并维护OpenSolaris，并且将他作为一个开源项目；\n5. 一些组件变得很流行，像ZFS；\n6. 最后ZFS变为单独的OpenZFS项目；\n7. 当前开发OpenZFS的主要有四个组，它们每个月都有一次会议来协同工作：\n   - 致力于OpenSolaris开发的组；\n   - FressBSD开发者；\n   - 致力于将ZFS嵌入到Linux内核的Lawrence Livermore National Laboratory\n   - 致力于将ZFS嵌入到MacOs和Windows的Jorgen Lundman\n8. Sun Community Development License与GNU Public License不兼容：\n   - ZFS代码不能嵌入到Linux内核中；\n   - 所有将ZFS带入嵌入到Linux内核的人不能使用GPL interfaces（GPL Interface是Linux的一个特性，该特性说明只有GPL的代码之间才能相互使用和修改）\n   - ZFS只能通过FUSE(用户态空间文件系统， Filesystem in Userspace)访问Linux Kernel。\n9. 在2016年，Ubuntu开源了一版在Kernel态的ZFS，它没有使用GPL interfaces，因此，自己额外开发了一些函数。当前，Canonical（开发Ubuntu的公司）还没被起诉，更多详情访问https://wiki.ubuntu.com/ZFS\n10. 当前，OpenZFS代码已经能在大多数Linux系统中配置使用。\n\nZFS相关资料：https://openzfs.org/wiki/Main_Page\n\nGithub网址：https://github.com/openzfs/zfs\n\n# Kernel I/O Structure\n\n1. 关于kernel的系统调用：\n   - 一切在硬件和系统调用之间的都是操作系统(everything between this and the hardware is the operating system)。\n   - 当我们和subsystem进行交互时，其实是在和file descriptor、socket、kqueue交互\n\n![image-20201014101848952](C:\\Users\\CCDC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201014101848952.png)\n\n# FileSystem Consistency\n\n1. 必须维护一些元数据信息：directories, inodes, bitmaps\n2. 维护元数据的一些规则：\n   - 在一个结构被初始化之前不要指向它\n   - 在将一个对象的所有指针置为空之前，不要使新指针指向它\n   - 在新指针被设置之前，不要讲老指针设置为一个可用的资源(例如，rename foo to bar，则在将foo的旧指针指向bar之后，再删除老的foo)\n\n# Keeping Metadata Consistent\n\n实现一致性的三种方法：\n\n1. 同步写\n2. 使用非易失性RAM\n3. 原子更新(journaling and logging)\n\n","source":"_posts/Filesystem/ZFS.md","raw":"## Introduction to the Kernel\n\n1. 参考书籍The Design and Implementation of the FreeBSD Operating System, 2nd\n   Edition\n\n# Introduction to the Zettabyte Filesystem\n\n1. 开始于Solaries。\n2. Solaris是Sun Microsystem开发的一个Unix版本的操作系统；\n   - 它是以下两种操作系统的合并版：SunOs和System V4\n3. Sun需要解决的问题是：传统的操作系统在处理大数据的时候，显现出了很大的缺点，因为大数据使得系统需要大量的磁盘。\n4. 为解决以上问题，Sun写了ZFS:\n   - Log Structured Filesystem，由Berkeley开发，展现出了它处理大问题大数据的一些优势\n   - 文件系统不可重复写的特性，给了它很多比较好的特性。\n\n# ZFS的演变过程\n\n1. 首先出现于OpenSolaris,  该操作系统是一款Solaris开源的操作系统，包括核心科技：ZFS和DTrace\n2. 随后，ZFS出现在了FreeBSD（一款Unix操作系统）中；\n3. 之后，Sun被Oracle收购，但是Larry Ellison不是一个开源爱好者，他不同意ZFS继续开源，但是已经开源的早期版本还在流传；\n4. 于是一些公司继续开发并维护OpenSolaris，并且将他作为一个开源项目；\n5. 一些组件变得很流行，像ZFS；\n6. 最后ZFS变为单独的OpenZFS项目；\n7. 当前开发OpenZFS的主要有四个组，它们每个月都有一次会议来协同工作：\n   - 致力于OpenSolaris开发的组；\n   - FressBSD开发者；\n   - 致力于将ZFS嵌入到Linux内核的Lawrence Livermore National Laboratory\n   - 致力于将ZFS嵌入到MacOs和Windows的Jorgen Lundman\n8. Sun Community Development License与GNU Public License不兼容：\n   - ZFS代码不能嵌入到Linux内核中；\n   - 所有将ZFS带入嵌入到Linux内核的人不能使用GPL interfaces（GPL Interface是Linux的一个特性，该特性说明只有GPL的代码之间才能相互使用和修改）\n   - ZFS只能通过FUSE(用户态空间文件系统， Filesystem in Userspace)访问Linux Kernel。\n9. 在2016年，Ubuntu开源了一版在Kernel态的ZFS，它没有使用GPL interfaces，因此，自己额外开发了一些函数。当前，Canonical（开发Ubuntu的公司）还没被起诉，更多详情访问https://wiki.ubuntu.com/ZFS\n10. 当前，OpenZFS代码已经能在大多数Linux系统中配置使用。\n\nZFS相关资料：https://openzfs.org/wiki/Main_Page\n\nGithub网址：https://github.com/openzfs/zfs\n\n# Kernel I/O Structure\n\n1. 关于kernel的系统调用：\n   - 一切在硬件和系统调用之间的都是操作系统(everything between this and the hardware is the operating system)。\n   - 当我们和subsystem进行交互时，其实是在和file descriptor、socket、kqueue交互\n\n![image-20201014101848952](C:\\Users\\CCDC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201014101848952.png)\n\n# FileSystem Consistency\n\n1. 必须维护一些元数据信息：directories, inodes, bitmaps\n2. 维护元数据的一些规则：\n   - 在一个结构被初始化之前不要指向它\n   - 在将一个对象的所有指针置为空之前，不要使新指针指向它\n   - 在新指针被设置之前，不要讲老指针设置为一个可用的资源(例如，rename foo to bar，则在将foo的旧指针指向bar之后，再删除老的foo)\n\n# Keeping Metadata Consistent\n\n实现一致性的三种方法：\n\n1. 同步写\n2. 使用非易失性RAM\n3. 原子更新(journaling and logging)\n\n","slug":"Filesystem/ZFS","published":1,"date":"2020-10-27T02:11:32.020Z","updated":"2020-10-14T02:49:09.388Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh1zfgyw000c7kti8yv3520b","content":"<h2 id=\"Introduction-to-the-Kernel\"><a href=\"#Introduction-to-the-Kernel\" class=\"headerlink\" title=\"Introduction to the Kernel\"></a>Introduction to the Kernel</h2><ol>\n<li>参考书籍The Design and Implementation of the FreeBSD Operating System, 2nd<br>Edition</li>\n</ol>\n<h1 id=\"Introduction-to-the-Zettabyte-Filesystem\"><a href=\"#Introduction-to-the-Zettabyte-Filesystem\" class=\"headerlink\" title=\"Introduction to the Zettabyte Filesystem\"></a>Introduction to the Zettabyte Filesystem</h1><ol>\n<li>开始于Solaries。</li>\n<li>Solaris是Sun Microsystem开发的一个Unix版本的操作系统；<ul>\n<li>它是以下两种操作系统的合并版：SunOs和System V4</li>\n</ul>\n</li>\n<li>Sun需要解决的问题是：传统的操作系统在处理大数据的时候，显现出了很大的缺点，因为大数据使得系统需要大量的磁盘。</li>\n<li>为解决以上问题，Sun写了ZFS:<ul>\n<li>Log Structured Filesystem，由Berkeley开发，展现出了它处理大问题大数据的一些优势</li>\n<li>文件系统不可重复写的特性，给了它很多比较好的特性。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"ZFS的演变过程\"><a href=\"#ZFS的演变过程\" class=\"headerlink\" title=\"ZFS的演变过程\"></a>ZFS的演变过程</h1><ol>\n<li>首先出现于OpenSolaris,  该操作系统是一款Solaris开源的操作系统，包括核心科技：ZFS和DTrace</li>\n<li>随后，ZFS出现在了FreeBSD（一款Unix操作系统）中；</li>\n<li>之后，Sun被Oracle收购，但是Larry Ellison不是一个开源爱好者，他不同意ZFS继续开源，但是已经开源的早期版本还在流传；</li>\n<li>于是一些公司继续开发并维护OpenSolaris，并且将他作为一个开源项目；</li>\n<li>一些组件变得很流行，像ZFS；</li>\n<li>最后ZFS变为单独的OpenZFS项目；</li>\n<li>当前开发OpenZFS的主要有四个组，它们每个月都有一次会议来协同工作：<ul>\n<li>致力于OpenSolaris开发的组；</li>\n<li>FressBSD开发者；</li>\n<li>致力于将ZFS嵌入到Linux内核的Lawrence Livermore National Laboratory</li>\n<li>致力于将ZFS嵌入到MacOs和Windows的Jorgen Lundman</li>\n</ul>\n</li>\n<li>Sun Community Development License与GNU Public License不兼容：<ul>\n<li>ZFS代码不能嵌入到Linux内核中；</li>\n<li>所有将ZFS带入嵌入到Linux内核的人不能使用GPL interfaces（GPL Interface是Linux的一个特性，该特性说明只有GPL的代码之间才能相互使用和修改）</li>\n<li>ZFS只能通过FUSE(用户态空间文件系统， Filesystem in Userspace)访问Linux Kernel。</li>\n</ul>\n</li>\n<li>在2016年，Ubuntu开源了一版在Kernel态的ZFS，它没有使用GPL interfaces，因此，自己额外开发了一些函数。当前，Canonical（开发Ubuntu的公司）还没被起诉，更多详情访问<a href=\"https://wiki.ubuntu.com/ZFS\">https://wiki.ubuntu.com/ZFS</a></li>\n<li>当前，OpenZFS代码已经能在大多数Linux系统中配置使用。</li>\n</ol>\n<p>ZFS相关资料：<a href=\"https://openzfs.org/wiki/Main_Page\">https://openzfs.org/wiki/Main_Page</a></p>\n<p>Github网址：<a href=\"https://github.com/openzfs/zfs\">https://github.com/openzfs/zfs</a></p>\n<h1 id=\"Kernel-I-O-Structure\"><a href=\"#Kernel-I-O-Structure\" class=\"headerlink\" title=\"Kernel I/O Structure\"></a>Kernel I/O Structure</h1><ol>\n<li>关于kernel的系统调用：<ul>\n<li>一切在硬件和系统调用之间的都是操作系统(everything between this and the hardware is the operating system)。</li>\n<li>当我们和subsystem进行交互时，其实是在和file descriptor、socket、kqueue交互</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/2020/10/27/Filesystem/ZFS/Users\\CCDC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201014101848952.png\" alt=\"image-20201014101848952\"></p>\n<h1 id=\"FileSystem-Consistency\"><a href=\"#FileSystem-Consistency\" class=\"headerlink\" title=\"FileSystem Consistency\"></a>FileSystem Consistency</h1><ol>\n<li>必须维护一些元数据信息：directories, inodes, bitmaps</li>\n<li>维护元数据的一些规则：<ul>\n<li>在一个结构被初始化之前不要指向它</li>\n<li>在将一个对象的所有指针置为空之前，不要使新指针指向它</li>\n<li>在新指针被设置之前，不要讲老指针设置为一个可用的资源(例如，rename foo to bar，则在将foo的旧指针指向bar之后，再删除老的foo)</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"Keeping-Metadata-Consistent\"><a href=\"#Keeping-Metadata-Consistent\" class=\"headerlink\" title=\"Keeping Metadata Consistent\"></a>Keeping Metadata Consistent</h1><p>实现一致性的三种方法：</p>\n<ol>\n<li>同步写</li>\n<li>使用非易失性RAM</li>\n<li>原子更新(journaling and logging)</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Introduction-to-the-Kernel\"><a href=\"#Introduction-to-the-Kernel\" class=\"headerlink\" title=\"Introduction to the Kernel\"></a>Introduction to the Kernel</h2><ol>\n<li>参考书籍The Design and Implementation of the FreeBSD Operating System, 2nd<br>Edition</li>\n</ol>\n<h1 id=\"Introduction-to-the-Zettabyte-Filesystem\"><a href=\"#Introduction-to-the-Zettabyte-Filesystem\" class=\"headerlink\" title=\"Introduction to the Zettabyte Filesystem\"></a>Introduction to the Zettabyte Filesystem</h1><ol>\n<li>开始于Solaries。</li>\n<li>Solaris是Sun Microsystem开发的一个Unix版本的操作系统；<ul>\n<li>它是以下两种操作系统的合并版：SunOs和System V4</li>\n</ul>\n</li>\n<li>Sun需要解决的问题是：传统的操作系统在处理大数据的时候，显现出了很大的缺点，因为大数据使得系统需要大量的磁盘。</li>\n<li>为解决以上问题，Sun写了ZFS:<ul>\n<li>Log Structured Filesystem，由Berkeley开发，展现出了它处理大问题大数据的一些优势</li>\n<li>文件系统不可重复写的特性，给了它很多比较好的特性。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"ZFS的演变过程\"><a href=\"#ZFS的演变过程\" class=\"headerlink\" title=\"ZFS的演变过程\"></a>ZFS的演变过程</h1><ol>\n<li>首先出现于OpenSolaris,  该操作系统是一款Solaris开源的操作系统，包括核心科技：ZFS和DTrace</li>\n<li>随后，ZFS出现在了FreeBSD（一款Unix操作系统）中；</li>\n<li>之后，Sun被Oracle收购，但是Larry Ellison不是一个开源爱好者，他不同意ZFS继续开源，但是已经开源的早期版本还在流传；</li>\n<li>于是一些公司继续开发并维护OpenSolaris，并且将他作为一个开源项目；</li>\n<li>一些组件变得很流行，像ZFS；</li>\n<li>最后ZFS变为单独的OpenZFS项目；</li>\n<li>当前开发OpenZFS的主要有四个组，它们每个月都有一次会议来协同工作：<ul>\n<li>致力于OpenSolaris开发的组；</li>\n<li>FressBSD开发者；</li>\n<li>致力于将ZFS嵌入到Linux内核的Lawrence Livermore National Laboratory</li>\n<li>致力于将ZFS嵌入到MacOs和Windows的Jorgen Lundman</li>\n</ul>\n</li>\n<li>Sun Community Development License与GNU Public License不兼容：<ul>\n<li>ZFS代码不能嵌入到Linux内核中；</li>\n<li>所有将ZFS带入嵌入到Linux内核的人不能使用GPL interfaces（GPL Interface是Linux的一个特性，该特性说明只有GPL的代码之间才能相互使用和修改）</li>\n<li>ZFS只能通过FUSE(用户态空间文件系统， Filesystem in Userspace)访问Linux Kernel。</li>\n</ul>\n</li>\n<li>在2016年，Ubuntu开源了一版在Kernel态的ZFS，它没有使用GPL interfaces，因此，自己额外开发了一些函数。当前，Canonical（开发Ubuntu的公司）还没被起诉，更多详情访问<a href=\"https://wiki.ubuntu.com/ZFS\">https://wiki.ubuntu.com/ZFS</a></li>\n<li>当前，OpenZFS代码已经能在大多数Linux系统中配置使用。</li>\n</ol>\n<p>ZFS相关资料：<a href=\"https://openzfs.org/wiki/Main_Page\">https://openzfs.org/wiki/Main_Page</a></p>\n<p>Github网址：<a href=\"https://github.com/openzfs/zfs\">https://github.com/openzfs/zfs</a></p>\n<h1 id=\"Kernel-I-O-Structure\"><a href=\"#Kernel-I-O-Structure\" class=\"headerlink\" title=\"Kernel I/O Structure\"></a>Kernel I/O Structure</h1><ol>\n<li>关于kernel的系统调用：<ul>\n<li>一切在硬件和系统调用之间的都是操作系统(everything between this and the hardware is the operating system)。</li>\n<li>当我们和subsystem进行交互时，其实是在和file descriptor、socket、kqueue交互</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/2020/10/27/Filesystem/ZFS/Users\\CCDC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201014101848952.png\" alt=\"image-20201014101848952\"></p>\n<h1 id=\"FileSystem-Consistency\"><a href=\"#FileSystem-Consistency\" class=\"headerlink\" title=\"FileSystem Consistency\"></a>FileSystem Consistency</h1><ol>\n<li>必须维护一些元数据信息：directories, inodes, bitmaps</li>\n<li>维护元数据的一些规则：<ul>\n<li>在一个结构被初始化之前不要指向它</li>\n<li>在将一个对象的所有指针置为空之前，不要使新指针指向它</li>\n<li>在新指针被设置之前，不要讲老指针设置为一个可用的资源(例如，rename foo to bar，则在将foo的旧指针指向bar之后，再删除老的foo)</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"Keeping-Metadata-Consistent\"><a href=\"#Keeping-Metadata-Consistent\" class=\"headerlink\" title=\"Keeping Metadata Consistent\"></a>Keeping Metadata Consistent</h1><p>实现一致性的三种方法：</p>\n<ol>\n<li>同步写</li>\n<li>使用非易失性RAM</li>\n<li>原子更新(journaling and logging)</li>\n</ol>\n"},{"title":"Leetcode 1234. Replace the Substring for Balanced String","date":"2020-10-29T12:46:24.000Z","_content":"\n\n## 题目描述\n\n[英文题目](https://leetcode.com/problems/replace-the-substring-for-balanced-string/)\n\n[中文题目](https://leetcode-cn.com/problems/replace-the-substring-for-balanced-string/)\n\n难度：中等\n\n### 题意\n\n说明：题目来自leetcode中文官网\n\n有一个只含有 'Q', 'W', 'E', 'R' 四种字符，且长度为 n 的字符串。\n\n假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。\n\n \n\n给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。\n\n你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。\n\n请返回待替换子串的最小可能长度。\n\n如果原字符串自身就是一个平衡字符串，则返回 0。\n\n**示例：**\n\n```txt\n输入：s = \"QWER\"\n输出：0\n解释：s 已经是平衡的了。\n\n------------\n输入：s = \"QQWE\"\n输出：1\n解释：我们需要把一个 'Q' 替换成 'R'，这样得到的 \"RQWE\" (或 \"QRWE\") 是平衡的。\n\n\n-------------\n输入：s = \"QQQW\"\n输出：2\n解释：我们可以把前面的 \"QQ\" 替换成 \"ER\"。\n\n-------------\n输入：s = \"QQQQ\"\n输出：3\n解释：我们可以替换后 3 个 'Q'，使 s = \"QWER\"。\n```\n\n\n\n### 解题思路\n\n该题目分类属于中等题，且用two pointer进行解决，核心思路见代码：\n\n**代码如下：**\n\n```java\nclass Solution {\n    \n    private int e = 0;\n    private int w = 1;\n    private int q = 2;\n    private int r = 3;\n    \n    public int balancedString(String s) {\n        int len = s.length();\n        \n        if (len == 0 || (len % 4 != 0)) {\n            return 0;\n        }\n        \n        int e = 0, w = 0, q = 0, r = 0;\n        \n        for (int i = 0; i < len; i++) {\n            char c = s.charAt(i);\n            if (c == 'E') {\n                e++;\n            } else if (c == 'W') {\n                w++;\n            } else if (c == 'Q') {\n                q++;\n            } else if (c == 'R') {\n                r++;\n            }\n        }\n        \n        // t为target的简写，t是每个字符的目标个数\n        int t = len / 4;\n        if (e == w && w == r && r == q) return 0;\n        \n        // 以下四行的n为need的简写，算出其离目标的距离即该字符需要变换的个数\n        // 需要注意的是，我们只计算大于目标的字符距离目标的个数，因为变换是相互的\n        // 你也可以只计算小于目标的字符距离目标的个数\n        int ne = (e <= t) ? 0 : e - t;\n        int nw = (w <= t) ? 0 : w - t;\n        int nq = (q <= t) ? 0 : q - t;\n        int nr = (r <= t) ? 0 : r - t;\n    \n        \n        int ans = len;\n        \n        int left = 0;\n        int right = 0;\n        \n        // 以下声明中，c为current的简写\n        // 下面四个变量代表在left和right指针区间内，各个字符的个数\n        int cq = 0, cw = 0, ce = 0, cr = 0;\n        \n        while (right < len) {\n            char c = s.charAt(right);\n            if (c == 'Q') {\n                cq++;\n            } else if (c == 'W') {\n                cw ++;\n            } else if (c == 'E') {\n                ce++;\n            } else if (c == 'R') {\n                cr++;\n            }\n            \n            // 如果当前的指针范围内各个字符需要变换的个数都满足需求，则我们开始\n            // 保存结果并缩小指针区间\n            while (cq >= nq && cw >= nw && ce >= ne && cr >= nr) {\n                ans = Math.min(ans, right - left + 1);\n                char leftC = s.charAt(left);\n                if (leftC == 'Q') {\n                    cq--;\n                } else if (leftC == 'W') {\n                    cw--;\n                } else if (leftC == 'E') {\n                    ce--;\n                } else if (leftC == 'R') {\n                    cr--;\n                }\n                left++;\n            }\n            \n            // 否则继续增大指针范围\n            right++;\n        } \n        \n        \n        return ans;\n    }\n    \n}\n```\n\n\n\n","source":"_posts/Leetcode/1234.md","raw":"---\ntitle: Leetcode 1234. Replace the Substring for Balanced String\ndate: 2020-10-29 20:46:24\ncategories: leetcode\ntags:\n\t- two pointer\n\t- algorithm \n---\n\n\n## 题目描述\n\n[英文题目](https://leetcode.com/problems/replace-the-substring-for-balanced-string/)\n\n[中文题目](https://leetcode-cn.com/problems/replace-the-substring-for-balanced-string/)\n\n难度：中等\n\n### 题意\n\n说明：题目来自leetcode中文官网\n\n有一个只含有 'Q', 'W', 'E', 'R' 四种字符，且长度为 n 的字符串。\n\n假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。\n\n \n\n给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。\n\n你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。\n\n请返回待替换子串的最小可能长度。\n\n如果原字符串自身就是一个平衡字符串，则返回 0。\n\n**示例：**\n\n```txt\n输入：s = \"QWER\"\n输出：0\n解释：s 已经是平衡的了。\n\n------------\n输入：s = \"QQWE\"\n输出：1\n解释：我们需要把一个 'Q' 替换成 'R'，这样得到的 \"RQWE\" (或 \"QRWE\") 是平衡的。\n\n\n-------------\n输入：s = \"QQQW\"\n输出：2\n解释：我们可以把前面的 \"QQ\" 替换成 \"ER\"。\n\n-------------\n输入：s = \"QQQQ\"\n输出：3\n解释：我们可以替换后 3 个 'Q'，使 s = \"QWER\"。\n```\n\n\n\n### 解题思路\n\n该题目分类属于中等题，且用two pointer进行解决，核心思路见代码：\n\n**代码如下：**\n\n```java\nclass Solution {\n    \n    private int e = 0;\n    private int w = 1;\n    private int q = 2;\n    private int r = 3;\n    \n    public int balancedString(String s) {\n        int len = s.length();\n        \n        if (len == 0 || (len % 4 != 0)) {\n            return 0;\n        }\n        \n        int e = 0, w = 0, q = 0, r = 0;\n        \n        for (int i = 0; i < len; i++) {\n            char c = s.charAt(i);\n            if (c == 'E') {\n                e++;\n            } else if (c == 'W') {\n                w++;\n            } else if (c == 'Q') {\n                q++;\n            } else if (c == 'R') {\n                r++;\n            }\n        }\n        \n        // t为target的简写，t是每个字符的目标个数\n        int t = len / 4;\n        if (e == w && w == r && r == q) return 0;\n        \n        // 以下四行的n为need的简写，算出其离目标的距离即该字符需要变换的个数\n        // 需要注意的是，我们只计算大于目标的字符距离目标的个数，因为变换是相互的\n        // 你也可以只计算小于目标的字符距离目标的个数\n        int ne = (e <= t) ? 0 : e - t;\n        int nw = (w <= t) ? 0 : w - t;\n        int nq = (q <= t) ? 0 : q - t;\n        int nr = (r <= t) ? 0 : r - t;\n    \n        \n        int ans = len;\n        \n        int left = 0;\n        int right = 0;\n        \n        // 以下声明中，c为current的简写\n        // 下面四个变量代表在left和right指针区间内，各个字符的个数\n        int cq = 0, cw = 0, ce = 0, cr = 0;\n        \n        while (right < len) {\n            char c = s.charAt(right);\n            if (c == 'Q') {\n                cq++;\n            } else if (c == 'W') {\n                cw ++;\n            } else if (c == 'E') {\n                ce++;\n            } else if (c == 'R') {\n                cr++;\n            }\n            \n            // 如果当前的指针范围内各个字符需要变换的个数都满足需求，则我们开始\n            // 保存结果并缩小指针区间\n            while (cq >= nq && cw >= nw && ce >= ne && cr >= nr) {\n                ans = Math.min(ans, right - left + 1);\n                char leftC = s.charAt(left);\n                if (leftC == 'Q') {\n                    cq--;\n                } else if (leftC == 'W') {\n                    cw--;\n                } else if (leftC == 'E') {\n                    ce--;\n                } else if (leftC == 'R') {\n                    cr--;\n                }\n                left++;\n            }\n            \n            // 否则继续增大指针范围\n            right++;\n        } \n        \n        \n        return ans;\n    }\n    \n}\n```\n\n\n\n","slug":"Leetcode/1234","published":1,"updated":"2020-10-29T12:49:48.357Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh1zfgyx000d7ktiedfjg7mr","content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><a href=\"https://leetcode.com/problems/replace-the-substring-for-balanced-string/\">英文题目</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/replace-the-substring-for-balanced-string/\">中文题目</a></p>\n<p>难度：中等</p>\n<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>说明：题目来自leetcode中文官网</p>\n<p>有一个只含有 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符，且长度为 n 的字符串。</p>\n<p>假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。</p>\n<p>给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。</p>\n<p>你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。</p>\n<p>请返回待替换子串的最小可能长度。</p>\n<p>如果原字符串自身就是一个平衡字符串，则返回 0。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;QWER&quot;</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：s 已经是平衡的了。</span><br><span class=\"line\"></span><br><span class=\"line\">------------</span><br><span class=\"line\">输入：s = &quot;QQWE&quot;</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：我们需要把一个 &#x27;Q&#x27; 替换成 &#x27;R&#x27;，这样得到的 &quot;RQWE&quot; (或 &quot;QRWE&quot;) 是平衡的。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-------------</span><br><span class=\"line\">输入：s = &quot;QQQW&quot;</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：我们可以把前面的 &quot;QQ&quot; 替换成 &quot;ER&quot;。</span><br><span class=\"line\"></span><br><span class=\"line\">-------------</span><br><span class=\"line\">输入：s = &quot;QQQQ&quot;</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：我们可以替换后 3 个 &#x27;Q&#x27;，使 s = &quot;QWER&quot;。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决，核心思路见代码：</p>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> e = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> w = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> q = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> r = <span class=\"number\">3</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">balancedString</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = s.length();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span> || (len % <span class=\"number\">4</span> != <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> e = <span class=\"number\">0</span>, w = <span class=\"number\">0</span>, q = <span class=\"number\">0</span>, r = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = s.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;E&#x27;</span>) &#123;</span><br><span class=\"line\">                e++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;W&#x27;</span>) &#123;</span><br><span class=\"line\">                w++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;Q&#x27;</span>) &#123;</span><br><span class=\"line\">                q++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;R&#x27;</span>) &#123;</span><br><span class=\"line\">                r++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// t为target的简写，t是每个字符的目标个数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> t = len / <span class=\"number\">4</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e == w &amp;&amp; w == r &amp;&amp; r == q) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 以下四行的n为need的简写，算出其离目标的距离即该字符需要变换的个数</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要注意的是，我们只计算大于目标的字符距离目标的个数，因为变换是相互的</span></span><br><span class=\"line\">        <span class=\"comment\">// 你也可以只计算小于目标的字符距离目标的个数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> ne = (e &lt;= t) ? <span class=\"number\">0</span> : e - t;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nw = (w &lt;= t) ? <span class=\"number\">0</span> : w - t;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nq = (q &lt;= t) ? <span class=\"number\">0</span> : q - t;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nr = (r &lt;= t) ? <span class=\"number\">0</span> : r - t;</span><br><span class=\"line\">    </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = len;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 以下声明中，c为current的简写</span></span><br><span class=\"line\">        <span class=\"comment\">// 下面四个变量代表在left和right指针区间内，各个字符的个数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> cq = <span class=\"number\">0</span>, cw = <span class=\"number\">0</span>, ce = <span class=\"number\">0</span>, cr = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (right &lt; len) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = s.charAt(right);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;Q&#x27;</span>) &#123;</span><br><span class=\"line\">                cq++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;W&#x27;</span>) &#123;</span><br><span class=\"line\">                cw ++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;E&#x27;</span>) &#123;</span><br><span class=\"line\">                ce++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;R&#x27;</span>) &#123;</span><br><span class=\"line\">                cr++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 如果当前的指针范围内各个字符需要变换的个数都满足需求，则我们开始</span></span><br><span class=\"line\">            <span class=\"comment\">// 保存结果并缩小指针区间</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (cq &gt;= nq &amp;&amp; cw &gt;= nw &amp;&amp; ce &gt;= ne &amp;&amp; cr &gt;= nr) &#123;</span><br><span class=\"line\">                ans = Math.min(ans, right - left + <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">char</span> leftC = s.charAt(left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (leftC == <span class=\"string\">&#x27;Q&#x27;</span>) &#123;</span><br><span class=\"line\">                    cq--;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (leftC == <span class=\"string\">&#x27;W&#x27;</span>) &#123;</span><br><span class=\"line\">                    cw--;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (leftC == <span class=\"string\">&#x27;E&#x27;</span>) &#123;</span><br><span class=\"line\">                    ce--;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (leftC == <span class=\"string\">&#x27;R&#x27;</span>) &#123;</span><br><span class=\"line\">                    cr--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 否则继续增大指针范围</span></span><br><span class=\"line\">            right++;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><a href=\"https://leetcode.com/problems/replace-the-substring-for-balanced-string/\">英文题目</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/replace-the-substring-for-balanced-string/\">中文题目</a></p>\n<p>难度：中等</p>\n<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>说明：题目来自leetcode中文官网</p>\n<p>有一个只含有 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符，且长度为 n 的字符串。</p>\n<p>假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。</p>\n<p>给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。</p>\n<p>你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。</p>\n<p>请返回待替换子串的最小可能长度。</p>\n<p>如果原字符串自身就是一个平衡字符串，则返回 0。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;QWER&quot;</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：s 已经是平衡的了。</span><br><span class=\"line\"></span><br><span class=\"line\">------------</span><br><span class=\"line\">输入：s = &quot;QQWE&quot;</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：我们需要把一个 &#x27;Q&#x27; 替换成 &#x27;R&#x27;，这样得到的 &quot;RQWE&quot; (或 &quot;QRWE&quot;) 是平衡的。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-------------</span><br><span class=\"line\">输入：s = &quot;QQQW&quot;</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：我们可以把前面的 &quot;QQ&quot; 替换成 &quot;ER&quot;。</span><br><span class=\"line\"></span><br><span class=\"line\">-------------</span><br><span class=\"line\">输入：s = &quot;QQQQ&quot;</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：我们可以替换后 3 个 &#x27;Q&#x27;，使 s = &quot;QWER&quot;。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决，核心思路见代码：</p>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> e = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> w = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> q = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> r = <span class=\"number\">3</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">balancedString</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = s.length();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span> || (len % <span class=\"number\">4</span> != <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> e = <span class=\"number\">0</span>, w = <span class=\"number\">0</span>, q = <span class=\"number\">0</span>, r = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = s.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;E&#x27;</span>) &#123;</span><br><span class=\"line\">                e++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;W&#x27;</span>) &#123;</span><br><span class=\"line\">                w++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;Q&#x27;</span>) &#123;</span><br><span class=\"line\">                q++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;R&#x27;</span>) &#123;</span><br><span class=\"line\">                r++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// t为target的简写，t是每个字符的目标个数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> t = len / <span class=\"number\">4</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e == w &amp;&amp; w == r &amp;&amp; r == q) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 以下四行的n为need的简写，算出其离目标的距离即该字符需要变换的个数</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要注意的是，我们只计算大于目标的字符距离目标的个数，因为变换是相互的</span></span><br><span class=\"line\">        <span class=\"comment\">// 你也可以只计算小于目标的字符距离目标的个数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> ne = (e &lt;= t) ? <span class=\"number\">0</span> : e - t;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nw = (w &lt;= t) ? <span class=\"number\">0</span> : w - t;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nq = (q &lt;= t) ? <span class=\"number\">0</span> : q - t;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nr = (r &lt;= t) ? <span class=\"number\">0</span> : r - t;</span><br><span class=\"line\">    </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = len;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 以下声明中，c为current的简写</span></span><br><span class=\"line\">        <span class=\"comment\">// 下面四个变量代表在left和right指针区间内，各个字符的个数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> cq = <span class=\"number\">0</span>, cw = <span class=\"number\">0</span>, ce = <span class=\"number\">0</span>, cr = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (right &lt; len) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = s.charAt(right);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;Q&#x27;</span>) &#123;</span><br><span class=\"line\">                cq++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;W&#x27;</span>) &#123;</span><br><span class=\"line\">                cw ++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;E&#x27;</span>) &#123;</span><br><span class=\"line\">                ce++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;R&#x27;</span>) &#123;</span><br><span class=\"line\">                cr++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 如果当前的指针范围内各个字符需要变换的个数都满足需求，则我们开始</span></span><br><span class=\"line\">            <span class=\"comment\">// 保存结果并缩小指针区间</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (cq &gt;= nq &amp;&amp; cw &gt;= nw &amp;&amp; ce &gt;= ne &amp;&amp; cr &gt;= nr) &#123;</span><br><span class=\"line\">                ans = Math.min(ans, right - left + <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">char</span> leftC = s.charAt(left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (leftC == <span class=\"string\">&#x27;Q&#x27;</span>) &#123;</span><br><span class=\"line\">                    cq--;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (leftC == <span class=\"string\">&#x27;W&#x27;</span>) &#123;</span><br><span class=\"line\">                    cw--;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (leftC == <span class=\"string\">&#x27;E&#x27;</span>) &#123;</span><br><span class=\"line\">                    ce--;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (leftC == <span class=\"string\">&#x27;R&#x27;</span>) &#123;</span><br><span class=\"line\">                    cr--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 否则继续增大指针范围</span></span><br><span class=\"line\">            right++;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"Leetcode 142. Linked List Cycle II","date":"2020-11-01T14:10:12.000Z","_content":"\n\n## 题目描述\n\n[英文题目](https://leetcode.com/problems/linked-list-cycle-ii/)\n\n[中文题目](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\n\n难度：中等\n\n### 题意\n\n简单来说，就是判断一个链表是否有环，如果有的话，返回环的起点。\n\n### 解题思路\n\n该题目分类属于中等题，且用two pointer进行解决。该问题可以拆解为两个子问题：\n\n#### 如何判断一个链表是否有环\n\n这个问题比较简单，我们设置一快一慢两个指针，快指针每次走一步，慢指针每次走两步，则如果时间充裕，两个指针一定会相遇。\n\n该问题类似于小学题目中的追击问题：操场上两个同学的跑步，一个同学的速度是`x`，另一个同学的速度是`y`，假设`x>y`，则最快多长时间两个人可以相遇？答案是`s/(x-y)`，且初次相遇时两者路程差一定是`S`。判断链表有环时，其实不能完全套用这个问题，因为两个人跑步时，操场上所有的点都是它们可以相遇的点，但是链表问题中，环上只有几个点可以是它们相遇的点，因此，初次相遇时，两者的路程差不一定是`S`，而是可能是`nS`，但是可以证明它们一定是可以相遇的。\n\n#### 如何判断环的起点\n\n证明如下图所示：\n\n![证明](142/zhengming.png)\n\n看不懂没关系，记住下面的技巧即可：\n\n简单来说：两个指针相遇之后，将快指针放回原点，慢指针位置不变，两者都以慢指针的速度遍历节点。则再次相遇时，便是环的起点。\n\n**代码如下：**\n\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        boolean flag = false;\n        while (slow != null && fast != null && fast.next != null) {\n            slow = slow.next; // 一次走一步\n            fast = fast.next.next; // 一次走两步\n            if (slow == fast) {\n                flag = true;\n                break;\n            }\n        }\n        if (flag == false) return null;\n        fast = head; // 快指针放回起点\n        while (fast != slow) { \n            fast = fast.next; // 以相同速度前进 \n            slow = slow.next; // 以相同速度前进 \n        }\n        return slow; // 交点即环的起点\n        \n    }\n}\n```\n\n### 总结\n\n1. 两个指针：慢指针和快指针，慢指针一次走一步，快指针一次走两步。如果两个指针相遇，就是有环，如果两个指针不相遇，就是没环。\n2. 将快指针放回链表起点，慢指针位置不变，两者都以慢速遍历指针，再次相遇的点即为环的起点。","source":"_posts/Leetcode/142.md","raw":"---\ntitle: Leetcode 142. Linked List Cycle II\ndate: 2020-11-01 22:10:12\ncategories: leetcode\ntags:\n\t- two pointer\n\t- algorithm \n---\n\n\n## 题目描述\n\n[英文题目](https://leetcode.com/problems/linked-list-cycle-ii/)\n\n[中文题目](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\n\n难度：中等\n\n### 题意\n\n简单来说，就是判断一个链表是否有环，如果有的话，返回环的起点。\n\n### 解题思路\n\n该题目分类属于中等题，且用two pointer进行解决。该问题可以拆解为两个子问题：\n\n#### 如何判断一个链表是否有环\n\n这个问题比较简单，我们设置一快一慢两个指针，快指针每次走一步，慢指针每次走两步，则如果时间充裕，两个指针一定会相遇。\n\n该问题类似于小学题目中的追击问题：操场上两个同学的跑步，一个同学的速度是`x`，另一个同学的速度是`y`，假设`x>y`，则最快多长时间两个人可以相遇？答案是`s/(x-y)`，且初次相遇时两者路程差一定是`S`。判断链表有环时，其实不能完全套用这个问题，因为两个人跑步时，操场上所有的点都是它们可以相遇的点，但是链表问题中，环上只有几个点可以是它们相遇的点，因此，初次相遇时，两者的路程差不一定是`S`，而是可能是`nS`，但是可以证明它们一定是可以相遇的。\n\n#### 如何判断环的起点\n\n证明如下图所示：\n\n![证明](142/zhengming.png)\n\n看不懂没关系，记住下面的技巧即可：\n\n简单来说：两个指针相遇之后，将快指针放回原点，慢指针位置不变，两者都以慢指针的速度遍历节点。则再次相遇时，便是环的起点。\n\n**代码如下：**\n\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        boolean flag = false;\n        while (slow != null && fast != null && fast.next != null) {\n            slow = slow.next; // 一次走一步\n            fast = fast.next.next; // 一次走两步\n            if (slow == fast) {\n                flag = true;\n                break;\n            }\n        }\n        if (flag == false) return null;\n        fast = head; // 快指针放回起点\n        while (fast != slow) { \n            fast = fast.next; // 以相同速度前进 \n            slow = slow.next; // 以相同速度前进 \n        }\n        return slow; // 交点即环的起点\n        \n    }\n}\n```\n\n### 总结\n\n1. 两个指针：慢指针和快指针，慢指针一次走一步，快指针一次走两步。如果两个指针相遇，就是有环，如果两个指针不相遇，就是没环。\n2. 将快指针放回链表起点，慢指针位置不变，两者都以慢速遍历指针，再次相遇的点即为环的起点。","slug":"Leetcode/142","published":1,"updated":"2020-11-01T15:02:50.639Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh1zfgyy000g7kti5rnahsa8","content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><a href=\"https://leetcode.com/problems/linked-list-cycle-ii/\">英文题目</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/linked-list-cycle-ii/\">中文题目</a></p>\n<p>难度：中等</p>\n<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>简单来说，就是判断一个链表是否有环，如果有的话，返回环的起点。</p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决。该问题可以拆解为两个子问题：</p>\n<h4 id=\"如何判断一个链表是否有环\"><a href=\"#如何判断一个链表是否有环\" class=\"headerlink\" title=\"如何判断一个链表是否有环\"></a>如何判断一个链表是否有环</h4><p>这个问题比较简单，我们设置一快一慢两个指针，快指针每次走一步，慢指针每次走两步，则如果时间充裕，两个指针一定会相遇。</p>\n<p>该问题类似于小学题目中的追击问题：操场上两个同学的跑步，一个同学的速度是<code>x</code>，另一个同学的速度是<code>y</code>，假设<code>x&gt;y</code>，则最快多长时间两个人可以相遇？答案是<code>s/(x-y)</code>，且初次相遇时两者路程差一定是<code>S</code>。判断链表有环时，其实不能完全套用这个问题，因为两个人跑步时，操场上所有的点都是它们可以相遇的点，但是链表问题中，环上只有几个点可以是它们相遇的点，因此，初次相遇时，两者的路程差不一定是<code>S</code>，而是可能是<code>nS</code>，但是可以证明它们一定是可以相遇的。</p>\n<h4 id=\"如何判断环的起点\"><a href=\"#如何判断环的起点\" class=\"headerlink\" title=\"如何判断环的起点\"></a>如何判断环的起点</h4><p>证明如下图所示：</p>\n<p><img src=\"/2020/11/01/Leetcode/142/zhengming.png\" alt=\"证明\"></p>\n<p>看不懂没关系，记住下面的技巧即可：</p>\n<p>简单来说：两个指针相遇之后，将快指针放回原点，慢指针位置不变，两者都以慢指针的速度遍历节点。则再次相遇时，便是环的起点。</p>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         val = x;</span></span><br><span class=\"line\"><span class=\"comment\"> *         next = null;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">detectCycle</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode slow = head;</span><br><span class=\"line\">        ListNode fast = head;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (slow != <span class=\"keyword\">null</span> &amp;&amp; fast != <span class=\"keyword\">null</span> &amp;&amp; fast.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            slow = slow.next; <span class=\"comment\">// 一次走一步</span></span><br><span class=\"line\">            fast = fast.next.next; <span class=\"comment\">// 一次走两步</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (slow == fast) &#123;</span><br><span class=\"line\">                flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag == <span class=\"keyword\">false</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        fast = head; <span class=\"comment\">// 快指针放回起点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (fast != slow) &#123; </span><br><span class=\"line\">            fast = fast.next; <span class=\"comment\">// 以相同速度前进 </span></span><br><span class=\"line\">            slow = slow.next; <span class=\"comment\">// 以相同速度前进 </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> slow; <span class=\"comment\">// 交点即环的起点</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>两个指针：慢指针和快指针，慢指针一次走一步，快指针一次走两步。如果两个指针相遇，就是有环，如果两个指针不相遇，就是没环。</li>\n<li>将快指针放回链表起点，慢指针位置不变，两者都以慢速遍历指针，再次相遇的点即为环的起点。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><a href=\"https://leetcode.com/problems/linked-list-cycle-ii/\">英文题目</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/linked-list-cycle-ii/\">中文题目</a></p>\n<p>难度：中等</p>\n<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>简单来说，就是判断一个链表是否有环，如果有的话，返回环的起点。</p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决。该问题可以拆解为两个子问题：</p>\n<h4 id=\"如何判断一个链表是否有环\"><a href=\"#如何判断一个链表是否有环\" class=\"headerlink\" title=\"如何判断一个链表是否有环\"></a>如何判断一个链表是否有环</h4><p>这个问题比较简单，我们设置一快一慢两个指针，快指针每次走一步，慢指针每次走两步，则如果时间充裕，两个指针一定会相遇。</p>\n<p>该问题类似于小学题目中的追击问题：操场上两个同学的跑步，一个同学的速度是<code>x</code>，另一个同学的速度是<code>y</code>，假设<code>x&gt;y</code>，则最快多长时间两个人可以相遇？答案是<code>s/(x-y)</code>，且初次相遇时两者路程差一定是<code>S</code>。判断链表有环时，其实不能完全套用这个问题，因为两个人跑步时，操场上所有的点都是它们可以相遇的点，但是链表问题中，环上只有几个点可以是它们相遇的点，因此，初次相遇时，两者的路程差不一定是<code>S</code>，而是可能是<code>nS</code>，但是可以证明它们一定是可以相遇的。</p>\n<h4 id=\"如何判断环的起点\"><a href=\"#如何判断环的起点\" class=\"headerlink\" title=\"如何判断环的起点\"></a>如何判断环的起点</h4><p>证明如下图所示：</p>\n<p><img src=\"/2020/11/01/Leetcode/142/zhengming.png\" alt=\"证明\"></p>\n<p>看不懂没关系，记住下面的技巧即可：</p>\n<p>简单来说：两个指针相遇之后，将快指针放回原点，慢指针位置不变，两者都以慢指针的速度遍历节点。则再次相遇时，便是环的起点。</p>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         val = x;</span></span><br><span class=\"line\"><span class=\"comment\"> *         next = null;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">detectCycle</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode slow = head;</span><br><span class=\"line\">        ListNode fast = head;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (slow != <span class=\"keyword\">null</span> &amp;&amp; fast != <span class=\"keyword\">null</span> &amp;&amp; fast.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            slow = slow.next; <span class=\"comment\">// 一次走一步</span></span><br><span class=\"line\">            fast = fast.next.next; <span class=\"comment\">// 一次走两步</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (slow == fast) &#123;</span><br><span class=\"line\">                flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag == <span class=\"keyword\">false</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        fast = head; <span class=\"comment\">// 快指针放回起点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (fast != slow) &#123; </span><br><span class=\"line\">            fast = fast.next; <span class=\"comment\">// 以相同速度前进 </span></span><br><span class=\"line\">            slow = slow.next; <span class=\"comment\">// 以相同速度前进 </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> slow; <span class=\"comment\">// 交点即环的起点</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>两个指针：慢指针和快指针，慢指针一次走一步，快指针一次走两步。如果两个指针相遇，就是有环，如果两个指针不相遇，就是没环。</li>\n<li>将快指针放回链表起点，慢指针位置不变，两者都以慢速遍历指针，再次相遇的点即为环的起点。</li>\n</ol>\n"},{"title":"Leetcode 532. K-diff Pairs in an Array","date":"2020-10-31T01:40:52.000Z","_content":"\n\n## 题目描述\n\n[英文题目](https://leetcode.com/problems/k-diff-pairs-in-an-array/)\n\n[中文题目](https://leetcode-cn.com/problems/k-diff-pairs-in-an-array/)\n\n难度：中等\n\n### 题意\n\n说明：题目来自leetcode中文官网\n\n给定一个整数数组和一个整数 k，你需要在数组里找到不同的 k-diff 数对，并返回不同的 k-diff 数对 的数目。\n\n这里将 k-diff 数对定义为一个整数对 (nums[i], nums[j])，并满足下述全部条件：\n\n0 <= i, j < nums.length\ni != j\n|nums[i] - nums[j]| == k\n注意，|val| 表示 val 的绝对值。\n\n**示例：**\n\n```txt\n输入：nums = [3, 1, 4, 1, 5], k = 2\n输出：2\n解释：数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。\n尽管数组中有两个1，但我们只应返回不同的数对的数量。\n\n------------\n输入：nums = [1, 2, 3, 4, 5], k = 1\n输出：4\n解释：数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。\n\n-------------\n输入：nums = [1, 3, 1, 5, 4], k = 0\n输出：1\n解释：数组中只有一个 0-diff 数对，(1, 1)。\n```\n\n\n\n### 解题思路\n\n该题目分类属于中等题，且用two pointer进行解决，核心思路见代码：\n\n1. 数组排序\n2. 前后两个指针遍历数组，如果当前指针所指的差值等于k，则是我们想要的答案，需要注意的地方是 ：\n   - 题目要求找到唯一的数组对，因此，排序之后相同的数字会排在一起，这里需要跳过重复的数字\n   - k为0的情况，注意别让两个指针重合了\n\n**代码如下：**\n\n```java\nclass Solution {\n    public int findPairs(int[] nums, int k) {\n        if (nums.length == 0 || nums.length == 1) {\n            return 0;\n        }\n        int len = nums.length;\n        Arrays.sort(nums);\n        \n        int ans = 0;\n        \n        int l = 0;\n        int r = 1;\n        while (r < len) {\n            int lv = nums[l];\n            int rv = nums[r];\n            if (rv - lv == k) {\n                ans++;\n                int preL = lv;\n                int preR = rv;\n                while((r + 1 < len) && nums[++r] == preR) {} // 跳过重复数字\n                while((l + 1 < len) && nums[++l] == preL) {} // 跳过重复数字\n            } else if (rv - lv < k) {\n                r++;\n            } else if (rv - lv > k) {\n                l++;\n            }\n            \n            if (l == r) r = l + 1; // 避免k=0时，左右指针重合的情况\n        }\n        \n        return ans;        \n    }\n}\n```\n\n\n\n","source":"_posts/Leetcode/523.md","raw":"---\ntitle: Leetcode 532. K-diff Pairs in an Array\ndate: 2020-10-31 09:40:52\ncategories: leetcode\ntags:\n\t- two pointer\n\t- algorithm \n---\n\n\n## 题目描述\n\n[英文题目](https://leetcode.com/problems/k-diff-pairs-in-an-array/)\n\n[中文题目](https://leetcode-cn.com/problems/k-diff-pairs-in-an-array/)\n\n难度：中等\n\n### 题意\n\n说明：题目来自leetcode中文官网\n\n给定一个整数数组和一个整数 k，你需要在数组里找到不同的 k-diff 数对，并返回不同的 k-diff 数对 的数目。\n\n这里将 k-diff 数对定义为一个整数对 (nums[i], nums[j])，并满足下述全部条件：\n\n0 <= i, j < nums.length\ni != j\n|nums[i] - nums[j]| == k\n注意，|val| 表示 val 的绝对值。\n\n**示例：**\n\n```txt\n输入：nums = [3, 1, 4, 1, 5], k = 2\n输出：2\n解释：数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。\n尽管数组中有两个1，但我们只应返回不同的数对的数量。\n\n------------\n输入：nums = [1, 2, 3, 4, 5], k = 1\n输出：4\n解释：数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。\n\n-------------\n输入：nums = [1, 3, 1, 5, 4], k = 0\n输出：1\n解释：数组中只有一个 0-diff 数对，(1, 1)。\n```\n\n\n\n### 解题思路\n\n该题目分类属于中等题，且用two pointer进行解决，核心思路见代码：\n\n1. 数组排序\n2. 前后两个指针遍历数组，如果当前指针所指的差值等于k，则是我们想要的答案，需要注意的地方是 ：\n   - 题目要求找到唯一的数组对，因此，排序之后相同的数字会排在一起，这里需要跳过重复的数字\n   - k为0的情况，注意别让两个指针重合了\n\n**代码如下：**\n\n```java\nclass Solution {\n    public int findPairs(int[] nums, int k) {\n        if (nums.length == 0 || nums.length == 1) {\n            return 0;\n        }\n        int len = nums.length;\n        Arrays.sort(nums);\n        \n        int ans = 0;\n        \n        int l = 0;\n        int r = 1;\n        while (r < len) {\n            int lv = nums[l];\n            int rv = nums[r];\n            if (rv - lv == k) {\n                ans++;\n                int preL = lv;\n                int preR = rv;\n                while((r + 1 < len) && nums[++r] == preR) {} // 跳过重复数字\n                while((l + 1 < len) && nums[++l] == preL) {} // 跳过重复数字\n            } else if (rv - lv < k) {\n                r++;\n            } else if (rv - lv > k) {\n                l++;\n            }\n            \n            if (l == r) r = l + 1; // 避免k=0时，左右指针重合的情况\n        }\n        \n        return ans;        \n    }\n}\n```\n\n\n\n","slug":"Leetcode/523","published":1,"updated":"2020-10-31T01:46:37.119Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh1zfgyz000k7ktif9vwcn6a","content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><a href=\"https://leetcode.com/problems/k-diff-pairs-in-an-array/\">英文题目</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/k-diff-pairs-in-an-array/\">中文题目</a></p>\n<p>难度：中等</p>\n<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>说明：题目来自leetcode中文官网</p>\n<p>给定一个整数数组和一个整数 k，你需要在数组里找到不同的 k-diff 数对，并返回不同的 k-diff 数对 的数目。</p>\n<p>这里将 k-diff 数对定义为一个整数对 (nums[i], nums[j])，并满足下述全部条件：</p>\n<p>0 &lt;= i, j &lt; nums.length<br>i != j<br>|nums[i] - nums[j]| == k<br>注意，|val| 表示 val 的绝对值。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [3, 1, 4, 1, 5], k = 2</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。</span><br><span class=\"line\">尽管数组中有两个1，但我们只应返回不同的数对的数量。</span><br><span class=\"line\"></span><br><span class=\"line\">------------</span><br><span class=\"line\">输入：nums = [1, 2, 3, 4, 5], k = 1</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。</span><br><span class=\"line\"></span><br><span class=\"line\">-------------</span><br><span class=\"line\">输入：nums = [1, 3, 1, 5, 4], k = 0</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：数组中只有一个 0-diff 数对，(1, 1)。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决，核心思路见代码：</p>\n<ol>\n<li>数组排序</li>\n<li>前后两个指针遍历数组，如果当前指针所指的差值等于k，则是我们想要的答案，需要注意的地方是 ：<ul>\n<li>题目要求找到唯一的数组对，因此，排序之后相同的数字会排在一起，这里需要跳过重复的数字</li>\n<li>k为0的情况，注意别让两个指针重合了</li>\n</ul>\n</li>\n</ol>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findPairs</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums.length == <span class=\"number\">0</span> || nums.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = nums.length;</span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (r &lt; len) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> lv = nums[l];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> rv = nums[r];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rv - lv == k) &#123;</span><br><span class=\"line\">                ans++;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> preL = lv;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> preR = rv;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>((r + <span class=\"number\">1</span> &lt; len) &amp;&amp; nums[++r] == preR) &#123;&#125; <span class=\"comment\">// 跳过重复数字</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span>((l + <span class=\"number\">1</span> &lt; len) &amp;&amp; nums[++l] == preL) &#123;&#125; <span class=\"comment\">// 跳过重复数字</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rv - lv &lt; k) &#123;</span><br><span class=\"line\">                r++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rv - lv &gt; k) &#123;</span><br><span class=\"line\">                l++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l == r) r = l + <span class=\"number\">1</span>; <span class=\"comment\">// 避免k=0时，左右指针重合的情况</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><a href=\"https://leetcode.com/problems/k-diff-pairs-in-an-array/\">英文题目</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/k-diff-pairs-in-an-array/\">中文题目</a></p>\n<p>难度：中等</p>\n<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>说明：题目来自leetcode中文官网</p>\n<p>给定一个整数数组和一个整数 k，你需要在数组里找到不同的 k-diff 数对，并返回不同的 k-diff 数对 的数目。</p>\n<p>这里将 k-diff 数对定义为一个整数对 (nums[i], nums[j])，并满足下述全部条件：</p>\n<p>0 &lt;= i, j &lt; nums.length<br>i != j<br>|nums[i] - nums[j]| == k<br>注意，|val| 表示 val 的绝对值。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [3, 1, 4, 1, 5], k = 2</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。</span><br><span class=\"line\">尽管数组中有两个1，但我们只应返回不同的数对的数量。</span><br><span class=\"line\"></span><br><span class=\"line\">------------</span><br><span class=\"line\">输入：nums = [1, 2, 3, 4, 5], k = 1</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。</span><br><span class=\"line\"></span><br><span class=\"line\">-------------</span><br><span class=\"line\">输入：nums = [1, 3, 1, 5, 4], k = 0</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：数组中只有一个 0-diff 数对，(1, 1)。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决，核心思路见代码：</p>\n<ol>\n<li>数组排序</li>\n<li>前后两个指针遍历数组，如果当前指针所指的差值等于k，则是我们想要的答案，需要注意的地方是 ：<ul>\n<li>题目要求找到唯一的数组对，因此，排序之后相同的数字会排在一起，这里需要跳过重复的数字</li>\n<li>k为0的情况，注意别让两个指针重合了</li>\n</ul>\n</li>\n</ol>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findPairs</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums.length == <span class=\"number\">0</span> || nums.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = nums.length;</span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (r &lt; len) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> lv = nums[l];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> rv = nums[r];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rv - lv == k) &#123;</span><br><span class=\"line\">                ans++;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> preL = lv;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> preR = rv;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>((r + <span class=\"number\">1</span> &lt; len) &amp;&amp; nums[++r] == preR) &#123;&#125; <span class=\"comment\">// 跳过重复数字</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span>((l + <span class=\"number\">1</span> &lt; len) &amp;&amp; nums[++l] == preL) &#123;&#125; <span class=\"comment\">// 跳过重复数字</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rv - lv &lt; k) &#123;</span><br><span class=\"line\">                r++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rv - lv &gt; k) &#123;</span><br><span class=\"line\">                l++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l == r) r = l + <span class=\"number\">1</span>; <span class=\"comment\">// 避免k=0时，左右指针重合的情况</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"1616. Split Two Strings to Make Palindrome","date":"2020-10-30T14:43:24.000Z","_content":"\n\n## 题目描述\n\n[英文题目](https://leetcode.com/problems/split-two-strings-to-make-palindrome/)\n\n[中文题目](https://leetcode-cn.com/problems/split-two-strings-to-make-palindrome/)\n\n难度：中等\n\n### 题意\n\n说明：题目来自leetcode中文官网\n\n给你两个字符串 a 和 b ，它们长度相同。请你选择一个下标，将两个字符串都在 相同的下标 分割开。由 a 可以得到两个字符串： aprefix 和 asuffix ，满足 a = aprefix + asuffix ，同理，由 b 可以得到两个字符串 bprefix 和 bsuffix ，满足 b = bprefix + bsuffix 。请你判断 aprefix + bsuffix 或者 bprefix + asuffix 能否构成回文串。\n\n当你将一个字符串 s 分割成 sprefix 和 ssuffix 时， ssuffix 或者 sprefix 可以为空。比方说， s = \"abc\" 那么 \"\" + \"abc\" ， \"a\" + \"bc\" ， \"ab\" + \"c\" 和 \"abc\" + \"\" 都是合法分割。\n\n如果 能构成回文字符串 ，那么请返回 true，否则返回 false 。\n\n请注意， x + y 表示连接字符串 x 和 y 。\n\n**示例：**\n\n```txt\n输入：a = \"x\", b = \"y\"\n输出：true\n解释：如果 a 或者 b 是回文串，那么答案一定为 true ，因为你可以如下分割：\naprefix = \"\", asuffix = \"x\"\nbprefix = \"\", bsuffix = \"y\"\n那么 aprefix + bsuffix = \"\" + \"y\" = \"y\" 是回文串。\n\n------------\n输入：a = \"ulacfd\", b = \"jizalu\"\n输出：true\n解释：在下标为 3 处分割：\naprefix = \"ula\", asuffix = \"cfd\"\nbprefix = \"jiz\", bsuffix = \"alu\"\n那么 aprefix + bsuffix = \"ula\" + \"alu\" = \"ulaalu\" 是回文串\n```\n\n\n\n### 解题思路\n\n该题目分类属于中等题，且用two pointer进行解决，核心思路见代码：\n\n1. 如果a前缀加上b后缀为回文，则在遍历过程中，一定存在以下情况：\n   - a的左指针，对称在b的右指针所指向的值是相等的，如果不相等，则它们之间的那一段必定是回文才能保证拼接之后是回文；\n2. 反过来，对于b和a也是一样的。\n\n**代码如下：**\n\n```java\nclass Solution {\n    \n    public boolean checkPalindromeFormation(String a, String b) {\n        return helper(a, b) || helper(b, a);\n    }\n    \n    private boolean helper(String a, String b) {\n        int len = a.length();\n        int i = 0, j = len - 1;\n        for (; i < len; i++, j--) {\n            if (a.charAt(i) != b.charAt(j)) {\n                return isP(a, i, j) || isP(b, i, j);\n            }\n        }\n        return true;\n    }\n    \n    private boolean isP(String s, int i, int j) {\n        while (i < j) {\n            if (s.charAt(i) != s.charAt(j)) return false;\n            i++;\n            j--;\n        }\n        return true;\n    }\n}\n```\n\n\n\n","source":"_posts/Leetcode/1616.md","raw":"---\ntitle: 1616. Split Two Strings to Make Palindrome\ndate: 2020-10-30 22:43:24\ncategories: leetcode\ntags:\n\t- two pointer\n\t- algorithm \n\t- greedy\n---\n\n\n## 题目描述\n\n[英文题目](https://leetcode.com/problems/split-two-strings-to-make-palindrome/)\n\n[中文题目](https://leetcode-cn.com/problems/split-two-strings-to-make-palindrome/)\n\n难度：中等\n\n### 题意\n\n说明：题目来自leetcode中文官网\n\n给你两个字符串 a 和 b ，它们长度相同。请你选择一个下标，将两个字符串都在 相同的下标 分割开。由 a 可以得到两个字符串： aprefix 和 asuffix ，满足 a = aprefix + asuffix ，同理，由 b 可以得到两个字符串 bprefix 和 bsuffix ，满足 b = bprefix + bsuffix 。请你判断 aprefix + bsuffix 或者 bprefix + asuffix 能否构成回文串。\n\n当你将一个字符串 s 分割成 sprefix 和 ssuffix 时， ssuffix 或者 sprefix 可以为空。比方说， s = \"abc\" 那么 \"\" + \"abc\" ， \"a\" + \"bc\" ， \"ab\" + \"c\" 和 \"abc\" + \"\" 都是合法分割。\n\n如果 能构成回文字符串 ，那么请返回 true，否则返回 false 。\n\n请注意， x + y 表示连接字符串 x 和 y 。\n\n**示例：**\n\n```txt\n输入：a = \"x\", b = \"y\"\n输出：true\n解释：如果 a 或者 b 是回文串，那么答案一定为 true ，因为你可以如下分割：\naprefix = \"\", asuffix = \"x\"\nbprefix = \"\", bsuffix = \"y\"\n那么 aprefix + bsuffix = \"\" + \"y\" = \"y\" 是回文串。\n\n------------\n输入：a = \"ulacfd\", b = \"jizalu\"\n输出：true\n解释：在下标为 3 处分割：\naprefix = \"ula\", asuffix = \"cfd\"\nbprefix = \"jiz\", bsuffix = \"alu\"\n那么 aprefix + bsuffix = \"ula\" + \"alu\" = \"ulaalu\" 是回文串\n```\n\n\n\n### 解题思路\n\n该题目分类属于中等题，且用two pointer进行解决，核心思路见代码：\n\n1. 如果a前缀加上b后缀为回文，则在遍历过程中，一定存在以下情况：\n   - a的左指针，对称在b的右指针所指向的值是相等的，如果不相等，则它们之间的那一段必定是回文才能保证拼接之后是回文；\n2. 反过来，对于b和a也是一样的。\n\n**代码如下：**\n\n```java\nclass Solution {\n    \n    public boolean checkPalindromeFormation(String a, String b) {\n        return helper(a, b) || helper(b, a);\n    }\n    \n    private boolean helper(String a, String b) {\n        int len = a.length();\n        int i = 0, j = len - 1;\n        for (; i < len; i++, j--) {\n            if (a.charAt(i) != b.charAt(j)) {\n                return isP(a, i, j) || isP(b, i, j);\n            }\n        }\n        return true;\n    }\n    \n    private boolean isP(String s, int i, int j) {\n        while (i < j) {\n            if (s.charAt(i) != s.charAt(j)) return false;\n            i++;\n            j--;\n        }\n        return true;\n    }\n}\n```\n\n\n\n","slug":"Leetcode/1616","published":1,"updated":"2020-10-30T14:49:59.751Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh1zfgz0000o7kti5rqj44b9","content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><a href=\"https://leetcode.com/problems/split-two-strings-to-make-palindrome/\">英文题目</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/split-two-strings-to-make-palindrome/\">中文题目</a></p>\n<p>难度：中等</p>\n<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>说明：题目来自leetcode中文官网</p>\n<p>给你两个字符串 a 和 b ，它们长度相同。请你选择一个下标，将两个字符串都在 相同的下标 分割开。由 a 可以得到两个字符串： aprefix 和 asuffix ，满足 a = aprefix + asuffix ，同理，由 b 可以得到两个字符串 bprefix 和 bsuffix ，满足 b = bprefix + bsuffix 。请你判断 aprefix + bsuffix 或者 bprefix + asuffix 能否构成回文串。</p>\n<p>当你将一个字符串 s 分割成 sprefix 和 ssuffix 时， ssuffix 或者 sprefix 可以为空。比方说， s = “abc” 那么 “” + “abc” ， “a” + “bc” ， “ab” + “c” 和 “abc” + “” 都是合法分割。</p>\n<p>如果 能构成回文字符串 ，那么请返回 true，否则返回 false 。</p>\n<p>请注意， x + y 表示连接字符串 x 和 y 。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：a = &quot;x&quot;, b = &quot;y&quot;</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：如果 a 或者 b 是回文串，那么答案一定为 true ，因为你可以如下分割：</span><br><span class=\"line\">aprefix = &quot;&quot;, asuffix = &quot;x&quot;</span><br><span class=\"line\">bprefix = &quot;&quot;, bsuffix = &quot;y&quot;</span><br><span class=\"line\">那么 aprefix + bsuffix = &quot;&quot; + &quot;y&quot; = &quot;y&quot; 是回文串。</span><br><span class=\"line\"></span><br><span class=\"line\">------------</span><br><span class=\"line\">输入：a = &quot;ulacfd&quot;, b = &quot;jizalu&quot;</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：在下标为 3 处分割：</span><br><span class=\"line\">aprefix = &quot;ula&quot;, asuffix = &quot;cfd&quot;</span><br><span class=\"line\">bprefix = &quot;jiz&quot;, bsuffix = &quot;alu&quot;</span><br><span class=\"line\">那么 aprefix + bsuffix = &quot;ula&quot; + &quot;alu&quot; = &quot;ulaalu&quot; 是回文串</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决，核心思路见代码：</p>\n<ol>\n<li>如果a前缀加上b后缀为回文，则在遍历过程中，一定存在以下情况：<ul>\n<li>a的左指针，对称在b的右指针所指向的值是相等的，如果不相等，则它们之间的那一段必定是回文才能保证拼接之后是回文；</li>\n</ul>\n</li>\n<li>反过来，对于b和a也是一样的。</li>\n</ol>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">checkPalindromeFormation</span><span class=\"params\">(String a, String b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> helper(a, b) || helper(b, a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">helper</span><span class=\"params\">(String a, String b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = a.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = len - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; i &lt; len; i++, j--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a.charAt(i) != b.charAt(j)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> isP(a, i, j) || isP(b, i, j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isP</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; j) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.charAt(i) != s.charAt(j)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><a href=\"https://leetcode.com/problems/split-two-strings-to-make-palindrome/\">英文题目</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/split-two-strings-to-make-palindrome/\">中文题目</a></p>\n<p>难度：中等</p>\n<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>说明：题目来自leetcode中文官网</p>\n<p>给你两个字符串 a 和 b ，它们长度相同。请你选择一个下标，将两个字符串都在 相同的下标 分割开。由 a 可以得到两个字符串： aprefix 和 asuffix ，满足 a = aprefix + asuffix ，同理，由 b 可以得到两个字符串 bprefix 和 bsuffix ，满足 b = bprefix + bsuffix 。请你判断 aprefix + bsuffix 或者 bprefix + asuffix 能否构成回文串。</p>\n<p>当你将一个字符串 s 分割成 sprefix 和 ssuffix 时， ssuffix 或者 sprefix 可以为空。比方说， s = “abc” 那么 “” + “abc” ， “a” + “bc” ， “ab” + “c” 和 “abc” + “” 都是合法分割。</p>\n<p>如果 能构成回文字符串 ，那么请返回 true，否则返回 false 。</p>\n<p>请注意， x + y 表示连接字符串 x 和 y 。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：a = &quot;x&quot;, b = &quot;y&quot;</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：如果 a 或者 b 是回文串，那么答案一定为 true ，因为你可以如下分割：</span><br><span class=\"line\">aprefix = &quot;&quot;, asuffix = &quot;x&quot;</span><br><span class=\"line\">bprefix = &quot;&quot;, bsuffix = &quot;y&quot;</span><br><span class=\"line\">那么 aprefix + bsuffix = &quot;&quot; + &quot;y&quot; = &quot;y&quot; 是回文串。</span><br><span class=\"line\"></span><br><span class=\"line\">------------</span><br><span class=\"line\">输入：a = &quot;ulacfd&quot;, b = &quot;jizalu&quot;</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：在下标为 3 处分割：</span><br><span class=\"line\">aprefix = &quot;ula&quot;, asuffix = &quot;cfd&quot;</span><br><span class=\"line\">bprefix = &quot;jiz&quot;, bsuffix = &quot;alu&quot;</span><br><span class=\"line\">那么 aprefix + bsuffix = &quot;ula&quot; + &quot;alu&quot; = &quot;ulaalu&quot; 是回文串</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决，核心思路见代码：</p>\n<ol>\n<li>如果a前缀加上b后缀为回文，则在遍历过程中，一定存在以下情况：<ul>\n<li>a的左指针，对称在b的右指针所指向的值是相等的，如果不相等，则它们之间的那一段必定是回文才能保证拼接之后是回文；</li>\n</ul>\n</li>\n<li>反过来，对于b和a也是一样的。</li>\n</ol>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">checkPalindromeFormation</span><span class=\"params\">(String a, String b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> helper(a, b) || helper(b, a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">helper</span><span class=\"params\">(String a, String b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = a.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = len - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; i &lt; len; i++, j--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a.charAt(i) != b.charAt(j)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> isP(a, i, j) || isP(b, i, j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isP</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; j) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.charAt(i) != s.charAt(j)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"Leetcode 287. Find the Duplicate Number","date":"2020-11-01T16:17:25.000Z","_content":"\n\n## 题目描述\n\n[英文题目](https://leetcode.com/problems/find-the-duplicate-number/)\n\n[中文题目](https://leetcode-cn.com/problems/find-the-duplicate-number/)\n\n难度：中等\n\n### 题意\n\n给定一个包含`n+1`个数字的数组，该数组中所有数字都在范围`[1,n]`内，该数组中有且仅有一个数字出现了两次，求这个数字。\n\n### 解题思路\n\n该数组可以等价为一个链表，数组中的每个元素等价为一个节点，每个节点的值得`nums[i]`，该节点的`next`值为`nums[nums[i]]`，即该节点的值为下一个节点在数组中的索引。这样，原本的数组就转换为了一个链表，对于链表中的每个节点，有\n\n```java\nNode n;\nn.val = nums[i];\nn.next = nums[n.val] // 或者n.next = nums[num[i]]\n```\n\n以nums[0]为头节点，就能将这个数组转换为链表啦。当然，你也可以以任意一个节点为头节点，而不仅仅是Nums[0]。\n\n转换为链表之后，链表中必存在环，因为有数字出现了两次，出现了两次意味着它是两个节点的next节点，也就是该数字是环的起点。\n\n**例子一：**\n\n假设现在有数组\n\n```\nindex: 0 1 2 3 4 \nvalue: 1 3 4 2 2\n```\n\n则以nums[0]为头节点，组成的链表为：\n\n```\n1->3->2->4\n\t  |__| \n```\n\n我们发现，2在数组中出现了两次，同时它也是环的起点。\n\n**例子二：**\n\n```\nindex: 0 1 2 3 4\nvalue: 3 1 3 4 2\n```\n\n则以nums[0]为头节点，组成的链表为：\n\n```\n3->4->2\n|_____|   \n```\n\n同样，3出现了两次，它也是环的起点。\n\n#### 如何判断环状链表的起点\n\n[证明](https://aerfalwl.github.io/2020/11/01/Leetcode/142/)\n\n\n\n### 代码\n\n```java\nclass Solution {\n    public int findDuplicate(int[] nums) {\n        int slow = 0, fast = 0;\n        slow = nums[slow];\n        fast = nums[nums[fast]];\n        while (slow != fast) {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        }\n        slow = 0;\n        while (slow != fast) {\n            slow = nums[slow];\n            fast = nums[fast];\n        }\n        return fast;\n    }\n}\n```\n\n### 总结\n\n**找环的起点：**\n\n1. 两个指针：慢指针和快指针，慢指针一次走一步，快指针一次走两步。如果两个指针相遇，就是有环，如果两个指针不相遇，就是没环。\n2. 将快指针放回链表起点，慢指针位置不变，两者都以慢速遍历指针，再次相遇的点即为环的起点。\n\n**数组**\n\n1. 数组中的每个元素可以有两层含义\n   - 它可以作为一个值(value)\n   - 该值也可以是数组的一个索引(index)","source":"_posts/Leetcode/287.md","raw":"---\ntitle: Leetcode 287. Find the Duplicate Number\ndate: 2020-11-02 00:17:25\ncategories: leetcode\ntags:\n\t- two pointer\n\t- algorithm \n---\n\n\n## 题目描述\n\n[英文题目](https://leetcode.com/problems/find-the-duplicate-number/)\n\n[中文题目](https://leetcode-cn.com/problems/find-the-duplicate-number/)\n\n难度：中等\n\n### 题意\n\n给定一个包含`n+1`个数字的数组，该数组中所有数字都在范围`[1,n]`内，该数组中有且仅有一个数字出现了两次，求这个数字。\n\n### 解题思路\n\n该数组可以等价为一个链表，数组中的每个元素等价为一个节点，每个节点的值得`nums[i]`，该节点的`next`值为`nums[nums[i]]`，即该节点的值为下一个节点在数组中的索引。这样，原本的数组就转换为了一个链表，对于链表中的每个节点，有\n\n```java\nNode n;\nn.val = nums[i];\nn.next = nums[n.val] // 或者n.next = nums[num[i]]\n```\n\n以nums[0]为头节点，就能将这个数组转换为链表啦。当然，你也可以以任意一个节点为头节点，而不仅仅是Nums[0]。\n\n转换为链表之后，链表中必存在环，因为有数字出现了两次，出现了两次意味着它是两个节点的next节点，也就是该数字是环的起点。\n\n**例子一：**\n\n假设现在有数组\n\n```\nindex: 0 1 2 3 4 \nvalue: 1 3 4 2 2\n```\n\n则以nums[0]为头节点，组成的链表为：\n\n```\n1->3->2->4\n\t  |__| \n```\n\n我们发现，2在数组中出现了两次，同时它也是环的起点。\n\n**例子二：**\n\n```\nindex: 0 1 2 3 4\nvalue: 3 1 3 4 2\n```\n\n则以nums[0]为头节点，组成的链表为：\n\n```\n3->4->2\n|_____|   \n```\n\n同样，3出现了两次，它也是环的起点。\n\n#### 如何判断环状链表的起点\n\n[证明](https://aerfalwl.github.io/2020/11/01/Leetcode/142/)\n\n\n\n### 代码\n\n```java\nclass Solution {\n    public int findDuplicate(int[] nums) {\n        int slow = 0, fast = 0;\n        slow = nums[slow];\n        fast = nums[nums[fast]];\n        while (slow != fast) {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        }\n        slow = 0;\n        while (slow != fast) {\n            slow = nums[slow];\n            fast = nums[fast];\n        }\n        return fast;\n    }\n}\n```\n\n### 总结\n\n**找环的起点：**\n\n1. 两个指针：慢指针和快指针，慢指针一次走一步，快指针一次走两步。如果两个指针相遇，就是有环，如果两个指针不相遇，就是没环。\n2. 将快指针放回链表起点，慢指针位置不变，两者都以慢速遍历指针，再次相遇的点即为环的起点。\n\n**数组**\n\n1. 数组中的每个元素可以有两层含义\n   - 它可以作为一个值(value)\n   - 该值也可以是数组的一个索引(index)","slug":"Leetcode/287","published":1,"updated":"2020-11-01T16:18:53.202Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh1zfgz2000p7kti86y014s1","content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><a href=\"https://leetcode.com/problems/find-the-duplicate-number/\">英文题目</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/find-the-duplicate-number/\">中文题目</a></p>\n<p>难度：中等</p>\n<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>给定一个包含<code>n+1</code>个数字的数组，该数组中所有数字都在范围<code>[1,n]</code>内，该数组中有且仅有一个数字出现了两次，求这个数字。</p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>该数组可以等价为一个链表，数组中的每个元素等价为一个节点，每个节点的值得<code>nums[i]</code>，该节点的<code>next</code>值为<code>nums[nums[i]]</code>，即该节点的值为下一个节点在数组中的索引。这样，原本的数组就转换为了一个链表，对于链表中的每个节点，有</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Node n;</span><br><span class=\"line\">n.val = nums[i];</span><br><span class=\"line\">n.next = nums[n.val] <span class=\"comment\">// 或者n.next = nums[num[i]]</span></span><br></pre></td></tr></table></figure>\n\n<p>以nums[0]为头节点，就能将这个数组转换为链表啦。当然，你也可以以任意一个节点为头节点，而不仅仅是Nums[0]。</p>\n<p>转换为链表之后，链表中必存在环，因为有数字出现了两次，出现了两次意味着它是两个节点的next节点，也就是该数字是环的起点。</p>\n<p><strong>例子一：</strong></p>\n<p>假设现在有数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">index: 0 1 2 3 4 </span><br><span class=\"line\">value: 1 3 4 2 2</span><br></pre></td></tr></table></figure>\n\n<p>则以nums[0]为头节点，组成的链表为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1-&gt;3-&gt;2-&gt;4</span><br><span class=\"line\">\t  |__| </span><br></pre></td></tr></table></figure>\n\n<p>我们发现，2在数组中出现了两次，同时它也是环的起点。</p>\n<p><strong>例子二：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">index: 0 1 2 3 4</span><br><span class=\"line\">value: 3 1 3 4 2</span><br></pre></td></tr></table></figure>\n\n<p>则以nums[0]为头节点，组成的链表为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3-&gt;4-&gt;2</span><br><span class=\"line\">|_____|   </span><br></pre></td></tr></table></figure>\n\n<p>同样，3出现了两次，它也是环的起点。</p>\n<h4 id=\"如何判断环状链表的起点\"><a href=\"#如何判断环状链表的起点\" class=\"headerlink\" title=\"如何判断环状链表的起点\"></a>如何判断环状链表的起点</h4><p><a href=\"https://aerfalwl.github.io/2020/11/01/Leetcode/142/\">证明</a></p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findDuplicate</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> slow = <span class=\"number\">0</span>, fast = <span class=\"number\">0</span>;</span><br><span class=\"line\">        slow = nums[slow];</span><br><span class=\"line\">        fast = nums[nums[fast]];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (slow != fast) &#123;</span><br><span class=\"line\">            slow = nums[slow];</span><br><span class=\"line\">            fast = nums[nums[fast]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        slow = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (slow != fast) &#123;</span><br><span class=\"line\">            slow = nums[slow];</span><br><span class=\"line\">            fast = nums[fast];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fast;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><strong>找环的起点：</strong></p>\n<ol>\n<li>两个指针：慢指针和快指针，慢指针一次走一步，快指针一次走两步。如果两个指针相遇，就是有环，如果两个指针不相遇，就是没环。</li>\n<li>将快指针放回链表起点，慢指针位置不变，两者都以慢速遍历指针，再次相遇的点即为环的起点。</li>\n</ol>\n<p><strong>数组</strong></p>\n<ol>\n<li>数组中的每个元素可以有两层含义<ul>\n<li>它可以作为一个值(value)</li>\n<li>该值也可以是数组的一个索引(index)</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><a href=\"https://leetcode.com/problems/find-the-duplicate-number/\">英文题目</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/find-the-duplicate-number/\">中文题目</a></p>\n<p>难度：中等</p>\n<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>给定一个包含<code>n+1</code>个数字的数组，该数组中所有数字都在范围<code>[1,n]</code>内，该数组中有且仅有一个数字出现了两次，求这个数字。</p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>该数组可以等价为一个链表，数组中的每个元素等价为一个节点，每个节点的值得<code>nums[i]</code>，该节点的<code>next</code>值为<code>nums[nums[i]]</code>，即该节点的值为下一个节点在数组中的索引。这样，原本的数组就转换为了一个链表，对于链表中的每个节点，有</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Node n;</span><br><span class=\"line\">n.val = nums[i];</span><br><span class=\"line\">n.next = nums[n.val] <span class=\"comment\">// 或者n.next = nums[num[i]]</span></span><br></pre></td></tr></table></figure>\n\n<p>以nums[0]为头节点，就能将这个数组转换为链表啦。当然，你也可以以任意一个节点为头节点，而不仅仅是Nums[0]。</p>\n<p>转换为链表之后，链表中必存在环，因为有数字出现了两次，出现了两次意味着它是两个节点的next节点，也就是该数字是环的起点。</p>\n<p><strong>例子一：</strong></p>\n<p>假设现在有数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">index: 0 1 2 3 4 </span><br><span class=\"line\">value: 1 3 4 2 2</span><br></pre></td></tr></table></figure>\n\n<p>则以nums[0]为头节点，组成的链表为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1-&gt;3-&gt;2-&gt;4</span><br><span class=\"line\">\t  |__| </span><br></pre></td></tr></table></figure>\n\n<p>我们发现，2在数组中出现了两次，同时它也是环的起点。</p>\n<p><strong>例子二：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">index: 0 1 2 3 4</span><br><span class=\"line\">value: 3 1 3 4 2</span><br></pre></td></tr></table></figure>\n\n<p>则以nums[0]为头节点，组成的链表为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3-&gt;4-&gt;2</span><br><span class=\"line\">|_____|   </span><br></pre></td></tr></table></figure>\n\n<p>同样，3出现了两次，它也是环的起点。</p>\n<h4 id=\"如何判断环状链表的起点\"><a href=\"#如何判断环状链表的起点\" class=\"headerlink\" title=\"如何判断环状链表的起点\"></a>如何判断环状链表的起点</h4><p><a href=\"https://aerfalwl.github.io/2020/11/01/Leetcode/142/\">证明</a></p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findDuplicate</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> slow = <span class=\"number\">0</span>, fast = <span class=\"number\">0</span>;</span><br><span class=\"line\">        slow = nums[slow];</span><br><span class=\"line\">        fast = nums[nums[fast]];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (slow != fast) &#123;</span><br><span class=\"line\">            slow = nums[slow];</span><br><span class=\"line\">            fast = nums[nums[fast]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        slow = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (slow != fast) &#123;</span><br><span class=\"line\">            slow = nums[slow];</span><br><span class=\"line\">            fast = nums[fast];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fast;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><strong>找环的起点：</strong></p>\n<ol>\n<li>两个指针：慢指针和快指针，慢指针一次走一步，快指针一次走两步。如果两个指针相遇，就是有环，如果两个指针不相遇，就是没环。</li>\n<li>将快指针放回链表起点，慢指针位置不变，两者都以慢速遍历指针，再次相遇的点即为环的起点。</li>\n</ol>\n<p><strong>数组</strong></p>\n<ol>\n<li>数组中的每个元素可以有两层含义<ul>\n<li>它可以作为一个值(value)</li>\n<li>该值也可以是数组的一个索引(index)</li>\n</ul>\n</li>\n</ol>\n"},{"title":"Leetcode 567. Permutation in String","date":"2020-11-03T12:27:49.000Z","_content":"\n\n## 题目描述\n\n[英文题目](https://leetcode.com/problems/permutation-in-string/)\n\n[中文题目](https://leetcode-cn.com/problems/permutation-in-string/)\n\n难度：中等\n\n### 题意\n\n题目给出两个字符串`s1`和`s2`，返回`s1`的全排列之一是否是`s2`的子集。\n\n**示例：**\n\n```txt\nInput: s1 = \"ab\" s2 = \"eidbaooo\"\nOutput: True\nExplanation: s2 contains one permutation of s1 (\"ba\").\n\n------------\nInput:s1= \"ab\" s2 = \"eidboaoo\"\nOutput: False\n```\n\n\n\n### 解题思路\n\n该题目分类属于中等题，且用two pointer进行解决，核心思路：\n\n1. 如果字符串`a`是字符串`b`的subtring，则`b`字符串其中的一段，一定和a的长度相等；\n2. a的全排列，就是将a中字符全部打乱，任意排列；且全排列不会更改字符串中字符出现的次数；\n\n因此，在代码中：\n\n\t1. 计算`s1`中每个字符出现的个数，保存在数组中；\n \t2. 两个指针遍历`s2`，假设两个指针之间形成的字符串为`tmpS`，若`tmpS`中每个字符的个数和`s1`中每个字符出现的个数相等，则返回`true`，遍历结束也没满足条件，返回false；\n\n**代码如下：**\n\n```java\nclass Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        int len1 = s1.length();\n        int len2 = s2.length();\n        int[] dp = new int[26];\n        for (char s : s1.toCharArray()) {\n            dp[s - 'a']++;\n        }\n        int need = len1;\n        int left = 0;\n        int right = 0;\n        while (right < len2) {\n            char c = s2.charAt(right);\n            if (dp[c - 'a'] > 0) {\n                dp[c - 'a']--;\n                need--;\n                right++;\n            } else if (dp[c - 'a'] <= 0) {\n                dp[s2.charAt(left) - 'a']++;\n                left++;\n                need++;\n            }\n            if (need == 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n\n\n","source":"_posts/Leetcode/567.md","raw":"---\ntitle: Leetcode 567. Permutation in String\ndate: 2020-11-03 20:27:49\ncategories: leetcode\ntags:\n\t- two pointer\n\t- algorithm \n---\n\n\n## 题目描述\n\n[英文题目](https://leetcode.com/problems/permutation-in-string/)\n\n[中文题目](https://leetcode-cn.com/problems/permutation-in-string/)\n\n难度：中等\n\n### 题意\n\n题目给出两个字符串`s1`和`s2`，返回`s1`的全排列之一是否是`s2`的子集。\n\n**示例：**\n\n```txt\nInput: s1 = \"ab\" s2 = \"eidbaooo\"\nOutput: True\nExplanation: s2 contains one permutation of s1 (\"ba\").\n\n------------\nInput:s1= \"ab\" s2 = \"eidboaoo\"\nOutput: False\n```\n\n\n\n### 解题思路\n\n该题目分类属于中等题，且用two pointer进行解决，核心思路：\n\n1. 如果字符串`a`是字符串`b`的subtring，则`b`字符串其中的一段，一定和a的长度相等；\n2. a的全排列，就是将a中字符全部打乱，任意排列；且全排列不会更改字符串中字符出现的次数；\n\n因此，在代码中：\n\n\t1. 计算`s1`中每个字符出现的个数，保存在数组中；\n \t2. 两个指针遍历`s2`，假设两个指针之间形成的字符串为`tmpS`，若`tmpS`中每个字符的个数和`s1`中每个字符出现的个数相等，则返回`true`，遍历结束也没满足条件，返回false；\n\n**代码如下：**\n\n```java\nclass Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        int len1 = s1.length();\n        int len2 = s2.length();\n        int[] dp = new int[26];\n        for (char s : s1.toCharArray()) {\n            dp[s - 'a']++;\n        }\n        int need = len1;\n        int left = 0;\n        int right = 0;\n        while (right < len2) {\n            char c = s2.charAt(right);\n            if (dp[c - 'a'] > 0) {\n                dp[c - 'a']--;\n                need--;\n                right++;\n            } else if (dp[c - 'a'] <= 0) {\n                dp[s2.charAt(left) - 'a']++;\n                left++;\n                need++;\n            }\n            if (need == 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n\n\n","slug":"Leetcode/567","published":1,"updated":"2020-11-03T12:38:33.543Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh1zfgz3000s7kti1821gf1k","content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><a href=\"https://leetcode.com/problems/permutation-in-string/\">英文题目</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/permutation-in-string/\">中文题目</a></p>\n<p>难度：中等</p>\n<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>题目给出两个字符串<code>s1</code>和<code>s2</code>，返回<code>s1</code>的全排列之一是否是<code>s2</code>的子集。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</span><br><span class=\"line\">Output: True</span><br><span class=\"line\">Explanation: s2 contains one permutation of s1 (&quot;ba&quot;).</span><br><span class=\"line\"></span><br><span class=\"line\">------------</span><br><span class=\"line\">Input:s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;</span><br><span class=\"line\">Output: False</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决，核心思路：</p>\n<ol>\n<li>如果字符串<code>a</code>是字符串<code>b</code>的subtring，则<code>b</code>字符串其中的一段，一定和a的长度相等；</li>\n<li>a的全排列，就是将a中字符全部打乱，任意排列；且全排列不会更改字符串中字符出现的次数；</li>\n</ol>\n<p>因此，在代码中：</p>\n<pre><code>1. 计算`s1`中每个字符出现的个数，保存在数组中；\n 2. 两个指针遍历`s2`，假设两个指针之间形成的字符串为`tmpS`，若`tmpS`中每个字符的个数和`s1`中每个字符出现的个数相等，则返回`true`，遍历结束也没满足条件，返回false；</code></pre>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">checkInclusion</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len1 = s1.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len2 = s2.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> s : s1.toCharArray()) &#123;</span><br><span class=\"line\">            dp[s - <span class=\"string\">&#x27;a&#x27;</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> need = len1;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (right &lt; len2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = s2.charAt(right);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dp[c - <span class=\"string\">&#x27;a&#x27;</span>] &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                dp[c - <span class=\"string\">&#x27;a&#x27;</span>]--;</span><br><span class=\"line\">                need--;</span><br><span class=\"line\">                right++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dp[c - <span class=\"string\">&#x27;a&#x27;</span>] &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                dp[s2.charAt(left) - <span class=\"string\">&#x27;a&#x27;</span>]++;</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">                need++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (need == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><a href=\"https://leetcode.com/problems/permutation-in-string/\">英文题目</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/permutation-in-string/\">中文题目</a></p>\n<p>难度：中等</p>\n<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>题目给出两个字符串<code>s1</code>和<code>s2</code>，返回<code>s1</code>的全排列之一是否是<code>s2</code>的子集。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</span><br><span class=\"line\">Output: True</span><br><span class=\"line\">Explanation: s2 contains one permutation of s1 (&quot;ba&quot;).</span><br><span class=\"line\"></span><br><span class=\"line\">------------</span><br><span class=\"line\">Input:s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;</span><br><span class=\"line\">Output: False</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决，核心思路：</p>\n<ol>\n<li>如果字符串<code>a</code>是字符串<code>b</code>的subtring，则<code>b</code>字符串其中的一段，一定和a的长度相等；</li>\n<li>a的全排列，就是将a中字符全部打乱，任意排列；且全排列不会更改字符串中字符出现的次数；</li>\n</ol>\n<p>因此，在代码中：</p>\n<pre><code>1. 计算`s1`中每个字符出现的个数，保存在数组中；\n 2. 两个指针遍历`s2`，假设两个指针之间形成的字符串为`tmpS`，若`tmpS`中每个字符的个数和`s1`中每个字符出现的个数相等，则返回`true`，遍历结束也没满足条件，返回false；</code></pre>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">checkInclusion</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len1 = s1.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len2 = s2.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> s : s1.toCharArray()) &#123;</span><br><span class=\"line\">            dp[s - <span class=\"string\">&#x27;a&#x27;</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> need = len1;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (right &lt; len2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = s2.charAt(right);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dp[c - <span class=\"string\">&#x27;a&#x27;</span>] &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                dp[c - <span class=\"string\">&#x27;a&#x27;</span>]--;</span><br><span class=\"line\">                need--;</span><br><span class=\"line\">                right++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dp[c - <span class=\"string\">&#x27;a&#x27;</span>] &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                dp[s2.charAt(left) - <span class=\"string\">&#x27;a&#x27;</span>]++;</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">                need++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (need == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"763. Partition Labels","date":"2020-10-27T13:36:28.000Z","_content":"\n\n## 题目描述\n\n[英文题目](https://leetcode.com/problems/partition-labels/)\n\n[中文题目](https://leetcode-cn.com/problems/partition-labels/)\n\n难度：中等\n\n### 题意\n\n说明：题目来自leetcode中文官网\n\n字符串 `S` 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。\n\n**示例：**\n\n```txt\n输入：S = \"ababcbacadefegdehijhklij\"\n输出：[9,7,8]\n解释：\n划分结果为 \"ababcbaca\", \"defegde\", \"hijhklij\"。\n每个字母最多出现在一个片段中。\n像 \"ababcbacadefegde\", \"hijhklij\" 的划分是错误的，因为划分的片段数较少。\n```\n\n\n\n### 解题思路\n\n该题目分类属于中等题，且用two pointer进行解决。\n\n即首先找到每个字母最后出现的位置，之后划分段的时候，确保该段内每个字母出现的最右值的位置在该段内。不太好描述，直接看代码。\n\n\n\n**代码如下：**\n\n```java\nclass Solution {\n    public List<Integer> partitionLabels(String S) {\n        if(S.length() <= 0) {\n            return null;\n        }\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        char[] s = S.toCharArray();\n        int len = s.length;\n        \n        int[] max = new int[26];\n        \n        \n        for (int i = 0; i < len; i++) {\n            int curr = s[i] - 'a';\n            if (max[curr] < i) max[curr] = i;\n        }\n        \n        int left = 0, right = 0;\n        while (right < len) {\n            int maxRight = 0;\n            while (right < len) {\n                int curr = max[s[right] - 'a'];\n                if (maxRight < curr) maxRight = curr;\n                if (right == maxRight) {\n                    ans.add(right - left + 1);\n                    left = right + 1;\n                    right++;\n                    break;\n                }\n                right++;\n            }\n        }\n        if (left != right) {\n            ans.add(right - left);\n        }\n        return ans;\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n### Two pointer解决套路\n\nTwo pointer和滑动窗口差不多，其套路一般为：\n\n1. 一个左指针，一个右指针。其中左指针用于缩小范围，右指针用于扩大搜索范围。一般求滑动窗口的最小值都是在缩小左指针的时候取得的。\n2. 右指针扩展的条件时：只要当前还没有满足条件，就暴力增长，直到第一次满足条件为止。\n3. 左指针收缩的条件：只要当前指针的缩小还没影响窗口的可满足性，就一直暴力向左增长。一但当前指针向前移动的时候影响了窗口的可满足性，就记录下当前的窗口大小，并更新目前为止满足条件的最小窗口记录。之后，再次扩展右指针，使得窗口满足题目的条件。\n4. 以此类推即可。\n\n","source":"_posts/Leetcode/763.md","raw":"---\ntitle: 763. Partition Labels\ndate: 2020-10-27 21:36:28\ncategories: leetcode\ntags:\n\t- two pointer\n\t- algorithm \n---\n\n\n## 题目描述\n\n[英文题目](https://leetcode.com/problems/partition-labels/)\n\n[中文题目](https://leetcode-cn.com/problems/partition-labels/)\n\n难度：中等\n\n### 题意\n\n说明：题目来自leetcode中文官网\n\n字符串 `S` 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。\n\n**示例：**\n\n```txt\n输入：S = \"ababcbacadefegdehijhklij\"\n输出：[9,7,8]\n解释：\n划分结果为 \"ababcbaca\", \"defegde\", \"hijhklij\"。\n每个字母最多出现在一个片段中。\n像 \"ababcbacadefegde\", \"hijhklij\" 的划分是错误的，因为划分的片段数较少。\n```\n\n\n\n### 解题思路\n\n该题目分类属于中等题，且用two pointer进行解决。\n\n即首先找到每个字母最后出现的位置，之后划分段的时候，确保该段内每个字母出现的最右值的位置在该段内。不太好描述，直接看代码。\n\n\n\n**代码如下：**\n\n```java\nclass Solution {\n    public List<Integer> partitionLabels(String S) {\n        if(S.length() <= 0) {\n            return null;\n        }\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        char[] s = S.toCharArray();\n        int len = s.length;\n        \n        int[] max = new int[26];\n        \n        \n        for (int i = 0; i < len; i++) {\n            int curr = s[i] - 'a';\n            if (max[curr] < i) max[curr] = i;\n        }\n        \n        int left = 0, right = 0;\n        while (right < len) {\n            int maxRight = 0;\n            while (right < len) {\n                int curr = max[s[right] - 'a'];\n                if (maxRight < curr) maxRight = curr;\n                if (right == maxRight) {\n                    ans.add(right - left + 1);\n                    left = right + 1;\n                    right++;\n                    break;\n                }\n                right++;\n            }\n        }\n        if (left != right) {\n            ans.add(right - left);\n        }\n        return ans;\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n### Two pointer解决套路\n\nTwo pointer和滑动窗口差不多，其套路一般为：\n\n1. 一个左指针，一个右指针。其中左指针用于缩小范围，右指针用于扩大搜索范围。一般求滑动窗口的最小值都是在缩小左指针的时候取得的。\n2. 右指针扩展的条件时：只要当前还没有满足条件，就暴力增长，直到第一次满足条件为止。\n3. 左指针收缩的条件：只要当前指针的缩小还没影响窗口的可满足性，就一直暴力向左增长。一但当前指针向前移动的时候影响了窗口的可满足性，就记录下当前的窗口大小，并更新目前为止满足条件的最小窗口记录。之后，再次扩展右指针，使得窗口满足题目的条件。\n4. 以此类推即可。\n\n","slug":"Leetcode/763","published":1,"updated":"2020-10-27T13:51:43.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh1zfgz4000u7kti92awgtad","content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><a href=\"https://leetcode.com/problems/partition-labels/\">英文题目</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/partition-labels/\">中文题目</a></p>\n<p>难度：中等</p>\n<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>说明：题目来自leetcode中文官网</p>\n<p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：S = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class=\"line\">输出：[9,7,8]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。</span><br><span class=\"line\">每个字母最多出现在一个片段中。</span><br><span class=\"line\">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决。</p>\n<p>即首先找到每个字母最后出现的位置，之后划分段的时候，确保该段内每个字母出现的最右值的位置在该段内。不太好描述，直接看代码。</p>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">partitionLabels</span><span class=\"params\">(String S)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(S.length() &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        List&lt;Integer&gt; ans = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] s = S.toCharArray();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = s.length;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] max = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> curr = s[i] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (max[curr] &lt; i) max[curr] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (right &lt; len) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> maxRight = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (right &lt; len) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> curr = max[s[right] - <span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (maxRight &lt; curr) maxRight = curr;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (right == maxRight) &#123;</span><br><span class=\"line\">                    ans.add(right - left + <span class=\"number\">1</span>);</span><br><span class=\"line\">                    left = right + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    right++;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                right++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left != right) &#123;</span><br><span class=\"line\">            ans.add(right - left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n<h3 id=\"Two-pointer解决套路\"><a href=\"#Two-pointer解决套路\" class=\"headerlink\" title=\"Two pointer解决套路\"></a>Two pointer解决套路</h3><p>Two pointer和滑动窗口差不多，其套路一般为：</p>\n<ol>\n<li>一个左指针，一个右指针。其中左指针用于缩小范围，右指针用于扩大搜索范围。一般求滑动窗口的最小值都是在缩小左指针的时候取得的。</li>\n<li>右指针扩展的条件时：只要当前还没有满足条件，就暴力增长，直到第一次满足条件为止。</li>\n<li>左指针收缩的条件：只要当前指针的缩小还没影响窗口的可满足性，就一直暴力向左增长。一但当前指针向前移动的时候影响了窗口的可满足性，就记录下当前的窗口大小，并更新目前为止满足条件的最小窗口记录。之后，再次扩展右指针，使得窗口满足题目的条件。</li>\n<li>以此类推即可。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><a href=\"https://leetcode.com/problems/partition-labels/\">英文题目</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/partition-labels/\">中文题目</a></p>\n<p>难度：中等</p>\n<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>说明：题目来自leetcode中文官网</p>\n<p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：S = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class=\"line\">输出：[9,7,8]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。</span><br><span class=\"line\">每个字母最多出现在一个片段中。</span><br><span class=\"line\">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决。</p>\n<p>即首先找到每个字母最后出现的位置，之后划分段的时候，确保该段内每个字母出现的最右值的位置在该段内。不太好描述，直接看代码。</p>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">partitionLabels</span><span class=\"params\">(String S)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(S.length() &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        List&lt;Integer&gt; ans = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] s = S.toCharArray();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = s.length;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] max = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> curr = s[i] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (max[curr] &lt; i) max[curr] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>, right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (right &lt; len) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> maxRight = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (right &lt; len) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> curr = max[s[right] - <span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (maxRight &lt; curr) maxRight = curr;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (right == maxRight) &#123;</span><br><span class=\"line\">                    ans.add(right - left + <span class=\"number\">1</span>);</span><br><span class=\"line\">                    left = right + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    right++;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                right++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left != right) &#123;</span><br><span class=\"line\">            ans.add(right - left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n<h3 id=\"Two-pointer解决套路\"><a href=\"#Two-pointer解决套路\" class=\"headerlink\" title=\"Two pointer解决套路\"></a>Two pointer解决套路</h3><p>Two pointer和滑动窗口差不多，其套路一般为：</p>\n<ol>\n<li>一个左指针，一个右指针。其中左指针用于缩小范围，右指针用于扩大搜索范围。一般求滑动窗口的最小值都是在缩小左指针的时候取得的。</li>\n<li>右指针扩展的条件时：只要当前还没有满足条件，就暴力增长，直到第一次满足条件为止。</li>\n<li>左指针收缩的条件：只要当前指针的缩小还没影响窗口的可满足性，就一直暴力向左增长。一但当前指针向前移动的时候影响了窗口的可满足性，就记录下当前的窗口大小，并更新目前为止满足条件的最小窗口记录。之后，再次扩展右指针，使得窗口满足题目的条件。</li>\n<li>以此类推即可。</li>\n</ol>\n"},{"_content":"# 滑动窗口\n\nhttps://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/367697\n\n\n\n- 1. [Count Number of Nice Subarrays](https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1))\n- 1. [Replace the Substring for Balanced String](https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/367697)\n- 1. [Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/247564/javacpython-sliding-window/379427?page=3)\n- 1. [Binary Subarrays With Sum](https://leetcode.com/problems/binary-subarrays-with-sum/discuss/186683/)\n- 1. [Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/234482/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1))\n- 1. [Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/discuss/170740/Sliding-Window-for-K-Elements)\n- 1. [Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/C%2B%2BJavaPython-O(N)-Using-Deque)\n- 1. [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/433123)\n\nhttps://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/204290/Monotonic-Queue-Summary","source":"_posts/Leetcode/滑动窗口.md","raw":"# 滑动窗口\n\nhttps://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/367697\n\n\n\n- 1. [Count Number of Nice Subarrays](https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1))\n- 1. [Replace the Substring for Balanced String](https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/367697)\n- 1. [Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/247564/javacpython-sliding-window/379427?page=3)\n- 1. [Binary Subarrays With Sum](https://leetcode.com/problems/binary-subarrays-with-sum/discuss/186683/)\n- 1. [Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/234482/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1))\n- 1. [Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/discuss/170740/Sliding-Window-for-K-Elements)\n- 1. [Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/C%2B%2BJavaPython-O(N)-Using-Deque)\n- 1. [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/433123)\n\nhttps://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/204290/Monotonic-Queue-Summary","slug":"Leetcode/滑动窗口","published":1,"date":"2020-10-27T02:11:32.056Z","updated":"2020-10-10T01:08:41.756Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh1zfgz5000z7ktiglk05jhj","content":"<h1 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h1><p><a href=\"https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/367697\">https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/367697</a></p>\n<ul>\n<li><ol>\n<li><a href=\"https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1)\">Count Number of Nice Subarrays</a></li>\n</ol>\n</li>\n<li><ol>\n<li><a href=\"https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/367697\">Replace the Substring for Balanced String</a></li>\n</ol>\n</li>\n<li><ol>\n<li><a href=\"https://leetcode.com/problems/max-consecutive-ones-iii/discuss/247564/javacpython-sliding-window/379427?page=3\">Max Consecutive Ones III</a></li>\n</ol>\n</li>\n<li><ol>\n<li><a href=\"https://leetcode.com/problems/binary-subarrays-with-sum/discuss/186683/\">Binary Subarrays With Sum</a></li>\n</ol>\n</li>\n<li><ol>\n<li><a href=\"https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/234482/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1)\">Subarrays with K Different Integers</a></li>\n</ol>\n</li>\n<li><ol>\n<li><a href=\"https://leetcode.com/problems/fruit-into-baskets/discuss/170740/Sliding-Window-for-K-Elements\">Fruit Into Baskets</a></li>\n</ol>\n</li>\n<li><ol>\n<li><a href=\"https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/C%2B%2BJavaPython-O(N)-Using-Deque\">Shortest Subarray with Sum at Least K</a></li>\n</ol>\n</li>\n<li><ol>\n<li><a href=\"https://leetcode.com/problems/minimum-size-subarray-sum/discuss/433123\">Minimum Size Subarray Sum</a></li>\n</ol>\n</li>\n</ul>\n<p><a href=\"https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/204290/Monotonic-Queue-Summary\">https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/204290/Monotonic-Queue-Summary</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h1><p><a href=\"https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/367697\">https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/367697</a></p>\n<ul>\n<li><ol>\n<li><a href=\"https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1)\">Count Number of Nice Subarrays</a></li>\n</ol>\n</li>\n<li><ol>\n<li><a href=\"https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/367697\">Replace the Substring for Balanced String</a></li>\n</ol>\n</li>\n<li><ol>\n<li><a href=\"https://leetcode.com/problems/max-consecutive-ones-iii/discuss/247564/javacpython-sliding-window/379427?page=3\">Max Consecutive Ones III</a></li>\n</ol>\n</li>\n<li><ol>\n<li><a href=\"https://leetcode.com/problems/binary-subarrays-with-sum/discuss/186683/\">Binary Subarrays With Sum</a></li>\n</ol>\n</li>\n<li><ol>\n<li><a href=\"https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/234482/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1)\">Subarrays with K Different Integers</a></li>\n</ol>\n</li>\n<li><ol>\n<li><a href=\"https://leetcode.com/problems/fruit-into-baskets/discuss/170740/Sliding-Window-for-K-Elements\">Fruit Into Baskets</a></li>\n</ol>\n</li>\n<li><ol>\n<li><a href=\"https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/C%2B%2BJavaPython-O(N)-Using-Deque\">Shortest Subarray with Sum at Least K</a></li>\n</ol>\n</li>\n<li><ol>\n<li><a href=\"https://leetcode.com/problems/minimum-size-subarray-sum/discuss/433123\">Minimum Size Subarray Sum</a></li>\n</ol>\n</li>\n</ul>\n<p><a href=\"https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/204290/Monotonic-Queue-Summary\">https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/204290/Monotonic-Queue-Summary</a></p>\n"},{"title":"LeetCode 826. Most Profit Assigning Work","date":"2020-10-28T13:11:12.000Z","_content":"\n\n## 题目描述\n\n[英文题目](https://leetcode.com/problems/most-profit-assigning-work/)\n\n[中文题目](https://leetcode-cn.com/problems/most-profit-assigning-work/)\n\n难度：中等\n\n### 题意\n\n说明：题目来自leetcode中文官网\n\n有一些工作：`difficulty[i]` 表示第 `i` 个工作的难度，`profit[i]` 表示第 `i` 个工作的收益。\n\n现在我们有一些工人。`worker[i]` 是第 `i` 个工人的能力，即该工人只能完成难度小于等于 `worker[i]` 的工作。\n\n每一个工人都最多只能安排一个工作，但是一个工作可以完成多次。\n\n举个例子，如果 3 个工人都尝试完成一份报酬为 1 的同样工作，那么总收益为 $3。如果一个工人不能完成任何工作，他的收益为 $0 。\n\n我们能得到的最大收益是多少？\n\n**示例：**\n\n```txt\nInput: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]\nOutput: 100 \nExplanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately.。\n```\n\n\n\n### 解题思路\n\n该题目分类属于中等题，且用two pointer进行解决。\n\n#### 思路一\n\n**核心**：找出每个工人能承受范围内工作的最大利润，求和即可。\n\n1. 将所有job按照困难度从小到大排序，困难度相同时，按照利润从大到小排序。\n2. 得到所有Job困难度下，能获得的最大利润。\n3. 遍历worker，找到其能承受困难度下的最大利润，相加即可。\n\n**代码如下：**\n\n```java\nclass Solution {\n    public int maxProfitAssignment(int[] d, int[] p, int[] w) {\n        int len = d.length;\n        if (len == 0) {\n            return 0;\n        }\n        \n        int[][] a = new int[len][2];\n        \n        for (int i = 0; i < len; i++) {\n            a[i][0] = d[i];\n            a[i][1] = p[i];\n        }\n        \n        // 按照困难度从小到大排序\n        Arrays.sort(a, (m, n) -> m[0] == n[0] ? n[1] - m[1] : m[0] - n[0]);\n        \n        \n        // 该困难度下的最高利润\n        int[] maxP = new int[len];\n        \n        maxP[0] = a[0][1];\n        int max = a[0][1];\n        for (int i = 1; i < len; i++) {\n            max = Math.max(a[i][1], max);\n            maxP[i] = max;\n        }\n        \n        int sum = 0;\n        int job = 0;\n        \n        // worker按照其能承受困难强度从小到大排序\n        Arrays.sort(w);\n        \n        // 找到所有worker能承受困难下的最大利润\n        max = 0;\n        for (int i = 0; i < w.length; i++) {\n            while (job < len) {\n                if (w[i] >= a[job][0]) {\n                    max = maxP[job];\n                    job++;\n                } else {\n                    break;\n                }\n            }\n            sum += max;\n        }\n        return sum;\n    }\n}\n```\n\n#### 思路二\n\n利用DP的思想，dp[i]表示在worker能承受难度最大值为i时，其能获得的最大的利润。\n\n```java\nclass Solution {\n    public int maxProfitAssignment(int[] d, int[] p, int[] w) {\n        int len = d.length;\n        if (len == 0) {\n            return 0;\n        }\n        \n        int maxD = 0; // 最大难度值\n        for (int num : d) {\n            maxD = Math.max(maxD, num);\n        }\n        \n        // dp[i] 表示在难度为i时，能获得的最大利润\n        int[] dp = new int[maxD + 1];\n        \n        // 首先将题目给的数填充进来\n        for (int i = 0; i < len; i++) {\n            dp[d[i]] = Math.max(dp[d[i]], p[i]); \n        }\n        \n        int maxP = 0;\n        // 可能出现难度高，但是利润小的工作，因此需要遍历再次找出特定难度下能获得的最大利润\n        for (int i = 0; i <= maxD; i++) {\n            maxP = Math.max(maxP, dp[i]);\n            dp[i] = maxP;\n        }\n        \n        int sum = 0;\n        for (int n : w) {\n            if (n > maxD) {\n                sum += maxP;\n            } else {\n                sum += dp[n]; //将所有的利润求和\n            }\n        }\n    \n        return sum;\n    }\n}\n```\n\n\n\n","source":"_posts/Leetcode/826.md","raw":"---\ntitle: LeetCode 826. Most Profit Assigning Work\ndate: 2020-10-28 21:11:12\ncategories: leetcode\ntags:\n\t- two pointer\n\t- algorithm \n\t- dp\n---\n\n\n## 题目描述\n\n[英文题目](https://leetcode.com/problems/most-profit-assigning-work/)\n\n[中文题目](https://leetcode-cn.com/problems/most-profit-assigning-work/)\n\n难度：中等\n\n### 题意\n\n说明：题目来自leetcode中文官网\n\n有一些工作：`difficulty[i]` 表示第 `i` 个工作的难度，`profit[i]` 表示第 `i` 个工作的收益。\n\n现在我们有一些工人。`worker[i]` 是第 `i` 个工人的能力，即该工人只能完成难度小于等于 `worker[i]` 的工作。\n\n每一个工人都最多只能安排一个工作，但是一个工作可以完成多次。\n\n举个例子，如果 3 个工人都尝试完成一份报酬为 1 的同样工作，那么总收益为 $3。如果一个工人不能完成任何工作，他的收益为 $0 。\n\n我们能得到的最大收益是多少？\n\n**示例：**\n\n```txt\nInput: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]\nOutput: 100 \nExplanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately.。\n```\n\n\n\n### 解题思路\n\n该题目分类属于中等题，且用two pointer进行解决。\n\n#### 思路一\n\n**核心**：找出每个工人能承受范围内工作的最大利润，求和即可。\n\n1. 将所有job按照困难度从小到大排序，困难度相同时，按照利润从大到小排序。\n2. 得到所有Job困难度下，能获得的最大利润。\n3. 遍历worker，找到其能承受困难度下的最大利润，相加即可。\n\n**代码如下：**\n\n```java\nclass Solution {\n    public int maxProfitAssignment(int[] d, int[] p, int[] w) {\n        int len = d.length;\n        if (len == 0) {\n            return 0;\n        }\n        \n        int[][] a = new int[len][2];\n        \n        for (int i = 0; i < len; i++) {\n            a[i][0] = d[i];\n            a[i][1] = p[i];\n        }\n        \n        // 按照困难度从小到大排序\n        Arrays.sort(a, (m, n) -> m[0] == n[0] ? n[1] - m[1] : m[0] - n[0]);\n        \n        \n        // 该困难度下的最高利润\n        int[] maxP = new int[len];\n        \n        maxP[0] = a[0][1];\n        int max = a[0][1];\n        for (int i = 1; i < len; i++) {\n            max = Math.max(a[i][1], max);\n            maxP[i] = max;\n        }\n        \n        int sum = 0;\n        int job = 0;\n        \n        // worker按照其能承受困难强度从小到大排序\n        Arrays.sort(w);\n        \n        // 找到所有worker能承受困难下的最大利润\n        max = 0;\n        for (int i = 0; i < w.length; i++) {\n            while (job < len) {\n                if (w[i] >= a[job][0]) {\n                    max = maxP[job];\n                    job++;\n                } else {\n                    break;\n                }\n            }\n            sum += max;\n        }\n        return sum;\n    }\n}\n```\n\n#### 思路二\n\n利用DP的思想，dp[i]表示在worker能承受难度最大值为i时，其能获得的最大的利润。\n\n```java\nclass Solution {\n    public int maxProfitAssignment(int[] d, int[] p, int[] w) {\n        int len = d.length;\n        if (len == 0) {\n            return 0;\n        }\n        \n        int maxD = 0; // 最大难度值\n        for (int num : d) {\n            maxD = Math.max(maxD, num);\n        }\n        \n        // dp[i] 表示在难度为i时，能获得的最大利润\n        int[] dp = new int[maxD + 1];\n        \n        // 首先将题目给的数填充进来\n        for (int i = 0; i < len; i++) {\n            dp[d[i]] = Math.max(dp[d[i]], p[i]); \n        }\n        \n        int maxP = 0;\n        // 可能出现难度高，但是利润小的工作，因此需要遍历再次找出特定难度下能获得的最大利润\n        for (int i = 0; i <= maxD; i++) {\n            maxP = Math.max(maxP, dp[i]);\n            dp[i] = maxP;\n        }\n        \n        int sum = 0;\n        for (int n : w) {\n            if (n > maxD) {\n                sum += maxP;\n            } else {\n                sum += dp[n]; //将所有的利润求和\n            }\n        }\n    \n        return sum;\n    }\n}\n```\n\n\n\n","slug":"Leetcode/826","published":1,"updated":"2020-10-28T14:03:42.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh1zfgz600127kti5z5t1mpc","content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><a href=\"https://leetcode.com/problems/most-profit-assigning-work/\">英文题目</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/most-profit-assigning-work/\">中文题目</a></p>\n<p>难度：中等</p>\n<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>说明：题目来自leetcode中文官网</p>\n<p>有一些工作：<code>difficulty[i]</code> 表示第 <code>i</code> 个工作的难度，<code>profit[i]</code> 表示第 <code>i</code> 个工作的收益。</p>\n<p>现在我们有一些工人。<code>worker[i]</code> 是第 <code>i</code> 个工人的能力，即该工人只能完成难度小于等于 <code>worker[i]</code> 的工作。</p>\n<p>每一个工人都最多只能安排一个工作，但是一个工作可以完成多次。</p>\n<p>举个例子，如果 3 个工人都尝试完成一份报酬为 1 的同样工作，那么总收益为 $3。如果一个工人不能完成任何工作，他的收益为 $0 。</p>\n<p>我们能得到的最大收益是多少？</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]</span><br><span class=\"line\">Output: 100 </span><br><span class=\"line\">Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately.。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决。</p>\n<h4 id=\"思路一\"><a href=\"#思路一\" class=\"headerlink\" title=\"思路一\"></a>思路一</h4><p><strong>核心</strong>：找出每个工人能承受范围内工作的最大利润，求和即可。</p>\n<ol>\n<li>将所有job按照困难度从小到大排序，困难度相同时，按照利润从大到小排序。</li>\n<li>得到所有Job困难度下，能获得的最大利润。</li>\n<li>遍历worker，找到其能承受困难度下的最大利润，相加即可。</li>\n</ol>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxProfitAssignment</span><span class=\"params\">(<span class=\"keyword\">int</span>[] d, <span class=\"keyword\">int</span>[] p, <span class=\"keyword\">int</span>[] w)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = d.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[len][<span class=\"number\">2</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            a[i][<span class=\"number\">0</span>] = d[i];</span><br><span class=\"line\">            a[i][<span class=\"number\">1</span>] = p[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 按照困难度从小到大排序</span></span><br><span class=\"line\">        Arrays.sort(a, (m, n) -&gt; m[<span class=\"number\">0</span>] == n[<span class=\"number\">0</span>] ? n[<span class=\"number\">1</span>] - m[<span class=\"number\">1</span>] : m[<span class=\"number\">0</span>] - n[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 该困难度下的最高利润</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] maxP = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[len];</span><br><span class=\"line\">        </span><br><span class=\"line\">        maxP[<span class=\"number\">0</span>] = a[<span class=\"number\">0</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = a[<span class=\"number\">0</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            max = Math.max(a[i][<span class=\"number\">1</span>], max);</span><br><span class=\"line\">            maxP[i] = max;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> job = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// worker按照其能承受困难强度从小到大排序</span></span><br><span class=\"line\">        Arrays.sort(w);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 找到所有worker能承受困难下的最大利润</span></span><br><span class=\"line\">        max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; w.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (job &lt; len) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (w[i] &gt;= a[job][<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">                    max = maxP[job];</span><br><span class=\"line\">                    job++;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sum += max;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"思路二\"><a href=\"#思路二\" class=\"headerlink\" title=\"思路二\"></a>思路二</h4><p>利用DP的思想，dp[i]表示在worker能承受难度最大值为i时，其能获得的最大的利润。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxProfitAssignment</span><span class=\"params\">(<span class=\"keyword\">int</span>[] d, <span class=\"keyword\">int</span>[] p, <span class=\"keyword\">int</span>[] w)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = d.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxD = <span class=\"number\">0</span>; <span class=\"comment\">// 最大难度值</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : d) &#123;</span><br><span class=\"line\">            maxD = Math.max(maxD, num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// dp[i] 表示在难度为i时，能获得的最大利润</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[maxD + <span class=\"number\">1</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 首先将题目给的数填充进来</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            dp[d[i]] = Math.max(dp[d[i]], p[i]); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxP = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 可能出现难度高，但是利润小的工作，因此需要遍历再次找出特定难度下能获得的最大利润</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= maxD; i++) &#123;</span><br><span class=\"line\">            maxP = Math.max(maxP, dp[i]);</span><br><span class=\"line\">            dp[i] = maxP;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> n : w) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n &gt; maxD) &#123;</span><br><span class=\"line\">                sum += maxP;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                sum += dp[n]; <span class=\"comment\">//将所有的利润求和</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><a href=\"https://leetcode.com/problems/most-profit-assigning-work/\">英文题目</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/most-profit-assigning-work/\">中文题目</a></p>\n<p>难度：中等</p>\n<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>说明：题目来自leetcode中文官网</p>\n<p>有一些工作：<code>difficulty[i]</code> 表示第 <code>i</code> 个工作的难度，<code>profit[i]</code> 表示第 <code>i</code> 个工作的收益。</p>\n<p>现在我们有一些工人。<code>worker[i]</code> 是第 <code>i</code> 个工人的能力，即该工人只能完成难度小于等于 <code>worker[i]</code> 的工作。</p>\n<p>每一个工人都最多只能安排一个工作，但是一个工作可以完成多次。</p>\n<p>举个例子，如果 3 个工人都尝试完成一份报酬为 1 的同样工作，那么总收益为 $3。如果一个工人不能完成任何工作，他的收益为 $0 。</p>\n<p>我们能得到的最大收益是多少？</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]</span><br><span class=\"line\">Output: 100 </span><br><span class=\"line\">Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately.。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决。</p>\n<h4 id=\"思路一\"><a href=\"#思路一\" class=\"headerlink\" title=\"思路一\"></a>思路一</h4><p><strong>核心</strong>：找出每个工人能承受范围内工作的最大利润，求和即可。</p>\n<ol>\n<li>将所有job按照困难度从小到大排序，困难度相同时，按照利润从大到小排序。</li>\n<li>得到所有Job困难度下，能获得的最大利润。</li>\n<li>遍历worker，找到其能承受困难度下的最大利润，相加即可。</li>\n</ol>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxProfitAssignment</span><span class=\"params\">(<span class=\"keyword\">int</span>[] d, <span class=\"keyword\">int</span>[] p, <span class=\"keyword\">int</span>[] w)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = d.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[len][<span class=\"number\">2</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            a[i][<span class=\"number\">0</span>] = d[i];</span><br><span class=\"line\">            a[i][<span class=\"number\">1</span>] = p[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 按照困难度从小到大排序</span></span><br><span class=\"line\">        Arrays.sort(a, (m, n) -&gt; m[<span class=\"number\">0</span>] == n[<span class=\"number\">0</span>] ? n[<span class=\"number\">1</span>] - m[<span class=\"number\">1</span>] : m[<span class=\"number\">0</span>] - n[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 该困难度下的最高利润</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] maxP = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[len];</span><br><span class=\"line\">        </span><br><span class=\"line\">        maxP[<span class=\"number\">0</span>] = a[<span class=\"number\">0</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = a[<span class=\"number\">0</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            max = Math.max(a[i][<span class=\"number\">1</span>], max);</span><br><span class=\"line\">            maxP[i] = max;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> job = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// worker按照其能承受困难强度从小到大排序</span></span><br><span class=\"line\">        Arrays.sort(w);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 找到所有worker能承受困难下的最大利润</span></span><br><span class=\"line\">        max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; w.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (job &lt; len) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (w[i] &gt;= a[job][<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">                    max = maxP[job];</span><br><span class=\"line\">                    job++;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sum += max;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"思路二\"><a href=\"#思路二\" class=\"headerlink\" title=\"思路二\"></a>思路二</h4><p>利用DP的思想，dp[i]表示在worker能承受难度最大值为i时，其能获得的最大的利润。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxProfitAssignment</span><span class=\"params\">(<span class=\"keyword\">int</span>[] d, <span class=\"keyword\">int</span>[] p, <span class=\"keyword\">int</span>[] w)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = d.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxD = <span class=\"number\">0</span>; <span class=\"comment\">// 最大难度值</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : d) &#123;</span><br><span class=\"line\">            maxD = Math.max(maxD, num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// dp[i] 表示在难度为i时，能获得的最大利润</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[maxD + <span class=\"number\">1</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 首先将题目给的数填充进来</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            dp[d[i]] = Math.max(dp[d[i]], p[i]); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxP = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 可能出现难度高，但是利润小的工作，因此需要遍历再次找出特定难度下能获得的最大利润</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= maxD; i++) &#123;</span><br><span class=\"line\">            maxP = Math.max(maxP, dp[i]);</span><br><span class=\"line\">            dp[i] = maxP;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> n : w) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n &gt; maxD) &#123;</span><br><span class=\"line\">                sum += maxP;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                sum += dp[n]; <span class=\"comment\">//将所有的利润求和</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"_content":"# 查看远程服务器的端口是否开放\n\n## 1. nc（netcat）\n\nnc是一个简单的Unix工具，使用TCP或者UDP协议读写网络连接上的数据。\n\n```bash\nnc [OPTIONS...] [hostname] [port]\n```\n\n如果未开放，则会显示请求被拒绝。例如：\n\n```bash\nnc node1 9100\n# Ncat: Connection refused.\n```\n\n如果指定端口开放，则会显示连接成功。例如：\n\n```bash\nnc node1 9100\n# Ncat: Connection succeeded\n```\n\n## 2. telnet\n\n命令格式\n\n```bash\ntelnet [HostName or IP] [PortNumber]\n```\n\n","source":"_posts/LinuxCmd/20200814-查看远程服务器的端口是否开放.md","raw":"# 查看远程服务器的端口是否开放\n\n## 1. nc（netcat）\n\nnc是一个简单的Unix工具，使用TCP或者UDP协议读写网络连接上的数据。\n\n```bash\nnc [OPTIONS...] [hostname] [port]\n```\n\n如果未开放，则会显示请求被拒绝。例如：\n\n```bash\nnc node1 9100\n# Ncat: Connection refused.\n```\n\n如果指定端口开放，则会显示连接成功。例如：\n\n```bash\nnc node1 9100\n# Ncat: Connection succeeded\n```\n\n## 2. telnet\n\n命令格式\n\n```bash\ntelnet [HostName or IP] [PortNumber]\n```\n\n","slug":"LinuxCmd/20200814-查看远程服务器的端口是否开放","published":1,"date":"2020-10-27T02:11:32.066Z","updated":"2020-10-10T01:08:41.752Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh1zfgz700167kti82t59chi","content":"<h1 id=\"查看远程服务器的端口是否开放\"><a href=\"#查看远程服务器的端口是否开放\" class=\"headerlink\" title=\"查看远程服务器的端口是否开放\"></a>查看远程服务器的端口是否开放</h1><h2 id=\"1-nc（netcat）\"><a href=\"#1-nc（netcat）\" class=\"headerlink\" title=\"1. nc（netcat）\"></a>1. nc（netcat）</h2><p>nc是一个简单的Unix工具，使用TCP或者UDP协议读写网络连接上的数据。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nc [OPTIONS...] [hostname] [port]</span><br></pre></td></tr></table></figure>\n\n<p>如果未开放，则会显示请求被拒绝。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nc node1 9100</span><br><span class=\"line\"><span class=\"comment\"># Ncat: Connection refused.</span></span><br></pre></td></tr></table></figure>\n\n<p>如果指定端口开放，则会显示连接成功。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nc node1 9100</span><br><span class=\"line\"><span class=\"comment\"># Ncat: Connection succeeded</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-telnet\"><a href=\"#2-telnet\" class=\"headerlink\" title=\"2. telnet\"></a>2. telnet</h2><p>命令格式</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">telnet [HostName or IP] [PortNumber]</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"查看远程服务器的端口是否开放\"><a href=\"#查看远程服务器的端口是否开放\" class=\"headerlink\" title=\"查看远程服务器的端口是否开放\"></a>查看远程服务器的端口是否开放</h1><h2 id=\"1-nc（netcat）\"><a href=\"#1-nc（netcat）\" class=\"headerlink\" title=\"1. nc（netcat）\"></a>1. nc（netcat）</h2><p>nc是一个简单的Unix工具，使用TCP或者UDP协议读写网络连接上的数据。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nc [OPTIONS...] [hostname] [port]</span><br></pre></td></tr></table></figure>\n\n<p>如果未开放，则会显示请求被拒绝。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nc node1 9100</span><br><span class=\"line\"><span class=\"comment\"># Ncat: Connection refused.</span></span><br></pre></td></tr></table></figure>\n\n<p>如果指定端口开放，则会显示连接成功。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nc node1 9100</span><br><span class=\"line\"><span class=\"comment\"># Ncat: Connection succeeded</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-telnet\"><a href=\"#2-telnet\" class=\"headerlink\" title=\"2. telnet\"></a>2. telnet</h2><p>命令格式</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">telnet [HostName or IP] [PortNumber]</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"# netstat\n\n查看所有在监听的端口\n\n```bash\nnetstat -ntlp\n```\n\n待整理\n\n[好文推荐]: https://www.journaldev.com/34113/opening-a-port-on-linux\n\n\n\n\n\n\n\n","source":"_posts/LinuxCmd/20200814netstat.md","raw":"# netstat\n\n查看所有在监听的端口\n\n```bash\nnetstat -ntlp\n```\n\n待整理\n\n[好文推荐]: https://www.journaldev.com/34113/opening-a-port-on-linux\n\n\n\n\n\n\n\n","slug":"LinuxCmd/20200814netstat","published":1,"date":"2020-10-27T02:11:32.076Z","updated":"2020-10-10T01:08:41.753Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh1zfgz800187ktic7hw50ql","content":"<h1 id=\"netstat\"><a href=\"#netstat\" class=\"headerlink\" title=\"netstat\"></a>netstat</h1><p>查看所有在监听的端口</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -ntlp</span><br></pre></td></tr></table></figure>\n\n<p>待整理</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"netstat\"><a href=\"#netstat\" class=\"headerlink\" title=\"netstat\"></a>netstat</h1><p>查看所有在监听的端口</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -ntlp</span><br></pre></td></tr></table></figure>\n\n<p>待整理</p>\n"},{"_content":"# 2 使用GDB查看core文件\n\n默认编译出来的程序在出现Segmentation fault 时并没有生成core崩溃文件，可以在gcc/g++编译时增加-g选项。\n\n如果仍然没有生成core文件，则可能是因为系统设置了core文件大小为0，可以通过：`ulimit -a` 查询得知。\n\n执行 `ulimit -c unlimited` 命令后可以使core文件大小不受限制。此时再次运行程序应该就能在同级目录看到`core.XXX`文件了\n\n使用 `gdb ./a.out core.XXX` 可以查看出错所在行信息，这样就进入了 gdb core 调试模式。\n\n追踪产生segmenttation fault的位置及代码函数调用情况：\n\n`gdb>bt`\n\n这样，一般就可以看到出错的代码是哪一句了，还可以打印出相应变量的数值，进行进一步分析。\n\n[返回目录](https://www.cnblogs.com/kuliuheng/p/11698378.html#_labelTop)\n\n# **3 使用GDB调试程序**\n\n如上述流程不能解决问题，下面可使用gdb单步调试程序。重新编译程序，编译命令中加入-g。如：\n\ngcc -lm -O3 -g file.c -o file\n之后使用gdb命令\n\n`gdb file`\n开始调试。\n\n输入`start`使程序运行到`main`中第一行运行代码。`next`或者n为执行下一行程序，`until xx`执行到xx行，print或p可输出变量值，`b xx`用于在xx行设置断点，`run`或`r`用于执行程序至下一断点，`d xx`删除xx行断点。\n\n我们可以先run一遍程序，这时它会提示出错行信息。然后`until`到出错行前5行，交替执行`next`和`print`，输出与出错行变量相关变量或指针的值。最终定位出错的根本操作在哪一行。修改之即可。","source":"_posts/LinuxCmd/使用GDB查看core文件.md","raw":"# 2 使用GDB查看core文件\n\n默认编译出来的程序在出现Segmentation fault 时并没有生成core崩溃文件，可以在gcc/g++编译时增加-g选项。\n\n如果仍然没有生成core文件，则可能是因为系统设置了core文件大小为0，可以通过：`ulimit -a` 查询得知。\n\n执行 `ulimit -c unlimited` 命令后可以使core文件大小不受限制。此时再次运行程序应该就能在同级目录看到`core.XXX`文件了\n\n使用 `gdb ./a.out core.XXX` 可以查看出错所在行信息，这样就进入了 gdb core 调试模式。\n\n追踪产生segmenttation fault的位置及代码函数调用情况：\n\n`gdb>bt`\n\n这样，一般就可以看到出错的代码是哪一句了，还可以打印出相应变量的数值，进行进一步分析。\n\n[返回目录](https://www.cnblogs.com/kuliuheng/p/11698378.html#_labelTop)\n\n# **3 使用GDB调试程序**\n\n如上述流程不能解决问题，下面可使用gdb单步调试程序。重新编译程序，编译命令中加入-g。如：\n\ngcc -lm -O3 -g file.c -o file\n之后使用gdb命令\n\n`gdb file`\n开始调试。\n\n输入`start`使程序运行到`main`中第一行运行代码。`next`或者n为执行下一行程序，`until xx`执行到xx行，print或p可输出变量值，`b xx`用于在xx行设置断点，`run`或`r`用于执行程序至下一断点，`d xx`删除xx行断点。\n\n我们可以先run一遍程序，这时它会提示出错行信息。然后`until`到出错行前5行，交替执行`next`和`print`，输出与出错行变量相关变量或指针的值。最终定位出错的根本操作在哪一行。修改之即可。","slug":"LinuxCmd/使用GDB查看core文件","published":1,"date":"2020-10-27T02:11:32.083Z","updated":"2020-10-10T01:08:41.754Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh1zfgzh002a7ktiev5u5w5u","content":"<h1 id=\"2-使用GDB查看core文件\"><a href=\"#2-使用GDB查看core文件\" class=\"headerlink\" title=\"2 使用GDB查看core文件\"></a>2 使用GDB查看core文件</h1><p>默认编译出来的程序在出现Segmentation fault 时并没有生成core崩溃文件，可以在gcc/g++编译时增加-g选项。</p>\n<p>如果仍然没有生成core文件，则可能是因为系统设置了core文件大小为0，可以通过：<code>ulimit -a</code> 查询得知。</p>\n<p>执行 <code>ulimit -c unlimited</code> 命令后可以使core文件大小不受限制。此时再次运行程序应该就能在同级目录看到<code>core.XXX</code>文件了</p>\n<p>使用 <code>gdb ./a.out core.XXX</code> 可以查看出错所在行信息，这样就进入了 gdb core 调试模式。</p>\n<p>追踪产生segmenttation fault的位置及代码函数调用情况：</p>\n<p><code>gdb&gt;bt</code></p>\n<p>这样，一般就可以看到出错的代码是哪一句了，还可以打印出相应变量的数值，进行进一步分析。</p>\n<p><a href=\"https://www.cnblogs.com/kuliuheng/p/11698378.html#_labelTop\">返回目录</a></p>\n<h1 id=\"3-使用GDB调试程序\"><a href=\"#3-使用GDB调试程序\" class=\"headerlink\" title=\"3 使用GDB调试程序\"></a><strong>3 使用GDB调试程序</strong></h1><p>如上述流程不能解决问题，下面可使用gdb单步调试程序。重新编译程序，编译命令中加入-g。如：</p>\n<p>gcc -lm -O3 -g file.c -o file<br>之后使用gdb命令</p>\n<p><code>gdb file</code><br>开始调试。</p>\n<p>输入<code>start</code>使程序运行到<code>main</code>中第一行运行代码。<code>next</code>或者n为执行下一行程序，<code>until xx</code>执行到xx行，print或p可输出变量值，<code>b xx</code>用于在xx行设置断点，<code>run</code>或<code>r</code>用于执行程序至下一断点，<code>d xx</code>删除xx行断点。</p>\n<p>我们可以先run一遍程序，这时它会提示出错行信息。然后<code>until</code>到出错行前5行，交替执行<code>next</code>和<code>print</code>，输出与出错行变量相关变量或指针的值。最终定位出错的根本操作在哪一行。修改之即可。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"2-使用GDB查看core文件\"><a href=\"#2-使用GDB查看core文件\" class=\"headerlink\" title=\"2 使用GDB查看core文件\"></a>2 使用GDB查看core文件</h1><p>默认编译出来的程序在出现Segmentation fault 时并没有生成core崩溃文件，可以在gcc/g++编译时增加-g选项。</p>\n<p>如果仍然没有生成core文件，则可能是因为系统设置了core文件大小为0，可以通过：<code>ulimit -a</code> 查询得知。</p>\n<p>执行 <code>ulimit -c unlimited</code> 命令后可以使core文件大小不受限制。此时再次运行程序应该就能在同级目录看到<code>core.XXX</code>文件了</p>\n<p>使用 <code>gdb ./a.out core.XXX</code> 可以查看出错所在行信息，这样就进入了 gdb core 调试模式。</p>\n<p>追踪产生segmenttation fault的位置及代码函数调用情况：</p>\n<p><code>gdb&gt;bt</code></p>\n<p>这样，一般就可以看到出错的代码是哪一句了，还可以打印出相应变量的数值，进行进一步分析。</p>\n<p><a href=\"https://www.cnblogs.com/kuliuheng/p/11698378.html#_labelTop\">返回目录</a></p>\n<h1 id=\"3-使用GDB调试程序\"><a href=\"#3-使用GDB调试程序\" class=\"headerlink\" title=\"3 使用GDB调试程序\"></a><strong>3 使用GDB调试程序</strong></h1><p>如上述流程不能解决问题，下面可使用gdb单步调试程序。重新编译程序，编译命令中加入-g。如：</p>\n<p>gcc -lm -O3 -g file.c -o file<br>之后使用gdb命令</p>\n<p><code>gdb file</code><br>开始调试。</p>\n<p>输入<code>start</code>使程序运行到<code>main</code>中第一行运行代码。<code>next</code>或者n为执行下一行程序，<code>until xx</code>执行到xx行，print或p可输出变量值，<code>b xx</code>用于在xx行设置断点，<code>run</code>或<code>r</code>用于执行程序至下一断点，<code>d xx</code>删除xx行断点。</p>\n<p>我们可以先run一遍程序，这时它会提示出错行信息。然后<code>until</code>到出错行前5行，交替执行<code>next</code>和<code>print</code>，输出与出错行变量相关变量或指针的值。最终定位出错的根本操作在哪一行。修改之即可。</p>\n"},{"title":"Summary of Two Pointer","date":"2020-11-03T12:44:38.000Z","_content":"\n### Two pointer解决套路\n\nTwo pointer和滑动窗口差不多，其套路一般为：\n\n1. 一个左指针，一个右指针。其中左指针用于缩小范围，右指针用于扩大搜索范围。一般求滑动窗口的最小值都是在缩小左指针的时候取得的。\n2. 右指针扩展的条件时：只要当前还没有满足条件，就暴力增长，直到第一次满足条件为止。\n3. 左指针收缩的条件：只要当前指针的缩小还没影响窗口的可满足性，就一直暴力向左增长。一但当前指针向前移动的时候影响了窗口的可满足性，就记录下当前的窗口大小，并更新目前为止满足条件的最小窗口记录。之后，再次扩展右指针，使得窗口满足题目的条件。\n4. 以此类推即可。\n\n","source":"_posts/LeetcodeSummary/TwoPointer.md","raw":"---\ntitle: Summary of Two Pointer\ndate: 2020-11-03 20:44:38\ncategories: leetcode_summary\ntags:\n\t- leetcode_summary\n---\n\n### Two pointer解决套路\n\nTwo pointer和滑动窗口差不多，其套路一般为：\n\n1. 一个左指针，一个右指针。其中左指针用于缩小范围，右指针用于扩大搜索范围。一般求滑动窗口的最小值都是在缩小左指针的时候取得的。\n2. 右指针扩展的条件时：只要当前还没有满足条件，就暴力增长，直到第一次满足条件为止。\n3. 左指针收缩的条件：只要当前指针的缩小还没影响窗口的可满足性，就一直暴力向左增长。一但当前指针向前移动的时候影响了窗口的可满足性，就记录下当前的窗口大小，并更新目前为止满足条件的最小窗口记录。之后，再次扩展右指针，使得窗口满足题目的条件。\n4. 以此类推即可。\n\n","slug":"LeetcodeSummary/TwoPointer","published":1,"updated":"2020-11-03T12:57:28.384Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh1zfgzh002b7kti3k6x7t1h","content":"<h3 id=\"Two-pointer解决套路\"><a href=\"#Two-pointer解决套路\" class=\"headerlink\" title=\"Two pointer解决套路\"></a>Two pointer解决套路</h3><p>Two pointer和滑动窗口差不多，其套路一般为：</p>\n<ol>\n<li>一个左指针，一个右指针。其中左指针用于缩小范围，右指针用于扩大搜索范围。一般求滑动窗口的最小值都是在缩小左指针的时候取得的。</li>\n<li>右指针扩展的条件时：只要当前还没有满足条件，就暴力增长，直到第一次满足条件为止。</li>\n<li>左指针收缩的条件：只要当前指针的缩小还没影响窗口的可满足性，就一直暴力向左增长。一但当前指针向前移动的时候影响了窗口的可满足性，就记录下当前的窗口大小，并更新目前为止满足条件的最小窗口记录。之后，再次扩展右指针，使得窗口满足题目的条件。</li>\n<li>以此类推即可。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Two-pointer解决套路\"><a href=\"#Two-pointer解决套路\" class=\"headerlink\" title=\"Two pointer解决套路\"></a>Two pointer解决套路</h3><p>Two pointer和滑动窗口差不多，其套路一般为：</p>\n<ol>\n<li>一个左指针，一个右指针。其中左指针用于缩小范围，右指针用于扩大搜索范围。一般求滑动窗口的最小值都是在缩小左指针的时候取得的。</li>\n<li>右指针扩展的条件时：只要当前还没有满足条件，就暴力增长，直到第一次满足条件为止。</li>\n<li>左指针收缩的条件：只要当前指针的缩小还没影响窗口的可满足性，就一直暴力向左增长。一但当前指针向前移动的时候影响了窗口的可满足性，就记录下当前的窗口大小，并更新目前为止满足条件的最小窗口记录。之后，再次扩展右指针，使得窗口满足题目的条件。</li>\n<li>以此类推即可。</li>\n</ol>\n"},{"title":"C++六种内存模型","date":"2020-10-30T03:29:45.000Z","_content":"\n## C++内存模型\n\nC++规定了6种访存顺序\n\n```C++\nenum memory_order {\n    memory_order_relaxed,\n    memory_order_consume,\n    memory_order_acquire,\n    memory_order_release,\n    memory_order_acq_rel,\n    memory_order_seq_cst\n};\n\n```\n\n这6种内存模型可以分为3类\n\n1. 顺序一致性模型, memory_order_seq_cst\n2. Acquire-release模型，也称为获取释放内存模型。\n   - memory_order_consume\n   - memory_order_acquire\n   - memory_order_release\n   - memory_order_acq_rel\n3. Relax模型，即memory_order_relaxed，宽松的内存序列化模型\n\n### memory_order_relaxed\n\n只保证当前操作的原子性，不考虑线程之间的同步，其它线程可以读到新值，也可以读到旧值。\n\n### memory_order_consume\n\n\n\n### memory_order_acquire\n\nacquire于内存的load操作对应，也就是读操作。设置该标志，表示在这条语句之后设置了barrier。\n\n即所有后续操作的读操作必须在本条原子操作完成之后执行。\n\n### memory_order_release\n\nrelease 对应于内存的 store操作，也就是写内存。设置标志，表示在这条语句之前设置了barrier。即所有之前的写操作完成之后才能执行本条原子操作。\n\n该语句和memory_order_qcquire有点相似，但是如何`见字如面`呢，即如何第一眼看到便区分开来呢。我是这样区分的：\n\n1. acquire和release的对象都是barrier；\n2. acquire即请求，请求之后，便得到了barrier，因此是在这条语句之后设置了barrier，因此后续的读(load)操作必须在本条原子操作完成之后；\n3. release即释放，要想释放，必须先拥有，即该条语句之前已经拥有了barrier，因此之前的写(store)操作完成之后，才能执行本条原子操作；\n4. acquire操作常用来读取数据的同步，release操作常用来写数据的同步。\n\n### memory_order_acq_rel\n\n对读取和写入施加acquire-release语句，无法被重排。\n\n可以看见其他线程施加release语义的所有写入，同时自己的release结束后所有写入对其施加acquire语义的线程可见。\n\n### memory_order_seq_cst\n\n","source":"_posts/Memory/Dynamic_memory_in_CPP.md","raw":"---\ntitle: C++六种内存模型\ndate: 2020-10-30 11:29:45\ncategories: Memory\ntags:\n\t- C++\n\t- Memory \n---\n\n## C++内存模型\n\nC++规定了6种访存顺序\n\n```C++\nenum memory_order {\n    memory_order_relaxed,\n    memory_order_consume,\n    memory_order_acquire,\n    memory_order_release,\n    memory_order_acq_rel,\n    memory_order_seq_cst\n};\n\n```\n\n这6种内存模型可以分为3类\n\n1. 顺序一致性模型, memory_order_seq_cst\n2. Acquire-release模型，也称为获取释放内存模型。\n   - memory_order_consume\n   - memory_order_acquire\n   - memory_order_release\n   - memory_order_acq_rel\n3. Relax模型，即memory_order_relaxed，宽松的内存序列化模型\n\n### memory_order_relaxed\n\n只保证当前操作的原子性，不考虑线程之间的同步，其它线程可以读到新值，也可以读到旧值。\n\n### memory_order_consume\n\n\n\n### memory_order_acquire\n\nacquire于内存的load操作对应，也就是读操作。设置该标志，表示在这条语句之后设置了barrier。\n\n即所有后续操作的读操作必须在本条原子操作完成之后执行。\n\n### memory_order_release\n\nrelease 对应于内存的 store操作，也就是写内存。设置标志，表示在这条语句之前设置了barrier。即所有之前的写操作完成之后才能执行本条原子操作。\n\n该语句和memory_order_qcquire有点相似，但是如何`见字如面`呢，即如何第一眼看到便区分开来呢。我是这样区分的：\n\n1. acquire和release的对象都是barrier；\n2. acquire即请求，请求之后，便得到了barrier，因此是在这条语句之后设置了barrier，因此后续的读(load)操作必须在本条原子操作完成之后；\n3. release即释放，要想释放，必须先拥有，即该条语句之前已经拥有了barrier，因此之前的写(store)操作完成之后，才能执行本条原子操作；\n4. acquire操作常用来读取数据的同步，release操作常用来写数据的同步。\n\n### memory_order_acq_rel\n\n对读取和写入施加acquire-release语句，无法被重排。\n\n可以看见其他线程施加release语义的所有写入，同时自己的release结束后所有写入对其施加acquire语义的线程可见。\n\n### memory_order_seq_cst\n\n","slug":"Memory/Dynamic_memory_in_CPP","published":1,"updated":"2020-11-05T01:39:11.126Z","_id":"ckh1zfgzi002c7kti1somgq3x","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"C-内存模型\"><a href=\"#C-内存模型\" class=\"headerlink\" title=\"C++内存模型\"></a>C++内存模型</h2><p>C++规定了6种访存顺序</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> memory_order &#123;</span><br><span class=\"line\">    memory_order_relaxed,</span><br><span class=\"line\">    memory_order_consume,</span><br><span class=\"line\">    memory_order_acquire,</span><br><span class=\"line\">    memory_order_release,</span><br><span class=\"line\">    memory_order_acq_rel,</span><br><span class=\"line\">    memory_order_seq_cst</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这6种内存模型可以分为3类</p>\n<ol>\n<li>顺序一致性模型, memory_order_seq_cst</li>\n<li>Acquire-release模型，也称为获取释放内存模型。<ul>\n<li>memory_order_consume</li>\n<li>memory_order_acquire</li>\n<li>memory_order_release</li>\n<li>memory_order_acq_rel</li>\n</ul>\n</li>\n<li>Relax模型，即memory_order_relaxed，宽松的内存序列化模型</li>\n</ol>\n<h3 id=\"memory-order-relaxed\"><a href=\"#memory-order-relaxed\" class=\"headerlink\" title=\"memory_order_relaxed\"></a>memory_order_relaxed</h3><p>只保证当前操作的原子性，不考虑线程之间的同步，其它线程可以读到新值，也可以读到旧值。</p>\n<h3 id=\"memory-order-consume\"><a href=\"#memory-order-consume\" class=\"headerlink\" title=\"memory_order_consume\"></a>memory_order_consume</h3><h3 id=\"memory-order-acquire\"><a href=\"#memory-order-acquire\" class=\"headerlink\" title=\"memory_order_acquire\"></a>memory_order_acquire</h3><p>acquire于内存的load操作对应，也就是读操作。设置该标志，表示在这条语句之后设置了barrier。</p>\n<p>即所有后续操作的读操作必须在本条原子操作完成之后执行。</p>\n<h3 id=\"memory-order-release\"><a href=\"#memory-order-release\" class=\"headerlink\" title=\"memory_order_release\"></a>memory_order_release</h3><p>release 对应于内存的 store操作，也就是写内存。设置标志，表示在这条语句之前设置了barrier。即所有之前的写操作完成之后才能执行本条原子操作。</p>\n<p>该语句和memory_order_qcquire有点相似，但是如何<code>见字如面</code>呢，即如何第一眼看到便区分开来呢。我是这样区分的：</p>\n<ol>\n<li>acquire和release的对象都是barrier；</li>\n<li>acquire即请求，请求之后，便得到了barrier，因此是在这条语句之后设置了barrier，因此后续的读(load)操作必须在本条原子操作完成之后；</li>\n<li>release即释放，要想释放，必须先拥有，即该条语句之前已经拥有了barrier，因此之前的写(store)操作完成之后，才能执行本条原子操作；</li>\n<li>acquire操作常用来读取数据的同步，release操作常用来写数据的同步。</li>\n</ol>\n<h3 id=\"memory-order-acq-rel\"><a href=\"#memory-order-acq-rel\" class=\"headerlink\" title=\"memory_order_acq_rel\"></a>memory_order_acq_rel</h3><p>对读取和写入施加acquire-release语句，无法被重排。</p>\n<p>可以看见其他线程施加release语义的所有写入，同时自己的release结束后所有写入对其施加acquire语义的线程可见。</p>\n<h3 id=\"memory-order-seq-cst\"><a href=\"#memory-order-seq-cst\" class=\"headerlink\" title=\"memory_order_seq_cst\"></a>memory_order_seq_cst</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"C-内存模型\"><a href=\"#C-内存模型\" class=\"headerlink\" title=\"C++内存模型\"></a>C++内存模型</h2><p>C++规定了6种访存顺序</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> memory_order &#123;</span><br><span class=\"line\">    memory_order_relaxed,</span><br><span class=\"line\">    memory_order_consume,</span><br><span class=\"line\">    memory_order_acquire,</span><br><span class=\"line\">    memory_order_release,</span><br><span class=\"line\">    memory_order_acq_rel,</span><br><span class=\"line\">    memory_order_seq_cst</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这6种内存模型可以分为3类</p>\n<ol>\n<li>顺序一致性模型, memory_order_seq_cst</li>\n<li>Acquire-release模型，也称为获取释放内存模型。<ul>\n<li>memory_order_consume</li>\n<li>memory_order_acquire</li>\n<li>memory_order_release</li>\n<li>memory_order_acq_rel</li>\n</ul>\n</li>\n<li>Relax模型，即memory_order_relaxed，宽松的内存序列化模型</li>\n</ol>\n<h3 id=\"memory-order-relaxed\"><a href=\"#memory-order-relaxed\" class=\"headerlink\" title=\"memory_order_relaxed\"></a>memory_order_relaxed</h3><p>只保证当前操作的原子性，不考虑线程之间的同步，其它线程可以读到新值，也可以读到旧值。</p>\n<h3 id=\"memory-order-consume\"><a href=\"#memory-order-consume\" class=\"headerlink\" title=\"memory_order_consume\"></a>memory_order_consume</h3><h3 id=\"memory-order-acquire\"><a href=\"#memory-order-acquire\" class=\"headerlink\" title=\"memory_order_acquire\"></a>memory_order_acquire</h3><p>acquire于内存的load操作对应，也就是读操作。设置该标志，表示在这条语句之后设置了barrier。</p>\n<p>即所有后续操作的读操作必须在本条原子操作完成之后执行。</p>\n<h3 id=\"memory-order-release\"><a href=\"#memory-order-release\" class=\"headerlink\" title=\"memory_order_release\"></a>memory_order_release</h3><p>release 对应于内存的 store操作，也就是写内存。设置标志，表示在这条语句之前设置了barrier。即所有之前的写操作完成之后才能执行本条原子操作。</p>\n<p>该语句和memory_order_qcquire有点相似，但是如何<code>见字如面</code>呢，即如何第一眼看到便区分开来呢。我是这样区分的：</p>\n<ol>\n<li>acquire和release的对象都是barrier；</li>\n<li>acquire即请求，请求之后，便得到了barrier，因此是在这条语句之后设置了barrier，因此后续的读(load)操作必须在本条原子操作完成之后；</li>\n<li>release即释放，要想释放，必须先拥有，即该条语句之前已经拥有了barrier，因此之前的写(store)操作完成之后，才能执行本条原子操作；</li>\n<li>acquire操作常用来读取数据的同步，release操作常用来写数据的同步。</li>\n</ol>\n<h3 id=\"memory-order-acq-rel\"><a href=\"#memory-order-acq-rel\" class=\"headerlink\" title=\"memory_order_acq_rel\"></a>memory_order_acq_rel</h3><p>对读取和写入施加acquire-release语句，无法被重排。</p>\n<p>可以看见其他线程施加release语义的所有写入，同时自己的release结束后所有写入对其施加acquire语义的线程可见。</p>\n<h3 id=\"memory-order-seq-cst\"><a href=\"#memory-order-seq-cst\" class=\"headerlink\" title=\"memory_order_seq_cst\"></a>memory_order_seq_cst</h3>"},{"_content":"# TCP 最大连接数为28232\n\nLinux对外的端口分配是有一定限制的，默认不超过28232个。\n\n```shell\ncat /proc/sys/net/ipv4/ip_local_range\n# 输出为\n32768 60999\n\n```\n\n## 方法一\n\n两个数字相减刚好为28232。如果要对其范围进行修改，可将两个数字更改为10000 65535，注意用户可用端口方位为1024~65535.\n\n```shell\n  echo \"10000 65535\" > /proc/sys/net/ipv4/ip_local_port_range\n  sysctl -p\t\n```\n\n## 方法二\n\n快速回收端口\n\n```shell\nsudo vim /etc/sysctl.conf\n# 末尾添加上\nnet.ipv4.tcp_tw_recycle=1\nsysctl -p\n```\n\n## 语言\n\n系统在高并发短连接的情况下，会出现大量处于TIME_WAIT的SOCKET。\n\n这里短连接是指：**业务处理+传输数据的时间 远远小于 TIMEWAIT超时的时间”的连接**\n\n","source":"_posts/Socket/2020-09-21-TCP最大连接数.md","raw":"# TCP 最大连接数为28232\n\nLinux对外的端口分配是有一定限制的，默认不超过28232个。\n\n```shell\ncat /proc/sys/net/ipv4/ip_local_range\n# 输出为\n32768 60999\n\n```\n\n## 方法一\n\n两个数字相减刚好为28232。如果要对其范围进行修改，可将两个数字更改为10000 65535，注意用户可用端口方位为1024~65535.\n\n```shell\n  echo \"10000 65535\" > /proc/sys/net/ipv4/ip_local_port_range\n  sysctl -p\t\n```\n\n## 方法二\n\n快速回收端口\n\n```shell\nsudo vim /etc/sysctl.conf\n# 末尾添加上\nnet.ipv4.tcp_tw_recycle=1\nsysctl -p\n```\n\n## 语言\n\n系统在高并发短连接的情况下，会出现大量处于TIME_WAIT的SOCKET。\n\n这里短连接是指：**业务处理+传输数据的时间 远远小于 TIMEWAIT超时的时间”的连接**\n\n","slug":"Socket/2020-09-21-TCP最大连接数","published":1,"date":"2020-10-27T02:11:32.097Z","updated":"2020-10-10T01:08:41.752Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh1zfgzl002f7kti2ufl9se4","content":"<h1 id=\"TCP-最大连接数为28232\"><a href=\"#TCP-最大连接数为28232\" class=\"headerlink\" title=\"TCP 最大连接数为28232\"></a>TCP 最大连接数为28232</h1><p>Linux对外的端口分配是有一定限制的，默认不超过28232个。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /proc/sys/net/ipv4/ip_local_range</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 输出为</span></span><br><span class=\"line\">32768 60999</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h2><p>两个数字相减刚好为28232。如果要对其范围进行修改，可将两个数字更改为10000 65535，注意用户可用端口方位为1024~65535.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &quot;10000 65535&quot; &gt; /proc/sys/net/ipv4/ip_local_port_range</span><br><span class=\"line\">sysctl -p\t</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h2><p>快速回收端口</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/sysctl.conf</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 末尾添加上</span></span><br><span class=\"line\">net.ipv4.tcp_tw_recycle=1</span><br><span class=\"line\">sysctl -p</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"语言\"><a href=\"#语言\" class=\"headerlink\" title=\"语言\"></a>语言</h2><p>系统在高并发短连接的情况下，会出现大量处于TIME_WAIT的SOCKET。</p>\n<p>这里短连接是指：<strong>业务处理+传输数据的时间 远远小于 TIMEWAIT超时的时间”的连接</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"TCP-最大连接数为28232\"><a href=\"#TCP-最大连接数为28232\" class=\"headerlink\" title=\"TCP 最大连接数为28232\"></a>TCP 最大连接数为28232</h1><p>Linux对外的端口分配是有一定限制的，默认不超过28232个。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /proc/sys/net/ipv4/ip_local_range</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 输出为</span></span><br><span class=\"line\">32768 60999</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h2><p>两个数字相减刚好为28232。如果要对其范围进行修改，可将两个数字更改为10000 65535，注意用户可用端口方位为1024~65535.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &quot;10000 65535&quot; &gt; /proc/sys/net/ipv4/ip_local_port_range</span><br><span class=\"line\">sysctl -p\t</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h2><p>快速回收端口</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/sysctl.conf</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 末尾添加上</span></span><br><span class=\"line\">net.ipv4.tcp_tw_recycle=1</span><br><span class=\"line\">sysctl -p</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"语言\"><a href=\"#语言\" class=\"headerlink\" title=\"语言\"></a>语言</h2><p>系统在高并发短连接的情况下，会出现大量处于TIME_WAIT的SOCKET。</p>\n<p>这里短连接是指：<strong>业务处理+传输数据的时间 远远小于 TIMEWAIT超时的时间”的连接</strong></p>\n"},{"_content":"# Socket 之Close与Shutdown\n\n## 区别\n\n1. close会释放文件句柄，而shutdown不会。\n2. close把描述符的引用计数减1，仅在该计数变为0时关闭套接字。shutdown可以不管引用计数就激发TCP的正常连接终止序列，因此在多进程环境中：close()是关闭本进程的socket id，但链接还是开着的，用这个socket id的其它进程还能用这个链接，能读或写这个socket id，而shutdown执行的操作对所有进程有效。\n\n## Strace\n\n```shell\nstrace ./exec\n```\n\n","source":"_posts/Socket/20200914-socket_close_shutdown.md","raw":"# Socket 之Close与Shutdown\n\n## 区别\n\n1. close会释放文件句柄，而shutdown不会。\n2. close把描述符的引用计数减1，仅在该计数变为0时关闭套接字。shutdown可以不管引用计数就激发TCP的正常连接终止序列，因此在多进程环境中：close()是关闭本进程的socket id，但链接还是开着的，用这个socket id的其它进程还能用这个链接，能读或写这个socket id，而shutdown执行的操作对所有进程有效。\n\n## Strace\n\n```shell\nstrace ./exec\n```\n\n","slug":"Socket/20200914-socket_close_shutdown","published":1,"date":"2020-10-27T02:11:32.107Z","updated":"2020-10-10T01:08:41.753Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh1zfgzm002g7ktidyx1ci9h","content":"<h1 id=\"Socket-之Close与Shutdown\"><a href=\"#Socket-之Close与Shutdown\" class=\"headerlink\" title=\"Socket 之Close与Shutdown\"></a>Socket 之Close与Shutdown</h1><h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2><ol>\n<li>close会释放文件句柄，而shutdown不会。</li>\n<li>close把描述符的引用计数减1，仅在该计数变为0时关闭套接字。shutdown可以不管引用计数就激发TCP的正常连接终止序列，因此在多进程环境中：close()是关闭本进程的socket id，但链接还是开着的，用这个socket id的其它进程还能用这个链接，能读或写这个socket id，而shutdown执行的操作对所有进程有效。</li>\n</ol>\n<h2 id=\"Strace\"><a href=\"#Strace\" class=\"headerlink\" title=\"Strace\"></a>Strace</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strace ./exec</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Socket-之Close与Shutdown\"><a href=\"#Socket-之Close与Shutdown\" class=\"headerlink\" title=\"Socket 之Close与Shutdown\"></a>Socket 之Close与Shutdown</h1><h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2><ol>\n<li>close会释放文件句柄，而shutdown不会。</li>\n<li>close把描述符的引用计数减1，仅在该计数变为0时关闭套接字。shutdown可以不管引用计数就激发TCP的正常连接终止序列，因此在多进程环境中：close()是关闭本进程的socket id，但链接还是开着的，用这个socket id的其它进程还能用这个链接，能读或写这个socket id，而shutdown执行的操作对所有进程有效。</li>\n</ol>\n<h2 id=\"Strace\"><a href=\"#Strace\" class=\"headerlink\" title=\"Strace\"></a>Strace</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strace ./exec</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Leetcode 986. Interval List Intersections","date":"2020-11-04T14:17:22.000Z","_content":"\n\n## 题目描述\n\n[英文题目](https://leetcode.com/problems/interval-list-intersections/)\n\n[中文题目](https://leetcode-cn.com/problems/interval-list-intersections/)\n\n难度：中等\n\n### 题意\n\n求两组线段集合的交集。\n\n**示例：**\n\n```txt\nInput: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]\nOutput: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]\n```\n\n### 解题思路\n\n该题目分类属于中等题，且用two pointer进行解决。\n\n#### 思路\n\n1. 两个指针，一个指针指向线段集合A，一个指针指向线段集合B；\n2. 依次移动两个指针，如果发现当前两个指针之间有交集，则求交集之后放入结果中，否则，视情况移动两个指针；\n\n**代码如下：**\n\n```java\nclass Solution {\n    public int[][] intervalIntersection(int[][] A, int[][] B) {\n        \n        int lenA = A.length;\n        int lenB = B.length;\n        \n        List<Node> list = new ArrayList<>();\n        int currA = 0;\n        int currB = 0;\n        \n        while (currA < lenA && currB < lenB) {\n            if (A[currA][1] < B[currB][0]) { // 没交集的情况\n                currA++;\n                continue;\n            }\n            if (B[currB][1] < A[currA][0]) { // 没交集的情况\n                currB++;\n                continue;\n            }\n            int maxL = Math.max(A[currA][0], B[currB][0]);\n            int minR = Math.min(A[currA][1], B[currB][1]);\n            list.add(new Node(maxL, minR));\n            if (A[currA][1] == minR) currA++;\n            if (B[currB][1] == minR) currB++;\n        }\n        \n        int[][] ans = new int[list.size()][2];\n        int len = list.size();\n        for (int i = 0; i < len; i++) {\n            Node tmp = list.get(i);\n            ans[i][0] = tmp.l;\n            ans[i][1] = tmp.r;\n        }\n        return ans;\n    }\n    \n    class Node {\n        int l;\n        int r;\n        Node(int l_, int r_) {\n            this.l = l_;\n            this.r = r_;\n        }\n    }\n}\n```\n\n","source":"_posts/Leetcode/986.md","raw":"---\ntitle: Leetcode 986. Interval List Intersections\ndate: 2020-11-04 22:17:22\ncategories: leetcode\ntags:\n\t- two pointer\n\t- algorithm \n---\n\n\n## 题目描述\n\n[英文题目](https://leetcode.com/problems/interval-list-intersections/)\n\n[中文题目](https://leetcode-cn.com/problems/interval-list-intersections/)\n\n难度：中等\n\n### 题意\n\n求两组线段集合的交集。\n\n**示例：**\n\n```txt\nInput: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]\nOutput: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]\n```\n\n### 解题思路\n\n该题目分类属于中等题，且用two pointer进行解决。\n\n#### 思路\n\n1. 两个指针，一个指针指向线段集合A，一个指针指向线段集合B；\n2. 依次移动两个指针，如果发现当前两个指针之间有交集，则求交集之后放入结果中，否则，视情况移动两个指针；\n\n**代码如下：**\n\n```java\nclass Solution {\n    public int[][] intervalIntersection(int[][] A, int[][] B) {\n        \n        int lenA = A.length;\n        int lenB = B.length;\n        \n        List<Node> list = new ArrayList<>();\n        int currA = 0;\n        int currB = 0;\n        \n        while (currA < lenA && currB < lenB) {\n            if (A[currA][1] < B[currB][0]) { // 没交集的情况\n                currA++;\n                continue;\n            }\n            if (B[currB][1] < A[currA][0]) { // 没交集的情况\n                currB++;\n                continue;\n            }\n            int maxL = Math.max(A[currA][0], B[currB][0]);\n            int minR = Math.min(A[currA][1], B[currB][1]);\n            list.add(new Node(maxL, minR));\n            if (A[currA][1] == minR) currA++;\n            if (B[currB][1] == minR) currB++;\n        }\n        \n        int[][] ans = new int[list.size()][2];\n        int len = list.size();\n        for (int i = 0; i < len; i++) {\n            Node tmp = list.get(i);\n            ans[i][0] = tmp.l;\n            ans[i][1] = tmp.r;\n        }\n        return ans;\n    }\n    \n    class Node {\n        int l;\n        int r;\n        Node(int l_, int r_) {\n            this.l = l_;\n            this.r = r_;\n        }\n    }\n}\n```\n\n","slug":"Leetcode/986","published":1,"updated":"2020-11-04T14:21:25.980Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh3hprnk0000swti3l8tdf38","content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><a href=\"https://leetcode.com/problems/interval-list-intersections/\">英文题目</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/interval-list-intersections/\">中文题目</a></p>\n<p>难度：中等</p>\n<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>求两组线段集合的交集。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]</span><br><span class=\"line\">Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决。</p>\n<h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ol>\n<li>两个指针，一个指针指向线段集合A，一个指针指向线段集合B；</li>\n<li>依次移动两个指针，如果发现当前两个指针之间有交集，则求交集之后放入结果中，否则，视情况移动两个指针；</li>\n</ol>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] intervalIntersection(<span class=\"keyword\">int</span>[][] A, <span class=\"keyword\">int</span>[][] B) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> lenA = A.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lenB = B.length;</span><br><span class=\"line\">        </span><br><span class=\"line\">        List&lt;Node&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> currA = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> currB = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (currA &lt; lenA &amp;&amp; currB &lt; lenB) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (A[currA][<span class=\"number\">1</span>] &lt; B[currB][<span class=\"number\">0</span>]) &#123; <span class=\"comment\">// 没交集的情况</span></span><br><span class=\"line\">                currA++;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (B[currB][<span class=\"number\">1</span>] &lt; A[currA][<span class=\"number\">0</span>]) &#123; <span class=\"comment\">// 没交集的情况</span></span><br><span class=\"line\">                currB++;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> maxL = Math.max(A[currA][<span class=\"number\">0</span>], B[currB][<span class=\"number\">0</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> minR = Math.min(A[currA][<span class=\"number\">1</span>], B[currB][<span class=\"number\">1</span>]);</span><br><span class=\"line\">            list.add(<span class=\"keyword\">new</span> Node(maxL, minR));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (A[currA][<span class=\"number\">1</span>] == minR) currA++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (B[currB][<span class=\"number\">1</span>] == minR) currB++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] ans = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[list.size()][<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = list.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            Node tmp = list.get(i);</span><br><span class=\"line\">            ans[i][<span class=\"number\">0</span>] = tmp.l;</span><br><span class=\"line\">            ans[i][<span class=\"number\">1</span>] = tmp.r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r;</span><br><span class=\"line\">        Node(<span class=\"keyword\">int</span> l_, <span class=\"keyword\">int</span> r_) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.l = l_;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.r = r_;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><a href=\"https://leetcode.com/problems/interval-list-intersections/\">英文题目</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/interval-list-intersections/\">中文题目</a></p>\n<p>难度：中等</p>\n<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>求两组线段集合的交集。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]</span><br><span class=\"line\">Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决。</p>\n<h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ol>\n<li>两个指针，一个指针指向线段集合A，一个指针指向线段集合B；</li>\n<li>依次移动两个指针，如果发现当前两个指针之间有交集，则求交集之后放入结果中，否则，视情况移动两个指针；</li>\n</ol>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] intervalIntersection(<span class=\"keyword\">int</span>[][] A, <span class=\"keyword\">int</span>[][] B) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> lenA = A.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lenB = B.length;</span><br><span class=\"line\">        </span><br><span class=\"line\">        List&lt;Node&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> currA = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> currB = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (currA &lt; lenA &amp;&amp; currB &lt; lenB) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (A[currA][<span class=\"number\">1</span>] &lt; B[currB][<span class=\"number\">0</span>]) &#123; <span class=\"comment\">// 没交集的情况</span></span><br><span class=\"line\">                currA++;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (B[currB][<span class=\"number\">1</span>] &lt; A[currA][<span class=\"number\">0</span>]) &#123; <span class=\"comment\">// 没交集的情况</span></span><br><span class=\"line\">                currB++;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> maxL = Math.max(A[currA][<span class=\"number\">0</span>], B[currB][<span class=\"number\">0</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> minR = Math.min(A[currA][<span class=\"number\">1</span>], B[currB][<span class=\"number\">1</span>]);</span><br><span class=\"line\">            list.add(<span class=\"keyword\">new</span> Node(maxL, minR));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (A[currA][<span class=\"number\">1</span>] == minR) currA++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (B[currB][<span class=\"number\">1</span>] == minR) currB++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] ans = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[list.size()][<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = list.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            Node tmp = list.get(i);</span><br><span class=\"line\">            ans[i][<span class=\"number\">0</span>] = tmp.l;</span><br><span class=\"line\">            ans[i][<span class=\"number\">1</span>] = tmp.r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r;</span><br><span class=\"line\">        Node(<span class=\"keyword\">int</span> l_, <span class=\"keyword\">int</span> r_) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.l = l_;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.r = r_;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"SkipList in LevelDB","date":"2020-11-05T02:33:33.000Z","_content":"\n\n\nLevelDB中有一份非常优雅的SkipList的实现方式，这里拿过来供学习。\n\nSkipList的一些特性：\n\n1. 最底层是0层，该层最长，最高层是大层，该层最短；\n2. 查找的过程总是从左上至右下；\n\n\n\n### 代码\n\n```java\n// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file. See the AUTHORS file for names of contributors.\n\n#ifndef STORAGE_LEVELDB_DB_SKIPLIST_H_\n#define STORAGE_LEVELDB_DB_SKIPLIST_H_\n\n// Thread safety\n// -------------\n//\n// Writes require external synchronization, most likely a mutex.\n// Reads require a guarantee that the SkipList will not be destroyed\n// while the read is in progress.  Apart from that, reads progress\n// without any internal locking or synchronization.\n//\n// Invariants:\n//\n// (1) Allocated nodes are never deleted until the SkipList is\n// destroyed.  This is trivially guaranteed by the code since we\n// never delete any skip list nodes.\n//\n// (2) The contents of a Node except for the next/prev pointers are\n// immutable after the Node has been linked into the SkipList.\n// Only Insert() modifies the list, and it is careful to initialize\n// a node and use release-stores to publish the nodes in one or\n// more lists.\n//\n// ... prev vs. next pointer ordering ...\n\n#include <atomic>\n#include <cassert>\n#include <cstdlib>\n\n#include \"util/arena.h\"\n#include \"util/random.h\"\n\nnamespace leveldb {\n\nclass Arena;\n\ntemplate <typename Key, class Comparator>\nclass SkipList {\n private:\n  struct Node;\n\n public:\n  // Create a new SkipList object that will use \"cmp\" for comparing keys,\n  // and will allocate memory using \"*arena\".  Objects allocated in the arena\n  // must remain allocated for the lifetime of the skiplist object.\n  explicit SkipList(Comparator cmp, Arena* arena);\n\n  SkipList(const SkipList&) = delete;\n  SkipList& operator=(const SkipList&) = delete;\n\n  // Insert key into the list.\n  // REQUIRES: nothing that compares equal to key is currently in the list.\n  void Insert(const Key& key);\n\n  // Returns true iff an entry that compares equal to key is in the list.\n  bool Contains(const Key& key) const;\n\n  // Iteration over the contents of a skip list\n  class Iterator {\n   public:\n    // Initialize an iterator over the specified list.\n    // The returned iterator is not valid.\n    explicit Iterator(const SkipList* list);\n\n    // Returns true iff the iterator is positioned at a valid node.\n    bool Valid() const;\n\n    // Returns the key at the current position.\n    // REQUIRES: Valid()\n    const Key& key() const;\n\n    // Advances to the next position.\n    // REQUIRES: Valid()\n    void Next();\n\n    // Advances to the previous position.\n    // REQUIRES: Valid()\n    void Prev();\n\n    // Advance to the first entry with a key >= target\n    void Seek(const Key& target);\n\n    // Position at the first entry in list.\n    // Final state of iterator is Valid() iff list is not empty.\n    void SeekToFirst();\n\n    // Position at the last entry in list.\n    // Final state of iterator is Valid() iff list is not empty.\n    void SeekToLast();\n\n   private:\n    const SkipList* list_;\n    Node* node_;\n    // Intentionally copyable\n  };\n\n private:\n  enum { kMaxHeight = 12 };\n\n  inline int GetMaxHeight() const {\n    return max_height_.load(std::memory_order_relaxed);\n  }\n\n  Node* NewNode(const Key& key, int height);\n  int RandomHeight();\n  bool Equal(const Key& a, const Key& b) const { return (compare_(a, b) == 0); }\n\n  // Return true if key is greater than the data stored in \"n\"\n  bool KeyIsAfterNode(const Key& key, Node* n) const;\n\n  // Return the earliest node that comes at or after key.\n  // Return nullptr if there is no such node.\n  //\n  // If prev is non-null, fills prev[level] with pointer to previous\n  // node at \"level\" for every level in [0..max_height_-1].\n  Node* FindGreaterOrEqual(const Key& key, Node** prev) const;\n\n  // Return the latest node with a key < key.\n  // Return head_ if there is no such node.\n  Node* FindLessThan(const Key& key) const;\n\n  // Return the last node in the list.\n  // Return head_ if list is empty.\n  Node* FindLast() const;\n\n  // Immutable after construction\n  Comparator const compare_;\n  Arena* const arena_;  // Arena used for allocations of nodes\n\n  Node* const head_;\n\n  // Modified only by Insert().  Read racily by readers, but stale\n  // values are ok.\n  std::atomic<int> max_height_;  // Height of the entire list\n\n  // Read/written only by Insert().\n  Random rnd_;\n};\n\n// Implementation details follow\ntemplate <typename Key, class Comparator>\nstruct SkipList<Key, Comparator>::Node {\n  explicit Node(const Key& k) : key(k) {}\n\n  Key const key;\n\n  // Accessors/mutators for links.  Wrapped in methods so we can\n  // add the appropriate barriers as necessary.\n  Node* Next(int n) {\n    assert(n >= 0);\n    // Use an 'acquire load' so that we observe a fully initialized\n    // version of the returned Node.\n    return next_[n].load(std::memory_order_acquire);\n  }\n  void SetNext(int n, Node* x) {\n    assert(n >= 0);\n    // Use a 'release store' so that anybody who reads through this\n    // pointer observes a fully initialized version of the inserted node.\n    next_[n].store(x, std::memory_order_release);\n  }\n\n  // No-barrier variants that can be safely used in a few locations.\n  Node* NoBarrier_Next(int n) {\n    assert(n >= 0);\n    return next_[n].load(std::memory_order_relaxed);\n  }\n  void NoBarrier_SetNext(int n, Node* x) {\n    assert(n >= 0);\n    next_[n].store(x, std::memory_order_relaxed);\n  }\n\n private:\n  // Array of length equal to the node height.  next_[0] is lowest level link.\n  std::atomic<Node*> next_[1];\n};\n\ntemplate <typename Key, class Comparator>\ntypename SkipList<Key, Comparator>::Node* SkipList<Key, Comparator>::NewNode(\n    const Key& key, int height) {\n  char* const node_memory = arena_->AllocateAligned(\n      sizeof(Node) + sizeof(std::atomic<Node*>) * (height - 1));\n  return new (node_memory) Node(key);\n}\n\ntemplate <typename Key, class Comparator>\ninline SkipList<Key, Comparator>::Iterator::Iterator(const SkipList* list) {\n  list_ = list;\n  node_ = nullptr;\n}\n\ntemplate <typename Key, class Comparator>\ninline bool SkipList<Key, Comparator>::Iterator::Valid() const {\n  return node_ != nullptr;\n}\n\ntemplate <typename Key, class Comparator>\ninline const Key& SkipList<Key, Comparator>::Iterator::key() const {\n  assert(Valid());\n  return node_->key;\n}\n\ntemplate <typename Key, class Comparator>\ninline void SkipList<Key, Comparator>::Iterator::Next() {\n  assert(Valid());\n  node_ = node_->Next(0);\n}\n\ntemplate <typename Key, class Comparator>\ninline void SkipList<Key, Comparator>::Iterator::Prev() {\n  // Instead of using explicit \"prev\" links, we just search for the\n  // last node that falls before key.\n  assert(Valid());\n  node_ = list_->FindLessThan(node_->key);\n  if (node_ == list_->head_) {\n    node_ = nullptr;\n  }\n}\n\ntemplate <typename Key, class Comparator>\ninline void SkipList<Key, Comparator>::Iterator::Seek(const Key& target) {\n  node_ = list_->FindGreaterOrEqual(target, nullptr);\n}\n\ntemplate <typename Key, class Comparator>\ninline void SkipList<Key, Comparator>::Iterator::SeekToFirst() {\n  node_ = list_->head_->Next(0);\n}\n\ntemplate <typename Key, class Comparator>\ninline void SkipList<Key, Comparator>::Iterator::SeekToLast() {\n  node_ = list_->FindLast();\n  if (node_ == list_->head_) {\n    node_ = nullptr;\n  }\n}\n\ntemplate <typename Key, class Comparator>\nint SkipList<Key, Comparator>::RandomHeight() {\n  // Increase height with probability 1 in kBranching\n  static const unsigned int kBranching = 4;\n  int height = 1;\n  // TODO lwl，这里不会使得kMaxHeight超过最大值么\n  while (height < kMaxHeight && ((rnd_.Next() % kBranching) == 0)) {\n    height++;\n  }\n  assert(height > 0);\n  assert(height <= kMaxHeight);\n  return height;\n}\n\ntemplate <typename Key, class Comparator>\nbool SkipList<Key, Comparator>::KeyIsAfterNode(const Key& key, Node* n) const {\n  // null n is considered infinite\n  return (n != nullptr) && (compare_(n->key, key) < 0);\n}\n\ntemplate <typename Key, class Comparator>\ntypename SkipList<Key, Comparator>::Node*\nSkipList<Key, Comparator>::FindGreaterOrEqual(const Key& key,\n                                              Node** prev) const {\n  Node* x = head_;\n  int level = GetMaxHeight() - 1;\n  while (true) {\n    Node* next = x->Next(level);\n    if (KeyIsAfterNode(key, next)) {\n      // Keep searching in this list\n      x = next;\n    } else {\n      if (prev != nullptr) prev[level] = x;\n      if (level == 0) {\n        return next;\n      } else {\n        // Switch to next list\n        level--;\n      }\n    }\n  }\n}\n\ntemplate <typename Key, class Comparator>\ntypename SkipList<Key, Comparator>::Node*\nSkipList<Key, Comparator>::FindLessThan(const Key& key) const {\n  Node* x = head_;\n  int level = GetMaxHeight() - 1;\n  while (true) {\n    assert(x == head_ || compare_(x->key, key) < 0);\n    Node* next = x->Next(level);\n    if (next == nullptr || compare_(next->key, key) >= 0) {\n      if (level == 0) {\n        return x;\n      } else {\n        // Switch to next list\n        level--;\n      }\n    } else {\n      x = next;\n    }\n  }\n}\n\ntemplate <typename Key, class Comparator>\ntypename SkipList<Key, Comparator>::Node* SkipList<Key, Comparator>::FindLast()\n    const {\n  Node* x = head_;\n  int level = GetMaxHeight() - 1;\n  while (true) {\n    Node* next = x->Next(level);\n    if (next == nullptr) {\n      if (level == 0) {\n        return x;\n      } else {\n        // Switch to next list\n        level--;\n      }\n    } else {\n      x = next;\n    }\n  }\n}\n\ntemplate <typename Key, class Comparator>\nSkipList<Key, Comparator>::SkipList(Comparator cmp, Arena* arena)\n    : compare_(cmp),\n      arena_(arena),\n      head_(NewNode(0 /* any key will do */, kMaxHeight)),\n      max_height_(1),\n      rnd_(0xdeadbeef) {\n  for (int i = 0; i < kMaxHeight; i++) {\n    head_->SetNext(i, nullptr);\n  }\n}\n\ntemplate <typename Key, class Comparator>\nvoid SkipList<Key, Comparator>::Insert(const Key& key) {\n  // TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()\n  // here since Insert() is externally synchronized.\n  Node* prev[kMaxHeight];\n  Node* x = FindGreaterOrEqual(key, prev);\n\n  // Our data structure does not allow duplicate insertion\n  assert(x == nullptr || !Equal(key, x->key));\n\n  int height = RandomHeight();\n  if (height > GetMaxHeight()) {\n    for (int i = GetMaxHeight(); i < height; i++) {\n      prev[i] = head_;\n    }\n    // It is ok to mutate max_height_ without any synchronization\n    // with concurrent readers.  A concurrent reader that observes\n    // the new value of max_height_ will see either the old value of\n    // new level pointers from head_ (nullptr), or a new value set in\n    // the loop below.  In the former case the reader will\n    // immediately drop to the next level since nullptr sorts after all\n    // keys.  In the latter case the reader will use the new node.\n    max_height_.store(height, std::memory_order_relaxed);\n  }\n\n  x = NewNode(key, height);\n  for (int i = 0; i < height; i++) {\n    // NoBarrier_SetNext() suffices since we will add a barrier when\n    // we publish a pointer to \"x\" in prev[i].\n    x->NoBarrier_SetNext(i, prev[i]->NoBarrier_Next(i));\n    prev[i]->SetNext(i, x);\n  }\n}\n\ntemplate <typename Key, class Comparator>\nbool SkipList<Key, Comparator>::Contains(const Key& key) const {\n  Node* x = FindGreaterOrEqual(key, nullptr);\n  if (x != nullptr && Equal(key, x->key)) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n}  // namespace leveldb\n\n#endif  // STORAGE_LEVELDB_DB_SKIPLIST_H_\n\n```\n","source":"_posts/NiceCode/SkipList.md","raw":"---\ntitle: SkipList in LevelDB\ndate: 2020-11-05 10:33:33\ncategories: nicecode\ntags:\n\t- data structure\n\t- link list \n---\n\n\n\nLevelDB中有一份非常优雅的SkipList的实现方式，这里拿过来供学习。\n\nSkipList的一些特性：\n\n1. 最底层是0层，该层最长，最高层是大层，该层最短；\n2. 查找的过程总是从左上至右下；\n\n\n\n### 代码\n\n```java\n// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file. See the AUTHORS file for names of contributors.\n\n#ifndef STORAGE_LEVELDB_DB_SKIPLIST_H_\n#define STORAGE_LEVELDB_DB_SKIPLIST_H_\n\n// Thread safety\n// -------------\n//\n// Writes require external synchronization, most likely a mutex.\n// Reads require a guarantee that the SkipList will not be destroyed\n// while the read is in progress.  Apart from that, reads progress\n// without any internal locking or synchronization.\n//\n// Invariants:\n//\n// (1) Allocated nodes are never deleted until the SkipList is\n// destroyed.  This is trivially guaranteed by the code since we\n// never delete any skip list nodes.\n//\n// (2) The contents of a Node except for the next/prev pointers are\n// immutable after the Node has been linked into the SkipList.\n// Only Insert() modifies the list, and it is careful to initialize\n// a node and use release-stores to publish the nodes in one or\n// more lists.\n//\n// ... prev vs. next pointer ordering ...\n\n#include <atomic>\n#include <cassert>\n#include <cstdlib>\n\n#include \"util/arena.h\"\n#include \"util/random.h\"\n\nnamespace leveldb {\n\nclass Arena;\n\ntemplate <typename Key, class Comparator>\nclass SkipList {\n private:\n  struct Node;\n\n public:\n  // Create a new SkipList object that will use \"cmp\" for comparing keys,\n  // and will allocate memory using \"*arena\".  Objects allocated in the arena\n  // must remain allocated for the lifetime of the skiplist object.\n  explicit SkipList(Comparator cmp, Arena* arena);\n\n  SkipList(const SkipList&) = delete;\n  SkipList& operator=(const SkipList&) = delete;\n\n  // Insert key into the list.\n  // REQUIRES: nothing that compares equal to key is currently in the list.\n  void Insert(const Key& key);\n\n  // Returns true iff an entry that compares equal to key is in the list.\n  bool Contains(const Key& key) const;\n\n  // Iteration over the contents of a skip list\n  class Iterator {\n   public:\n    // Initialize an iterator over the specified list.\n    // The returned iterator is not valid.\n    explicit Iterator(const SkipList* list);\n\n    // Returns true iff the iterator is positioned at a valid node.\n    bool Valid() const;\n\n    // Returns the key at the current position.\n    // REQUIRES: Valid()\n    const Key& key() const;\n\n    // Advances to the next position.\n    // REQUIRES: Valid()\n    void Next();\n\n    // Advances to the previous position.\n    // REQUIRES: Valid()\n    void Prev();\n\n    // Advance to the first entry with a key >= target\n    void Seek(const Key& target);\n\n    // Position at the first entry in list.\n    // Final state of iterator is Valid() iff list is not empty.\n    void SeekToFirst();\n\n    // Position at the last entry in list.\n    // Final state of iterator is Valid() iff list is not empty.\n    void SeekToLast();\n\n   private:\n    const SkipList* list_;\n    Node* node_;\n    // Intentionally copyable\n  };\n\n private:\n  enum { kMaxHeight = 12 };\n\n  inline int GetMaxHeight() const {\n    return max_height_.load(std::memory_order_relaxed);\n  }\n\n  Node* NewNode(const Key& key, int height);\n  int RandomHeight();\n  bool Equal(const Key& a, const Key& b) const { return (compare_(a, b) == 0); }\n\n  // Return true if key is greater than the data stored in \"n\"\n  bool KeyIsAfterNode(const Key& key, Node* n) const;\n\n  // Return the earliest node that comes at or after key.\n  // Return nullptr if there is no such node.\n  //\n  // If prev is non-null, fills prev[level] with pointer to previous\n  // node at \"level\" for every level in [0..max_height_-1].\n  Node* FindGreaterOrEqual(const Key& key, Node** prev) const;\n\n  // Return the latest node with a key < key.\n  // Return head_ if there is no such node.\n  Node* FindLessThan(const Key& key) const;\n\n  // Return the last node in the list.\n  // Return head_ if list is empty.\n  Node* FindLast() const;\n\n  // Immutable after construction\n  Comparator const compare_;\n  Arena* const arena_;  // Arena used for allocations of nodes\n\n  Node* const head_;\n\n  // Modified only by Insert().  Read racily by readers, but stale\n  // values are ok.\n  std::atomic<int> max_height_;  // Height of the entire list\n\n  // Read/written only by Insert().\n  Random rnd_;\n};\n\n// Implementation details follow\ntemplate <typename Key, class Comparator>\nstruct SkipList<Key, Comparator>::Node {\n  explicit Node(const Key& k) : key(k) {}\n\n  Key const key;\n\n  // Accessors/mutators for links.  Wrapped in methods so we can\n  // add the appropriate barriers as necessary.\n  Node* Next(int n) {\n    assert(n >= 0);\n    // Use an 'acquire load' so that we observe a fully initialized\n    // version of the returned Node.\n    return next_[n].load(std::memory_order_acquire);\n  }\n  void SetNext(int n, Node* x) {\n    assert(n >= 0);\n    // Use a 'release store' so that anybody who reads through this\n    // pointer observes a fully initialized version of the inserted node.\n    next_[n].store(x, std::memory_order_release);\n  }\n\n  // No-barrier variants that can be safely used in a few locations.\n  Node* NoBarrier_Next(int n) {\n    assert(n >= 0);\n    return next_[n].load(std::memory_order_relaxed);\n  }\n  void NoBarrier_SetNext(int n, Node* x) {\n    assert(n >= 0);\n    next_[n].store(x, std::memory_order_relaxed);\n  }\n\n private:\n  // Array of length equal to the node height.  next_[0] is lowest level link.\n  std::atomic<Node*> next_[1];\n};\n\ntemplate <typename Key, class Comparator>\ntypename SkipList<Key, Comparator>::Node* SkipList<Key, Comparator>::NewNode(\n    const Key& key, int height) {\n  char* const node_memory = arena_->AllocateAligned(\n      sizeof(Node) + sizeof(std::atomic<Node*>) * (height - 1));\n  return new (node_memory) Node(key);\n}\n\ntemplate <typename Key, class Comparator>\ninline SkipList<Key, Comparator>::Iterator::Iterator(const SkipList* list) {\n  list_ = list;\n  node_ = nullptr;\n}\n\ntemplate <typename Key, class Comparator>\ninline bool SkipList<Key, Comparator>::Iterator::Valid() const {\n  return node_ != nullptr;\n}\n\ntemplate <typename Key, class Comparator>\ninline const Key& SkipList<Key, Comparator>::Iterator::key() const {\n  assert(Valid());\n  return node_->key;\n}\n\ntemplate <typename Key, class Comparator>\ninline void SkipList<Key, Comparator>::Iterator::Next() {\n  assert(Valid());\n  node_ = node_->Next(0);\n}\n\ntemplate <typename Key, class Comparator>\ninline void SkipList<Key, Comparator>::Iterator::Prev() {\n  // Instead of using explicit \"prev\" links, we just search for the\n  // last node that falls before key.\n  assert(Valid());\n  node_ = list_->FindLessThan(node_->key);\n  if (node_ == list_->head_) {\n    node_ = nullptr;\n  }\n}\n\ntemplate <typename Key, class Comparator>\ninline void SkipList<Key, Comparator>::Iterator::Seek(const Key& target) {\n  node_ = list_->FindGreaterOrEqual(target, nullptr);\n}\n\ntemplate <typename Key, class Comparator>\ninline void SkipList<Key, Comparator>::Iterator::SeekToFirst() {\n  node_ = list_->head_->Next(0);\n}\n\ntemplate <typename Key, class Comparator>\ninline void SkipList<Key, Comparator>::Iterator::SeekToLast() {\n  node_ = list_->FindLast();\n  if (node_ == list_->head_) {\n    node_ = nullptr;\n  }\n}\n\ntemplate <typename Key, class Comparator>\nint SkipList<Key, Comparator>::RandomHeight() {\n  // Increase height with probability 1 in kBranching\n  static const unsigned int kBranching = 4;\n  int height = 1;\n  // TODO lwl，这里不会使得kMaxHeight超过最大值么\n  while (height < kMaxHeight && ((rnd_.Next() % kBranching) == 0)) {\n    height++;\n  }\n  assert(height > 0);\n  assert(height <= kMaxHeight);\n  return height;\n}\n\ntemplate <typename Key, class Comparator>\nbool SkipList<Key, Comparator>::KeyIsAfterNode(const Key& key, Node* n) const {\n  // null n is considered infinite\n  return (n != nullptr) && (compare_(n->key, key) < 0);\n}\n\ntemplate <typename Key, class Comparator>\ntypename SkipList<Key, Comparator>::Node*\nSkipList<Key, Comparator>::FindGreaterOrEqual(const Key& key,\n                                              Node** prev) const {\n  Node* x = head_;\n  int level = GetMaxHeight() - 1;\n  while (true) {\n    Node* next = x->Next(level);\n    if (KeyIsAfterNode(key, next)) {\n      // Keep searching in this list\n      x = next;\n    } else {\n      if (prev != nullptr) prev[level] = x;\n      if (level == 0) {\n        return next;\n      } else {\n        // Switch to next list\n        level--;\n      }\n    }\n  }\n}\n\ntemplate <typename Key, class Comparator>\ntypename SkipList<Key, Comparator>::Node*\nSkipList<Key, Comparator>::FindLessThan(const Key& key) const {\n  Node* x = head_;\n  int level = GetMaxHeight() - 1;\n  while (true) {\n    assert(x == head_ || compare_(x->key, key) < 0);\n    Node* next = x->Next(level);\n    if (next == nullptr || compare_(next->key, key) >= 0) {\n      if (level == 0) {\n        return x;\n      } else {\n        // Switch to next list\n        level--;\n      }\n    } else {\n      x = next;\n    }\n  }\n}\n\ntemplate <typename Key, class Comparator>\ntypename SkipList<Key, Comparator>::Node* SkipList<Key, Comparator>::FindLast()\n    const {\n  Node* x = head_;\n  int level = GetMaxHeight() - 1;\n  while (true) {\n    Node* next = x->Next(level);\n    if (next == nullptr) {\n      if (level == 0) {\n        return x;\n      } else {\n        // Switch to next list\n        level--;\n      }\n    } else {\n      x = next;\n    }\n  }\n}\n\ntemplate <typename Key, class Comparator>\nSkipList<Key, Comparator>::SkipList(Comparator cmp, Arena* arena)\n    : compare_(cmp),\n      arena_(arena),\n      head_(NewNode(0 /* any key will do */, kMaxHeight)),\n      max_height_(1),\n      rnd_(0xdeadbeef) {\n  for (int i = 0; i < kMaxHeight; i++) {\n    head_->SetNext(i, nullptr);\n  }\n}\n\ntemplate <typename Key, class Comparator>\nvoid SkipList<Key, Comparator>::Insert(const Key& key) {\n  // TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()\n  // here since Insert() is externally synchronized.\n  Node* prev[kMaxHeight];\n  Node* x = FindGreaterOrEqual(key, prev);\n\n  // Our data structure does not allow duplicate insertion\n  assert(x == nullptr || !Equal(key, x->key));\n\n  int height = RandomHeight();\n  if (height > GetMaxHeight()) {\n    for (int i = GetMaxHeight(); i < height; i++) {\n      prev[i] = head_;\n    }\n    // It is ok to mutate max_height_ without any synchronization\n    // with concurrent readers.  A concurrent reader that observes\n    // the new value of max_height_ will see either the old value of\n    // new level pointers from head_ (nullptr), or a new value set in\n    // the loop below.  In the former case the reader will\n    // immediately drop to the next level since nullptr sorts after all\n    // keys.  In the latter case the reader will use the new node.\n    max_height_.store(height, std::memory_order_relaxed);\n  }\n\n  x = NewNode(key, height);\n  for (int i = 0; i < height; i++) {\n    // NoBarrier_SetNext() suffices since we will add a barrier when\n    // we publish a pointer to \"x\" in prev[i].\n    x->NoBarrier_SetNext(i, prev[i]->NoBarrier_Next(i));\n    prev[i]->SetNext(i, x);\n  }\n}\n\ntemplate <typename Key, class Comparator>\nbool SkipList<Key, Comparator>::Contains(const Key& key) const {\n  Node* x = FindGreaterOrEqual(key, nullptr);\n  if (x != nullptr && Equal(key, x->key)) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n}  // namespace leveldb\n\n#endif  // STORAGE_LEVELDB_DB_SKIPLIST_H_\n\n```\n","slug":"NiceCode/SkipList","published":1,"updated":"2020-11-05T02:39:19.827Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh481t2p0000cwti9rr25umz","content":"<p>LevelDB中有一份非常优雅的SkipList的实现方式，这里拿过来供学习。</p>\n<p>SkipList的一些特性：</p>\n<ol>\n<li>最底层是0层，该层最长，最高层是大层，该层最短；</li>\n<li>查找的过程总是从左上至右下；</li>\n</ol>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</span></span><br><span class=\"line\"><span class=\"comment\">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class=\"line\"><span class=\"comment\">// found in the LICENSE file. See the AUTHORS file for names of contributors.</span></span><br><span class=\"line\"></span><br><span class=\"line\">#ifndef STORAGE_LEVELDB_DB_SKIPLIST_H_</span><br><span class=\"line\">#define STORAGE_LEVELDB_DB_SKIPLIST_H_</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Thread safety</span></span><br><span class=\"line\"><span class=\"comment\">// -------------</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Writes require external synchronization, most likely a mutex.</span></span><br><span class=\"line\"><span class=\"comment\">// Reads require a guarantee that the SkipList will not be destroyed</span></span><br><span class=\"line\"><span class=\"comment\">// while the read is in progress.  Apart from that, reads progress</span></span><br><span class=\"line\"><span class=\"comment\">// without any internal locking or synchronization.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Invariants:</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// (1) Allocated nodes are never deleted until the SkipList is</span></span><br><span class=\"line\"><span class=\"comment\">// destroyed.  This is trivially guaranteed by the code since we</span></span><br><span class=\"line\"><span class=\"comment\">// never delete any skip list nodes.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// (2) The contents of a Node except for the next/prev pointers are</span></span><br><span class=\"line\"><span class=\"comment\">// immutable after the Node has been linked into the SkipList.</span></span><br><span class=\"line\"><span class=\"comment\">// Only Insert() modifies the list, and it is careful to initialize</span></span><br><span class=\"line\"><span class=\"comment\">// a node and use release-stores to publish the nodes in one or</span></span><br><span class=\"line\"><span class=\"comment\">// more lists.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// ... prev vs. next pointer ordering ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">#include &lt;atomic&gt;</span><br><span class=\"line\">#include &lt;cassert&gt;</span><br><span class=\"line\">#include &lt;cstdlib&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#include &quot;util/arena.h&quot;</span><br><span class=\"line\">#include &quot;util/random.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace leveldb &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Arena</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">SkipList</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  struct Node;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"comment\">// Create a new SkipList object that will use &quot;cmp&quot; for comparing keys,</span></span><br><span class=\"line\">  <span class=\"comment\">// and will allocate memory using &quot;*arena&quot;.  Objects allocated in the arena</span></span><br><span class=\"line\">  <span class=\"comment\">// must remain allocated for the lifetime of the skiplist object.</span></span><br><span class=\"line\">  <span class=\"function\">explicit <span class=\"title\">SkipList</span><span class=\"params\">(Comparator cmp, Arena* arena)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  SkipList(<span class=\"keyword\">const</span> SkipList&amp;) = delete;</span><br><span class=\"line\">  SkipList&amp; operator=(<span class=\"keyword\">const</span> SkipList&amp;) = delete;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Insert key into the list.</span></span><br><span class=\"line\">  <span class=\"comment\">// REQUIRES: nothing that compares equal to key is currently in the list.</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Insert</span><span class=\"params\">(<span class=\"keyword\">const</span> Key&amp; key)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Returns true iff an entry that compares equal to key is in the list.</span></span><br><span class=\"line\">  <span class=\"function\">bool <span class=\"title\">Contains</span><span class=\"params\">(<span class=\"keyword\">const</span> Key&amp; key)</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Iteration over the contents of a skip list</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Iterator</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// Initialize an iterator over the specified list.</span></span><br><span class=\"line\">    <span class=\"comment\">// The returned iterator is not valid.</span></span><br><span class=\"line\">    <span class=\"function\">explicit <span class=\"title\">Iterator</span><span class=\"params\">(<span class=\"keyword\">const</span> SkipList* list)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Returns true iff the iterator is positioned at a valid node.</span></span><br><span class=\"line\">    <span class=\"function\">bool <span class=\"title\">Valid</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Returns the key at the current position.</span></span><br><span class=\"line\">    <span class=\"comment\">// REQUIRES: Valid()</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> Key&amp; key() <span class=\"keyword\">const</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Advances to the next position.</span></span><br><span class=\"line\">    <span class=\"comment\">// REQUIRES: Valid()</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Next</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Advances to the previous position.</span></span><br><span class=\"line\">    <span class=\"comment\">// REQUIRES: Valid()</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Prev</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Advance to the first entry with a key &gt;= target</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Seek</span><span class=\"params\">(<span class=\"keyword\">const</span> Key&amp; target)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Position at the first entry in list.</span></span><br><span class=\"line\">    <span class=\"comment\">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SeekToFirst</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Position at the last entry in list.</span></span><br><span class=\"line\">    <span class=\"comment\">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SeekToLast</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">const</span> SkipList* list_;</span><br><span class=\"line\">    Node* node_;</span><br><span class=\"line\">    <span class=\"comment\">// Intentionally copyable</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">enum</span> </span>&#123; kMaxHeight = <span class=\"number\">12</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\">inline <span class=\"keyword\">int</span> <span class=\"title\">GetMaxHeight</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max_height_.load(std::memory_order_relaxed);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Node* NewNode(<span class=\"keyword\">const</span> Key&amp; key, <span class=\"keyword\">int</span> height);</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">RandomHeight</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\">bool <span class=\"title\">Equal</span><span class=\"params\">(<span class=\"keyword\">const</span> Key&amp; a, <span class=\"keyword\">const</span> Key&amp; b)</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> (compare_(a, b) == <span class=\"number\">0</span>); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Return true if key is greater than the data stored in &quot;n&quot;</span></span><br><span class=\"line\">  <span class=\"function\">bool <span class=\"title\">KeyIsAfterNode</span><span class=\"params\">(<span class=\"keyword\">const</span> Key&amp; key, Node* n)</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Return the earliest node that comes at or after key.</span></span><br><span class=\"line\">  <span class=\"comment\">// Return nullptr if there is no such node.</span></span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"comment\">// If prev is non-null, fills prev[level] with pointer to previous</span></span><br><span class=\"line\">  <span class=\"comment\">// node at &quot;level&quot; for every level in [0..max_height_-1].</span></span><br><span class=\"line\">  Node* FindGreaterOrEqual(<span class=\"keyword\">const</span> Key&amp; key, Node** prev) <span class=\"keyword\">const</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Return the latest node with a key &lt; key.</span></span><br><span class=\"line\">  <span class=\"comment\">// Return head_ if there is no such node.</span></span><br><span class=\"line\">  Node* FindLessThan(<span class=\"keyword\">const</span> Key&amp; key) <span class=\"keyword\">const</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Return the last node in the list.</span></span><br><span class=\"line\">  <span class=\"comment\">// Return head_ if list is empty.</span></span><br><span class=\"line\">  Node* FindLast() <span class=\"keyword\">const</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Immutable after construction</span></span><br><span class=\"line\">  Comparator <span class=\"keyword\">const</span> compare_;</span><br><span class=\"line\">  Arena* <span class=\"keyword\">const</span> arena_;  <span class=\"comment\">// Arena used for allocations of nodes</span></span><br><span class=\"line\"></span><br><span class=\"line\">  Node* <span class=\"keyword\">const</span> head_;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Modified only by Insert().  Read racily by readers, but stale</span></span><br><span class=\"line\">  <span class=\"comment\">// values are ok.</span></span><br><span class=\"line\">  std::atomic&lt;<span class=\"keyword\">int</span>&gt; max_height_;  <span class=\"comment\">// Height of the entire list</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Read/written only by Insert().</span></span><br><span class=\"line\">  Random rnd_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Implementation details follow</span></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">struct SkipList&lt;Key, Comparator&gt;::Node &#123;</span><br><span class=\"line\">  <span class=\"function\">explicit <span class=\"title\">Node</span><span class=\"params\">(<span class=\"keyword\">const</span> Key&amp; k)</span> : <span class=\"title\">key</span><span class=\"params\">(k)</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Key <span class=\"keyword\">const</span> key;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Accessors/mutators for links.  Wrapped in methods so we can</span></span><br><span class=\"line\">  <span class=\"comment\">// add the appropriate barriers as necessary.</span></span><br><span class=\"line\">  Node* Next(<span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(n &gt;= <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// Use an &#x27;acquire load&#x27; so that we observe a fully initialized</span></span><br><span class=\"line\">    <span class=\"comment\">// version of the returned Node.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> next_[n].load(std::memory_order_acquire);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SetNext</span><span class=\"params\">(<span class=\"keyword\">int</span> n, Node* x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(n &gt;= <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// Use a &#x27;release store&#x27; so that anybody who reads through this</span></span><br><span class=\"line\">    <span class=\"comment\">// pointer observes a fully initialized version of the inserted node.</span></span><br><span class=\"line\">    next_[n].store(x, std::memory_order_release);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// No-barrier variants that can be safely used in a few locations.</span></span><br><span class=\"line\">  Node* NoBarrier_Next(<span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(n &gt;= <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next_[n].load(std::memory_order_relaxed);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">NoBarrier_SetNext</span><span class=\"params\">(<span class=\"keyword\">int</span> n, Node* x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(n &gt;= <span class=\"number\">0</span>);</span><br><span class=\"line\">    next_[n].store(x, std::memory_order_relaxed);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"comment\">// Array of length equal to the node height.  next_[0] is lowest level link.</span></span><br><span class=\"line\">  std::atomic&lt;Node*&gt; next_[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">typename SkipList&lt;Key, Comparator&gt;::Node* SkipList&lt;Key, Comparator&gt;::NewNode(</span><br><span class=\"line\">    <span class=\"keyword\">const</span> Key&amp; key, <span class=\"keyword\">int</span> height) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> node_memory = arena_-&gt;AllocateAligned(</span><br><span class=\"line\">      sizeof(Node) + sizeof(std::atomic&lt;Node*&gt;) * (height - <span class=\"number\">1</span>));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> (node_memory) Node(key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">inline SkipList&lt;Key, Comparator&gt;::Iterator::Iterator(const SkipList* list) &#123;</span><br><span class=\"line\">  list_ = list;</span><br><span class=\"line\">  node_ = nullptr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">inline bool SkipList&lt;Key, Comparator&gt;::Iterator::Valid() const &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> node_ != nullptr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">inline const Key&amp; SkipList&lt;Key, Comparator&gt;::Iterator::key() const &#123;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(Valid());</span><br><span class=\"line\">  <span class=\"keyword\">return</span> node_-&gt;key;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">inline void SkipList&lt;Key, Comparator&gt;::Iterator::Next() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(Valid());</span><br><span class=\"line\">  node_ = node_-&gt;Next(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">inline void SkipList&lt;Key, Comparator&gt;::Iterator::Prev() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Instead of using explicit &quot;prev&quot; links, we just search for the</span></span><br><span class=\"line\">  <span class=\"comment\">// last node that falls before key.</span></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(Valid());</span><br><span class=\"line\">  node_ = list_-&gt;FindLessThan(node_-&gt;key);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node_ == list_-&gt;head_) &#123;</span><br><span class=\"line\">    node_ = nullptr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">inline void SkipList&lt;Key, Comparator&gt;::Iterator::Seek(const Key&amp; target) &#123;</span><br><span class=\"line\">  node_ = list_-&gt;FindGreaterOrEqual(target, nullptr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">inline void SkipList&lt;Key, Comparator&gt;::Iterator::SeekToFirst() &#123;</span><br><span class=\"line\">  node_ = list_-&gt;head_-&gt;Next(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">inline void SkipList&lt;Key, Comparator&gt;::Iterator::SeekToLast() &#123;</span><br><span class=\"line\">  node_ = list_-&gt;FindLast();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node_ == list_-&gt;head_) &#123;</span><br><span class=\"line\">    node_ = nullptr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">int SkipList&lt;Key, Comparator&gt;::RandomHeight() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Increase height with probability 1 in kBranching</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> unsigned <span class=\"keyword\">int</span> kBranching = <span class=\"number\">4</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> height = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">// TODO lwl，这里不会使得kMaxHeight超过最大值么</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (height &lt; kMaxHeight &amp;&amp; ((rnd_.Next() % kBranching) == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">    height++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(height &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(height &lt;= kMaxHeight);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> height;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">bool SkipList&lt;Key, Comparator&gt;::KeyIsAfterNode(const Key&amp; key, Node* n) const &#123;</span><br><span class=\"line\">  <span class=\"comment\">// null n is considered infinite</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (n != nullptr) &amp;&amp; (compare_(n-&gt;key, key) &lt; <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">typename SkipList&lt;Key, Comparator&gt;::Node*</span><br><span class=\"line\">SkipList&lt;Key, Comparator&gt;::FindGreaterOrEqual(<span class=\"keyword\">const</span> Key&amp; key,</span><br><span class=\"line\">                                              Node** prev) <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  Node* x = head_;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> level = GetMaxHeight() - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">    Node* next = x-&gt;Next(level);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (KeyIsAfterNode(key, next)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Keep searching in this list</span></span><br><span class=\"line\">      x = next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (prev != nullptr) prev[level] = x;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (level == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Switch to next list</span></span><br><span class=\"line\">        level--;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">typename SkipList&lt;Key, Comparator&gt;::Node*</span><br><span class=\"line\">SkipList&lt;Key, Comparator&gt;::FindLessThan(<span class=\"keyword\">const</span> Key&amp; key) <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  Node* x = head_;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> level = GetMaxHeight() - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(x == head_ || compare_(x-&gt;key, key) &lt; <span class=\"number\">0</span>);</span><br><span class=\"line\">    Node* next = x-&gt;Next(level);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next == nullptr || compare_(next-&gt;key, key) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (level == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Switch to next list</span></span><br><span class=\"line\">        level--;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      x = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">typename SkipList&lt;Key, Comparator&gt;::Node* SkipList&lt;Key, Comparator&gt;::FindLast()</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  Node* x = head_;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> level = GetMaxHeight() - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">    Node* next = x-&gt;Next(level);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next == nullptr) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (level == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Switch to next list</span></span><br><span class=\"line\">        level--;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      x = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">SkipList&lt;Key, Comparator&gt;::SkipList(Comparator cmp, Arena* arena)</span><br><span class=\"line\">    : compare_(cmp),</span><br><span class=\"line\">      arena_(arena),</span><br><span class=\"line\">      head_(NewNode(<span class=\"number\">0</span> <span class=\"comment\">/* any key will do */</span>, kMaxHeight)),</span><br><span class=\"line\">      max_height_(<span class=\"number\">1</span>),</span><br><span class=\"line\">      rnd_(<span class=\"number\">0xdeadbeef</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; kMaxHeight; i++) &#123;</span><br><span class=\"line\">    head_-&gt;SetNext(i, nullptr);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">void SkipList&lt;Key, Comparator&gt;::Insert(const Key&amp; key) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()</span></span><br><span class=\"line\">  <span class=\"comment\">// here since Insert() is externally synchronized.</span></span><br><span class=\"line\">  Node* prev[kMaxHeight];</span><br><span class=\"line\">  Node* x = FindGreaterOrEqual(key, prev);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Our data structure does not allow duplicate insertion</span></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(x == nullptr || !Equal(key, x-&gt;key));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> height = RandomHeight();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (height &gt; GetMaxHeight()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = GetMaxHeight(); i &lt; height; i++) &#123;</span><br><span class=\"line\">      prev[i] = head_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// It is ok to mutate max_height_ without any synchronization</span></span><br><span class=\"line\">    <span class=\"comment\">// with concurrent readers.  A concurrent reader that observes</span></span><br><span class=\"line\">    <span class=\"comment\">// the new value of max_height_ will see either the old value of</span></span><br><span class=\"line\">    <span class=\"comment\">// new level pointers from head_ (nullptr), or a new value set in</span></span><br><span class=\"line\">    <span class=\"comment\">// the loop below.  In the former case the reader will</span></span><br><span class=\"line\">    <span class=\"comment\">// immediately drop to the next level since nullptr sorts after all</span></span><br><span class=\"line\">    <span class=\"comment\">// keys.  In the latter case the reader will use the new node.</span></span><br><span class=\"line\">    max_height_.store(height, std::memory_order_relaxed);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  x = NewNode(key, height);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; height; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// NoBarrier_SetNext() suffices since we will add a barrier when</span></span><br><span class=\"line\">    <span class=\"comment\">// we publish a pointer to &quot;x&quot; in prev[i].</span></span><br><span class=\"line\">    x-&gt;NoBarrier_SetNext(i, prev[i]-&gt;NoBarrier_Next(i));</span><br><span class=\"line\">    prev[i]-&gt;SetNext(i, x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">bool SkipList&lt;Key, Comparator&gt;::Contains(const Key&amp; key) const &#123;</span><br><span class=\"line\">  Node* x = FindGreaterOrEqual(key, nullptr);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x != nullptr &amp;&amp; Equal(key, x-&gt;key)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  <span class=\"comment\">// namespace leveldb</span></span><br><span class=\"line\"></span><br><span class=\"line\">#endif  // STORAGE_LEVELDB_DB_SKIPLIST_H_</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>LevelDB中有一份非常优雅的SkipList的实现方式，这里拿过来供学习。</p>\n<p>SkipList的一些特性：</p>\n<ol>\n<li>最底层是0层，该层最长，最高层是大层，该层最短；</li>\n<li>查找的过程总是从左上至右下；</li>\n</ol>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</span></span><br><span class=\"line\"><span class=\"comment\">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class=\"line\"><span class=\"comment\">// found in the LICENSE file. See the AUTHORS file for names of contributors.</span></span><br><span class=\"line\"></span><br><span class=\"line\">#ifndef STORAGE_LEVELDB_DB_SKIPLIST_H_</span><br><span class=\"line\">#define STORAGE_LEVELDB_DB_SKIPLIST_H_</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Thread safety</span></span><br><span class=\"line\"><span class=\"comment\">// -------------</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Writes require external synchronization, most likely a mutex.</span></span><br><span class=\"line\"><span class=\"comment\">// Reads require a guarantee that the SkipList will not be destroyed</span></span><br><span class=\"line\"><span class=\"comment\">// while the read is in progress.  Apart from that, reads progress</span></span><br><span class=\"line\"><span class=\"comment\">// without any internal locking or synchronization.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Invariants:</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// (1) Allocated nodes are never deleted until the SkipList is</span></span><br><span class=\"line\"><span class=\"comment\">// destroyed.  This is trivially guaranteed by the code since we</span></span><br><span class=\"line\"><span class=\"comment\">// never delete any skip list nodes.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// (2) The contents of a Node except for the next/prev pointers are</span></span><br><span class=\"line\"><span class=\"comment\">// immutable after the Node has been linked into the SkipList.</span></span><br><span class=\"line\"><span class=\"comment\">// Only Insert() modifies the list, and it is careful to initialize</span></span><br><span class=\"line\"><span class=\"comment\">// a node and use release-stores to publish the nodes in one or</span></span><br><span class=\"line\"><span class=\"comment\">// more lists.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// ... prev vs. next pointer ordering ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">#include &lt;atomic&gt;</span><br><span class=\"line\">#include &lt;cassert&gt;</span><br><span class=\"line\">#include &lt;cstdlib&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#include &quot;util/arena.h&quot;</span><br><span class=\"line\">#include &quot;util/random.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">namespace leveldb &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Arena</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">SkipList</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  struct Node;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"comment\">// Create a new SkipList object that will use &quot;cmp&quot; for comparing keys,</span></span><br><span class=\"line\">  <span class=\"comment\">// and will allocate memory using &quot;*arena&quot;.  Objects allocated in the arena</span></span><br><span class=\"line\">  <span class=\"comment\">// must remain allocated for the lifetime of the skiplist object.</span></span><br><span class=\"line\">  <span class=\"function\">explicit <span class=\"title\">SkipList</span><span class=\"params\">(Comparator cmp, Arena* arena)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  SkipList(<span class=\"keyword\">const</span> SkipList&amp;) = delete;</span><br><span class=\"line\">  SkipList&amp; operator=(<span class=\"keyword\">const</span> SkipList&amp;) = delete;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Insert key into the list.</span></span><br><span class=\"line\">  <span class=\"comment\">// REQUIRES: nothing that compares equal to key is currently in the list.</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Insert</span><span class=\"params\">(<span class=\"keyword\">const</span> Key&amp; key)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Returns true iff an entry that compares equal to key is in the list.</span></span><br><span class=\"line\">  <span class=\"function\">bool <span class=\"title\">Contains</span><span class=\"params\">(<span class=\"keyword\">const</span> Key&amp; key)</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Iteration over the contents of a skip list</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Iterator</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// Initialize an iterator over the specified list.</span></span><br><span class=\"line\">    <span class=\"comment\">// The returned iterator is not valid.</span></span><br><span class=\"line\">    <span class=\"function\">explicit <span class=\"title\">Iterator</span><span class=\"params\">(<span class=\"keyword\">const</span> SkipList* list)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Returns true iff the iterator is positioned at a valid node.</span></span><br><span class=\"line\">    <span class=\"function\">bool <span class=\"title\">Valid</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Returns the key at the current position.</span></span><br><span class=\"line\">    <span class=\"comment\">// REQUIRES: Valid()</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> Key&amp; key() <span class=\"keyword\">const</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Advances to the next position.</span></span><br><span class=\"line\">    <span class=\"comment\">// REQUIRES: Valid()</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Next</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Advances to the previous position.</span></span><br><span class=\"line\">    <span class=\"comment\">// REQUIRES: Valid()</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Prev</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Advance to the first entry with a key &gt;= target</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Seek</span><span class=\"params\">(<span class=\"keyword\">const</span> Key&amp; target)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Position at the first entry in list.</span></span><br><span class=\"line\">    <span class=\"comment\">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SeekToFirst</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Position at the last entry in list.</span></span><br><span class=\"line\">    <span class=\"comment\">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SeekToLast</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">const</span> SkipList* list_;</span><br><span class=\"line\">    Node* node_;</span><br><span class=\"line\">    <span class=\"comment\">// Intentionally copyable</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">enum</span> </span>&#123; kMaxHeight = <span class=\"number\">12</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\">inline <span class=\"keyword\">int</span> <span class=\"title\">GetMaxHeight</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max_height_.load(std::memory_order_relaxed);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Node* NewNode(<span class=\"keyword\">const</span> Key&amp; key, <span class=\"keyword\">int</span> height);</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">RandomHeight</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\">bool <span class=\"title\">Equal</span><span class=\"params\">(<span class=\"keyword\">const</span> Key&amp; a, <span class=\"keyword\">const</span> Key&amp; b)</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> (compare_(a, b) == <span class=\"number\">0</span>); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Return true if key is greater than the data stored in &quot;n&quot;</span></span><br><span class=\"line\">  <span class=\"function\">bool <span class=\"title\">KeyIsAfterNode</span><span class=\"params\">(<span class=\"keyword\">const</span> Key&amp; key, Node* n)</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Return the earliest node that comes at or after key.</span></span><br><span class=\"line\">  <span class=\"comment\">// Return nullptr if there is no such node.</span></span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"comment\">// If prev is non-null, fills prev[level] with pointer to previous</span></span><br><span class=\"line\">  <span class=\"comment\">// node at &quot;level&quot; for every level in [0..max_height_-1].</span></span><br><span class=\"line\">  Node* FindGreaterOrEqual(<span class=\"keyword\">const</span> Key&amp; key, Node** prev) <span class=\"keyword\">const</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Return the latest node with a key &lt; key.</span></span><br><span class=\"line\">  <span class=\"comment\">// Return head_ if there is no such node.</span></span><br><span class=\"line\">  Node* FindLessThan(<span class=\"keyword\">const</span> Key&amp; key) <span class=\"keyword\">const</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Return the last node in the list.</span></span><br><span class=\"line\">  <span class=\"comment\">// Return head_ if list is empty.</span></span><br><span class=\"line\">  Node* FindLast() <span class=\"keyword\">const</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Immutable after construction</span></span><br><span class=\"line\">  Comparator <span class=\"keyword\">const</span> compare_;</span><br><span class=\"line\">  Arena* <span class=\"keyword\">const</span> arena_;  <span class=\"comment\">// Arena used for allocations of nodes</span></span><br><span class=\"line\"></span><br><span class=\"line\">  Node* <span class=\"keyword\">const</span> head_;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Modified only by Insert().  Read racily by readers, but stale</span></span><br><span class=\"line\">  <span class=\"comment\">// values are ok.</span></span><br><span class=\"line\">  std::atomic&lt;<span class=\"keyword\">int</span>&gt; max_height_;  <span class=\"comment\">// Height of the entire list</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Read/written only by Insert().</span></span><br><span class=\"line\">  Random rnd_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Implementation details follow</span></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">struct SkipList&lt;Key, Comparator&gt;::Node &#123;</span><br><span class=\"line\">  <span class=\"function\">explicit <span class=\"title\">Node</span><span class=\"params\">(<span class=\"keyword\">const</span> Key&amp; k)</span> : <span class=\"title\">key</span><span class=\"params\">(k)</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Key <span class=\"keyword\">const</span> key;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Accessors/mutators for links.  Wrapped in methods so we can</span></span><br><span class=\"line\">  <span class=\"comment\">// add the appropriate barriers as necessary.</span></span><br><span class=\"line\">  Node* Next(<span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(n &gt;= <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// Use an &#x27;acquire load&#x27; so that we observe a fully initialized</span></span><br><span class=\"line\">    <span class=\"comment\">// version of the returned Node.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> next_[n].load(std::memory_order_acquire);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SetNext</span><span class=\"params\">(<span class=\"keyword\">int</span> n, Node* x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(n &gt;= <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// Use a &#x27;release store&#x27; so that anybody who reads through this</span></span><br><span class=\"line\">    <span class=\"comment\">// pointer observes a fully initialized version of the inserted node.</span></span><br><span class=\"line\">    next_[n].store(x, std::memory_order_release);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// No-barrier variants that can be safely used in a few locations.</span></span><br><span class=\"line\">  Node* NoBarrier_Next(<span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(n &gt;= <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next_[n].load(std::memory_order_relaxed);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">NoBarrier_SetNext</span><span class=\"params\">(<span class=\"keyword\">int</span> n, Node* x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(n &gt;= <span class=\"number\">0</span>);</span><br><span class=\"line\">    next_[n].store(x, std::memory_order_relaxed);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"comment\">// Array of length equal to the node height.  next_[0] is lowest level link.</span></span><br><span class=\"line\">  std::atomic&lt;Node*&gt; next_[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">typename SkipList&lt;Key, Comparator&gt;::Node* SkipList&lt;Key, Comparator&gt;::NewNode(</span><br><span class=\"line\">    <span class=\"keyword\">const</span> Key&amp; key, <span class=\"keyword\">int</span> height) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> node_memory = arena_-&gt;AllocateAligned(</span><br><span class=\"line\">      sizeof(Node) + sizeof(std::atomic&lt;Node*&gt;) * (height - <span class=\"number\">1</span>));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> (node_memory) Node(key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">inline SkipList&lt;Key, Comparator&gt;::Iterator::Iterator(const SkipList* list) &#123;</span><br><span class=\"line\">  list_ = list;</span><br><span class=\"line\">  node_ = nullptr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">inline bool SkipList&lt;Key, Comparator&gt;::Iterator::Valid() const &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> node_ != nullptr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">inline const Key&amp; SkipList&lt;Key, Comparator&gt;::Iterator::key() const &#123;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(Valid());</span><br><span class=\"line\">  <span class=\"keyword\">return</span> node_-&gt;key;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">inline void SkipList&lt;Key, Comparator&gt;::Iterator::Next() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(Valid());</span><br><span class=\"line\">  node_ = node_-&gt;Next(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">inline void SkipList&lt;Key, Comparator&gt;::Iterator::Prev() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Instead of using explicit &quot;prev&quot; links, we just search for the</span></span><br><span class=\"line\">  <span class=\"comment\">// last node that falls before key.</span></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(Valid());</span><br><span class=\"line\">  node_ = list_-&gt;FindLessThan(node_-&gt;key);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node_ == list_-&gt;head_) &#123;</span><br><span class=\"line\">    node_ = nullptr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">inline void SkipList&lt;Key, Comparator&gt;::Iterator::Seek(const Key&amp; target) &#123;</span><br><span class=\"line\">  node_ = list_-&gt;FindGreaterOrEqual(target, nullptr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">inline void SkipList&lt;Key, Comparator&gt;::Iterator::SeekToFirst() &#123;</span><br><span class=\"line\">  node_ = list_-&gt;head_-&gt;Next(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">inline void SkipList&lt;Key, Comparator&gt;::Iterator::SeekToLast() &#123;</span><br><span class=\"line\">  node_ = list_-&gt;FindLast();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node_ == list_-&gt;head_) &#123;</span><br><span class=\"line\">    node_ = nullptr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">int SkipList&lt;Key, Comparator&gt;::RandomHeight() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Increase height with probability 1 in kBranching</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> unsigned <span class=\"keyword\">int</span> kBranching = <span class=\"number\">4</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> height = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">// TODO lwl，这里不会使得kMaxHeight超过最大值么</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (height &lt; kMaxHeight &amp;&amp; ((rnd_.Next() % kBranching) == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">    height++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(height &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(height &lt;= kMaxHeight);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> height;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">bool SkipList&lt;Key, Comparator&gt;::KeyIsAfterNode(const Key&amp; key, Node* n) const &#123;</span><br><span class=\"line\">  <span class=\"comment\">// null n is considered infinite</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (n != nullptr) &amp;&amp; (compare_(n-&gt;key, key) &lt; <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">typename SkipList&lt;Key, Comparator&gt;::Node*</span><br><span class=\"line\">SkipList&lt;Key, Comparator&gt;::FindGreaterOrEqual(<span class=\"keyword\">const</span> Key&amp; key,</span><br><span class=\"line\">                                              Node** prev) <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  Node* x = head_;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> level = GetMaxHeight() - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">    Node* next = x-&gt;Next(level);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (KeyIsAfterNode(key, next)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Keep searching in this list</span></span><br><span class=\"line\">      x = next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (prev != nullptr) prev[level] = x;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (level == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Switch to next list</span></span><br><span class=\"line\">        level--;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">typename SkipList&lt;Key, Comparator&gt;::Node*</span><br><span class=\"line\">SkipList&lt;Key, Comparator&gt;::FindLessThan(<span class=\"keyword\">const</span> Key&amp; key) <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  Node* x = head_;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> level = GetMaxHeight() - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(x == head_ || compare_(x-&gt;key, key) &lt; <span class=\"number\">0</span>);</span><br><span class=\"line\">    Node* next = x-&gt;Next(level);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next == nullptr || compare_(next-&gt;key, key) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (level == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Switch to next list</span></span><br><span class=\"line\">        level--;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      x = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">typename SkipList&lt;Key, Comparator&gt;::Node* SkipList&lt;Key, Comparator&gt;::FindLast()</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  Node* x = head_;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> level = GetMaxHeight() - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">    Node* next = x-&gt;Next(level);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next == nullptr) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (level == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Switch to next list</span></span><br><span class=\"line\">        level--;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      x = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">SkipList&lt;Key, Comparator&gt;::SkipList(Comparator cmp, Arena* arena)</span><br><span class=\"line\">    : compare_(cmp),</span><br><span class=\"line\">      arena_(arena),</span><br><span class=\"line\">      head_(NewNode(<span class=\"number\">0</span> <span class=\"comment\">/* any key will do */</span>, kMaxHeight)),</span><br><span class=\"line\">      max_height_(<span class=\"number\">1</span>),</span><br><span class=\"line\">      rnd_(<span class=\"number\">0xdeadbeef</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; kMaxHeight; i++) &#123;</span><br><span class=\"line\">    head_-&gt;SetNext(i, nullptr);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">void SkipList&lt;Key, Comparator&gt;::Insert(const Key&amp; key) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()</span></span><br><span class=\"line\">  <span class=\"comment\">// here since Insert() is externally synchronized.</span></span><br><span class=\"line\">  Node* prev[kMaxHeight];</span><br><span class=\"line\">  Node* x = FindGreaterOrEqual(key, prev);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Our data structure does not allow duplicate insertion</span></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(x == nullptr || !Equal(key, x-&gt;key));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> height = RandomHeight();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (height &gt; GetMaxHeight()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = GetMaxHeight(); i &lt; height; i++) &#123;</span><br><span class=\"line\">      prev[i] = head_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// It is ok to mutate max_height_ without any synchronization</span></span><br><span class=\"line\">    <span class=\"comment\">// with concurrent readers.  A concurrent reader that observes</span></span><br><span class=\"line\">    <span class=\"comment\">// the new value of max_height_ will see either the old value of</span></span><br><span class=\"line\">    <span class=\"comment\">// new level pointers from head_ (nullptr), or a new value set in</span></span><br><span class=\"line\">    <span class=\"comment\">// the loop below.  In the former case the reader will</span></span><br><span class=\"line\">    <span class=\"comment\">// immediately drop to the next level since nullptr sorts after all</span></span><br><span class=\"line\">    <span class=\"comment\">// keys.  In the latter case the reader will use the new node.</span></span><br><span class=\"line\">    max_height_.store(height, std::memory_order_relaxed);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  x = NewNode(key, height);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; height; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// NoBarrier_SetNext() suffices since we will add a barrier when</span></span><br><span class=\"line\">    <span class=\"comment\">// we publish a pointer to &quot;x&quot; in prev[i].</span></span><br><span class=\"line\">    x-&gt;NoBarrier_SetNext(i, prev[i]-&gt;NoBarrier_Next(i));</span><br><span class=\"line\">    prev[i]-&gt;SetNext(i, x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Key, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Comparator</span>&gt;</span></span><br><span class=\"line\">bool SkipList&lt;Key, Comparator&gt;::Contains(const Key&amp; key) const &#123;</span><br><span class=\"line\">  Node* x = FindGreaterOrEqual(key, nullptr);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x != nullptr &amp;&amp; Equal(key, x-&gt;key)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  <span class=\"comment\">// namespace leveldb</span></span><br><span class=\"line\"></span><br><span class=\"line\">#endif  // STORAGE_LEVELDB_DB_SKIPLIST_H_</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"title":"Leetcode 925. Long Pressed Name","date":"2020-11-05T15:34:25.000Z","_content":"\n\n## 题目描述\n\n[英文题目](https://leetcode.com/problems/long-pressed-name/)\n\n[中文题目](https://leetcode-cn.com/problems/long-pressed-name/)\n\n难度：简单\n\n**代码如下：**\n\n```java\nclass Solution {\n    public boolean isLongPressedName(String name, String typed) {\n        if (null == name || null == typed) return false;\n        int lenN = name.length();\n        int lenT = typed.length();\n        int n = 0, t = 0;\n        \n        while (n < lenN && t < lenT) {\n            char cn = name.charAt(n);\n            char ct = typed.charAt(t);\n            if (cn == ct) {\n                n++;\n                t++;\n                continue;\n            }\n            if (t == 0) return false;\n            char pre = typed.charAt(t - 1);\n            if (pre == ct) {\n                while (pre == ct) {\n                    t++;\n                    if (t >= lenT) break;\n                    ct = typed.charAt(t);\n                }\n            } else {\n                return false;\n            }\n        }\n        if (n != lenN) return false;\n        while (t < lenT) {\n            char ct = typed.charAt(t);\n            if (ct != name.charAt(n - 1)) {\n                return false;\n            }\n            t++;\n        }\n        return true;\n    }\n}\n```\n\n\n\n","source":"_posts/Leetcode/925.md","raw":"---\ntitle: Leetcode 925. Long Pressed Name\ndate: 2020-11-05 23:34:25\ncategories: leetcode\ntags:\n\t- two pointer\n\t- algorithm \n---\n\n\n## 题目描述\n\n[英文题目](https://leetcode.com/problems/long-pressed-name/)\n\n[中文题目](https://leetcode-cn.com/problems/long-pressed-name/)\n\n难度：简单\n\n**代码如下：**\n\n```java\nclass Solution {\n    public boolean isLongPressedName(String name, String typed) {\n        if (null == name || null == typed) return false;\n        int lenN = name.length();\n        int lenT = typed.length();\n        int n = 0, t = 0;\n        \n        while (n < lenN && t < lenT) {\n            char cn = name.charAt(n);\n            char ct = typed.charAt(t);\n            if (cn == ct) {\n                n++;\n                t++;\n                continue;\n            }\n            if (t == 0) return false;\n            char pre = typed.charAt(t - 1);\n            if (pre == ct) {\n                while (pre == ct) {\n                    t++;\n                    if (t >= lenT) break;\n                    ct = typed.charAt(t);\n                }\n            } else {\n                return false;\n            }\n        }\n        if (n != lenN) return false;\n        while (t < lenT) {\n            char ct = typed.charAt(t);\n            if (ct != name.charAt(n - 1)) {\n                return false;\n            }\n            t++;\n        }\n        return true;\n    }\n}\n```\n\n\n\n","slug":"Leetcode/925","published":1,"updated":"2020-11-05T15:35:45.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh4ztka50000a0tibwr8foip","content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><a href=\"https://leetcode.com/problems/long-pressed-name/\">英文题目</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/long-pressed-name/\">中文题目</a></p>\n<p>难度：简单</p>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isLongPressedName</span><span class=\"params\">(String name, String typed)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == name || <span class=\"keyword\">null</span> == typed) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lenN = name.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lenT = typed.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>, t = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n &lt; lenN &amp;&amp; t &lt; lenT) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> cn = name.charAt(n);</span><br><span class=\"line\">            <span class=\"keyword\">char</span> ct = typed.charAt(t);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cn == ct) &#123;</span><br><span class=\"line\">                n++;</span><br><span class=\"line\">                t++;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> pre = typed.charAt(t - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pre == ct) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (pre == ct) &#123;</span><br><span class=\"line\">                    t++;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (t &gt;= lenT) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    ct = typed.charAt(t);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n != lenN) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (t &lt; lenT) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> ct = typed.charAt(t);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ct != name.charAt(n - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            t++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><a href=\"https://leetcode.com/problems/long-pressed-name/\">英文题目</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/long-pressed-name/\">中文题目</a></p>\n<p>难度：简单</p>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isLongPressedName</span><span class=\"params\">(String name, String typed)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == name || <span class=\"keyword\">null</span> == typed) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lenN = name.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lenT = typed.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>, t = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n &lt; lenN &amp;&amp; t &lt; lenT) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> cn = name.charAt(n);</span><br><span class=\"line\">            <span class=\"keyword\">char</span> ct = typed.charAt(t);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cn == ct) &#123;</span><br><span class=\"line\">                n++;</span><br><span class=\"line\">                t++;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> pre = typed.charAt(t - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pre == ct) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (pre == ct) &#123;</span><br><span class=\"line\">                    t++;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (t &gt;= lenT) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    ct = typed.charAt(t);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n != lenN) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (t &lt; lenT) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> ct = typed.charAt(t);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ct != name.charAt(n - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            t++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"844. Backspace String Compare","date":"2020-11-08T05:19:32.000Z","_content":"\n\n## 题目描述\n\n[英文题目](https://leetcode.com/problems/backspace-string-compare/)\n\n[中文题目](https://leetcode-cn.com/problems/backspace-string-compare/)\n\n难度：Easy\n\n### 解题思路\n\n#### 方法一\n\n直接模拟删除字符串的方法，即遇到删除键便删除前面的字符，最后判断两个字符串是否相等。这里直接用数据结构stack来模仿删除字符的操作。\n\n```java\nclass Solution {\n    public boolean backspaceCompare(String S, String T) {\n        return getStr(S).equals(getStr(T));\n    }\n    \n    private String getStr(String s) {\n        Stack<Character> stack = new Stack<>();\n        for (char c : s.toCharArray()) {\n            if (c!= '#') {\n                stack.push(c);\n            } else {\n                if (!stack.empty()) {\n                    stack.pop();\n                }\n            }\n        }\n        StringBuilder sb = new StringBuilder(\"\");\n        for (char c: stack) {\n            sb.append(c);\n        }\n        return sb.toString();\n    }\n}\n```\n\n\n\n#### 方法二\n\n从后往前遍历字符串，因为从前遍历的时候，遇到一个字符串，我们并不能确定该字符串是否会被删除，而从后往前遍历的时候，一个字符串是否被删除是可以确定的，因为在遍历的过程中，遇到删除键我们便往前删除一个字符即可。\n\n**代码如下：**\n\n```java\nclass Solution {\n    public boolean backspaceCompare(String S, String T) {\n        int sLen = S.length();\n        int tLen = T.length();\n        int sp = sLen - 1;\n        int tp = tLen - 1;\n        \n        while (true) {\n            int back = 0; // 还需要删除的字符个数\n            while (sp >= 0) {\n                if (S.charAt(sp) == '#') {\n                    sp--;\n                    back++;\n                } else {\n                    if (back > 0) {\n                        sp--;\n                        back--;\n                    } else {\n                        break;\n                    }\n                }\n                \n            }\n            \n            back = 0;\n            while (tp >= 0) {\n                if (T.charAt(tp) == '#') {\n                    tp--;\n                    back++;\n                } else {\n                    if (back > 0) {\n                        tp--;\n                        back--;\n                    } else {\n                        break;\n                    }\n                }\n            }\n            \n            System.out.println(sp + \":\" + tp);\n            \n            if (sp >= 0 && tp >= 0 && S.charAt(sp) == T.charAt(tp)) {\n                sp--;\n                tp--;\n            } else {\n                break;\n            }\n            \n        }\n        return sp < 0 && tp < 0;\n    }\n}\n```\n\n\n\n","source":"_posts/Leetcode/844.md","raw":"---\ntitle: 844. Backspace String Compare\ndate: 2020-11-08 13:19:32\ncategories: leetcode\ntags:\n\t- two pointer\n\t- algorithm \n---\n\n\n## 题目描述\n\n[英文题目](https://leetcode.com/problems/backspace-string-compare/)\n\n[中文题目](https://leetcode-cn.com/problems/backspace-string-compare/)\n\n难度：Easy\n\n### 解题思路\n\n#### 方法一\n\n直接模拟删除字符串的方法，即遇到删除键便删除前面的字符，最后判断两个字符串是否相等。这里直接用数据结构stack来模仿删除字符的操作。\n\n```java\nclass Solution {\n    public boolean backspaceCompare(String S, String T) {\n        return getStr(S).equals(getStr(T));\n    }\n    \n    private String getStr(String s) {\n        Stack<Character> stack = new Stack<>();\n        for (char c : s.toCharArray()) {\n            if (c!= '#') {\n                stack.push(c);\n            } else {\n                if (!stack.empty()) {\n                    stack.pop();\n                }\n            }\n        }\n        StringBuilder sb = new StringBuilder(\"\");\n        for (char c: stack) {\n            sb.append(c);\n        }\n        return sb.toString();\n    }\n}\n```\n\n\n\n#### 方法二\n\n从后往前遍历字符串，因为从前遍历的时候，遇到一个字符串，我们并不能确定该字符串是否会被删除，而从后往前遍历的时候，一个字符串是否被删除是可以确定的，因为在遍历的过程中，遇到删除键我们便往前删除一个字符即可。\n\n**代码如下：**\n\n```java\nclass Solution {\n    public boolean backspaceCompare(String S, String T) {\n        int sLen = S.length();\n        int tLen = T.length();\n        int sp = sLen - 1;\n        int tp = tLen - 1;\n        \n        while (true) {\n            int back = 0; // 还需要删除的字符个数\n            while (sp >= 0) {\n                if (S.charAt(sp) == '#') {\n                    sp--;\n                    back++;\n                } else {\n                    if (back > 0) {\n                        sp--;\n                        back--;\n                    } else {\n                        break;\n                    }\n                }\n                \n            }\n            \n            back = 0;\n            while (tp >= 0) {\n                if (T.charAt(tp) == '#') {\n                    tp--;\n                    back++;\n                } else {\n                    if (back > 0) {\n                        tp--;\n                        back--;\n                    } else {\n                        break;\n                    }\n                }\n            }\n            \n            System.out.println(sp + \":\" + tp);\n            \n            if (sp >= 0 && tp >= 0 && S.charAt(sp) == T.charAt(tp)) {\n                sp--;\n                tp--;\n            } else {\n                break;\n            }\n            \n        }\n        return sp < 0 && tp < 0;\n    }\n}\n```\n\n\n\n","slug":"Leetcode/844","published":1,"updated":"2020-11-08T05:55:29.174Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckh8pdyvd0000pcti3vqgfd3m","content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><a href=\"https://leetcode.com/problems/backspace-string-compare/\">英文题目</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/backspace-string-compare/\">中文题目</a></p>\n<p>难度：Easy</p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>直接模拟删除字符串的方法，即遇到删除键便删除前面的字符，最后判断两个字符串是否相等。这里直接用数据结构stack来模仿删除字符的操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">backspaceCompare</span><span class=\"params\">(String S, String T)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getStr(S).equals(getStr(T));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getStr</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        Stack&lt;Character&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : s.toCharArray()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c!= <span class=\"string\">&#x27;#&#x27;</span>) &#123;</span><br><span class=\"line\">                stack.push(c);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!stack.empty()) &#123;</span><br><span class=\"line\">                    stack.pop();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c: stack) &#123;</span><br><span class=\"line\">            sb.append(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p>从后往前遍历字符串，因为从前遍历的时候，遇到一个字符串，我们并不能确定该字符串是否会被删除，而从后往前遍历的时候，一个字符串是否被删除是可以确定的，因为在遍历的过程中，遇到删除键我们便往前删除一个字符即可。</p>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">backspaceCompare</span><span class=\"params\">(String S, String T)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sLen = S.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tLen = T.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sp = sLen - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tp = tLen - <span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> back = <span class=\"number\">0</span>; <span class=\"comment\">// 还需要删除的字符个数</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (sp &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (S.charAt(sp) == <span class=\"string\">&#x27;#&#x27;</span>) &#123;</span><br><span class=\"line\">                    sp--;</span><br><span class=\"line\">                    back++;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (back &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        sp--;</span><br><span class=\"line\">                        back--;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            back = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (tp &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (T.charAt(tp) == <span class=\"string\">&#x27;#&#x27;</span>) &#123;</span><br><span class=\"line\">                    tp--;</span><br><span class=\"line\">                    back++;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (back &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        tp--;</span><br><span class=\"line\">                        back--;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            System.out.println(sp + <span class=\"string\">&quot;:&quot;</span> + tp);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sp &gt;= <span class=\"number\">0</span> &amp;&amp; tp &gt;= <span class=\"number\">0</span> &amp;&amp; S.charAt(sp) == T.charAt(tp)) &#123;</span><br><span class=\"line\">                sp--;</span><br><span class=\"line\">                tp--;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sp &lt; <span class=\"number\">0</span> &amp;&amp; tp &lt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><a href=\"https://leetcode.com/problems/backspace-string-compare/\">英文题目</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/backspace-string-compare/\">中文题目</a></p>\n<p>难度：Easy</p>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><h4 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h4><p>直接模拟删除字符串的方法，即遇到删除键便删除前面的字符，最后判断两个字符串是否相等。这里直接用数据结构stack来模仿删除字符的操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">backspaceCompare</span><span class=\"params\">(String S, String T)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getStr(S).equals(getStr(T));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getStr</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        Stack&lt;Character&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : s.toCharArray()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c!= <span class=\"string\">&#x27;#&#x27;</span>) &#123;</span><br><span class=\"line\">                stack.push(c);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!stack.empty()) &#123;</span><br><span class=\"line\">                    stack.pop();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c: stack) &#123;</span><br><span class=\"line\">            sb.append(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h4><p>从后往前遍历字符串，因为从前遍历的时候，遇到一个字符串，我们并不能确定该字符串是否会被删除，而从后往前遍历的时候，一个字符串是否被删除是可以确定的，因为在遍历的过程中，遇到删除键我们便往前删除一个字符即可。</p>\n<p><strong>代码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">backspaceCompare</span><span class=\"params\">(String S, String T)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sLen = S.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tLen = T.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sp = sLen - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tp = tLen - <span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> back = <span class=\"number\">0</span>; <span class=\"comment\">// 还需要删除的字符个数</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (sp &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (S.charAt(sp) == <span class=\"string\">&#x27;#&#x27;</span>) &#123;</span><br><span class=\"line\">                    sp--;</span><br><span class=\"line\">                    back++;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (back &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        sp--;</span><br><span class=\"line\">                        back--;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            back = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (tp &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (T.charAt(tp) == <span class=\"string\">&#x27;#&#x27;</span>) &#123;</span><br><span class=\"line\">                    tp--;</span><br><span class=\"line\">                    back++;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (back &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        tp--;</span><br><span class=\"line\">                        back--;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            System.out.println(sp + <span class=\"string\">&quot;:&quot;</span> + tp);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sp &gt;= <span class=\"number\">0</span> &amp;&amp; tp &gt;= <span class=\"number\">0</span> &amp;&amp; S.charAt(sp) == T.charAt(tp)) &#123;</span><br><span class=\"line\">                sp--;</span><br><span class=\"line\">                tp--;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sp &lt; <span class=\"number\">0</span> &amp;&amp; tp &lt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n"}],"PostAsset":[{"_id":"source/_posts/Config/hexo_google_site/add_sitemap.png","slug":"add_sitemap.png","post":"ckh1zfgyt00087kti62yx09td","modified":0,"renderable":0},{"_id":"source/_posts/Config/hexo_google_site/could_not_fetch.jpg","slug":"could_not_fetch.jpg","post":"ckh1zfgyt00087kti62yx09td","modified":0,"renderable":0},{"_id":"source/_posts/Config/hexo_google_site/first.png","slug":"first.png","post":"ckh1zfgyt00087kti62yx09td","modified":0,"renderable":0},{"_id":"source/_posts/Leetcode/142/zhengming.png","slug":"zhengming.png","post":"ckh1zfgyy000g7kti5rnahsa8","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ckh1zfgyt00087kti62yx09td","category_id":"ckh1zfgyr00047ktib4wg5nun","_id":"ckh1zfgyy000e7kti4hjd0tyq"},{"post_id":"ckh1zfgyn00017ktidhf8e0sd","category_id":"ckh1zfgyr00047ktib4wg5nun","_id":"ckh1zfgyz000h7kti23vj3x79"},{"post_id":"ckh1zfgyp00037kti191cdodb","category_id":"ckh1zfgyr00047ktib4wg5nun","_id":"ckh1zfgz0000l7kti6mubfjyv"},{"post_id":"ckh1zfgz0000o7kti5rqj44b9","category_id":"ckh1zfgyz000j7kti10l1cgzf","_id":"ckh1zfgz4000v7kti5np8fbii"},{"post_id":"ckh1zfgyx000d7ktiedfjg7mr","category_id":"ckh1zfgyz000j7kti10l1cgzf","_id":"ckh1zfgz600107kticl1vegwh"},{"post_id":"ckh1zfgz2000p7kti86y014s1","category_id":"ckh1zfgyz000j7kti10l1cgzf","_id":"ckh1zfgz700137ktielxl6ds4"},{"post_id":"ckh1zfgz3000s7kti1821gf1k","category_id":"ckh1zfgyz000j7kti10l1cgzf","_id":"ckh1zfgz800177kti2x7s2x8c"},{"post_id":"ckh1zfgyy000g7kti5rnahsa8","category_id":"ckh1zfgyz000j7kti10l1cgzf","_id":"ckh1zfgz900197kti8jf50lx8"},{"post_id":"ckh1zfgz4000u7kti92awgtad","category_id":"ckh1zfgyz000j7kti10l1cgzf","_id":"ckh1zfgz9001b7ktian2r17yr"},{"post_id":"ckh1zfgyz000k7ktif9vwcn6a","category_id":"ckh1zfgyz000j7kti10l1cgzf","_id":"ckh1zfgz9001d7ktifhy8hllb"},{"post_id":"ckh1zfgz600127kti5z5t1mpc","category_id":"ckh1zfgyz000j7kti10l1cgzf","_id":"ckh1zfgza001g7ktid173g6g7"},{"post_id":"ckh1zfgzh002b7kti3k6x7t1h","category_id":"ckh1zfgzl002d7kti19cp8it3","_id":"ckh1zfgzn002k7kti1xpm5cjx"},{"post_id":"ckh1zfgzi002c7kti1somgq3x","category_id":"ckh1zfgzn002h7ktidrnnd6c5","_id":"ckh1zfgzo002m7ktieb4wg5uf"},{"post_id":"ckh3hprnk0000swti3l8tdf38","category_id":"ckh1zfgyz000j7kti10l1cgzf","_id":"ckh3hprny0003swtihme49ihn"},{"post_id":"ckh481t2p0000cwti9rr25umz","category_id":"ckh47y2n30001tgtibdz80rcj","_id":"ckh481t2t0003cwti6mh0gxnc"},{"post_id":"ckh4ztka50000a0tibwr8foip","category_id":"ckh1zfgyz000j7kti10l1cgzf","_id":"ckh4ztkal0003a0ti5iu71sko"},{"post_id":"ckh8pdyvd0000pcti3vqgfd3m","category_id":"ckh1zfgyz000j7kti10l1cgzf","_id":"ckh8pdyvg0003pcti0zudhznk"}],"PostTag":[{"post_id":"ckh1zfgyn00017ktidhf8e0sd","tag_id":"ckh1zfgys00057kti4p12eken","_id":"ckh1zfgyz000i7kti1vk4c698"},{"post_id":"ckh1zfgyn00017ktidhf8e0sd","tag_id":"ckh1zfgyv000b7ktiain942w7","_id":"ckh1zfgz0000m7kti2mdchchl"},{"post_id":"ckh1zfgyp00037kti191cdodb","tag_id":"ckh1zfgys00057kti4p12eken","_id":"ckh1zfgz4000t7kti8kgl3xfp"},{"post_id":"ckh1zfgyp00037kti191cdodb","tag_id":"ckh1zfgyv000b7ktiain942w7","_id":"ckh1zfgz5000x7kti7bsiharj"},{"post_id":"ckh1zfgyt00087kti62yx09td","tag_id":"ckh1zfgys00057kti4p12eken","_id":"ckh1zfgz600117kti4kkfa7tj"},{"post_id":"ckh1zfgyt00087kti62yx09td","tag_id":"ckh1zfgyv000b7ktiain942w7","_id":"ckh1zfgz700147kti39rw8qvo"},{"post_id":"ckh1zfgyx000d7ktiedfjg7mr","tag_id":"ckh1zfgz5000y7ktias7t8kvl","_id":"ckh1zfgz9001c7ktiapsfdllo"},{"post_id":"ckh1zfgyx000d7ktiedfjg7mr","tag_id":"ckh1zfgz700157kti9ghygyk7","_id":"ckh1zfgz9001e7ktigkw6443p"},{"post_id":"ckh1zfgyy000g7kti5rnahsa8","tag_id":"ckh1zfgz5000y7ktias7t8kvl","_id":"ckh1zfgza001i7ktiasupajnr"},{"post_id":"ckh1zfgyy000g7kti5rnahsa8","tag_id":"ckh1zfgz700157kti9ghygyk7","_id":"ckh1zfgza001j7kti54wcb2tl"},{"post_id":"ckh1zfgyz000k7ktif9vwcn6a","tag_id":"ckh1zfgz5000y7ktias7t8kvl","_id":"ckh1zfgzb001m7kticv8rdisd"},{"post_id":"ckh1zfgyz000k7ktif9vwcn6a","tag_id":"ckh1zfgz700157kti9ghygyk7","_id":"ckh1zfgzb001n7kti5cz51511"},{"post_id":"ckh1zfgz0000o7kti5rqj44b9","tag_id":"ckh1zfgz5000y7ktias7t8kvl","_id":"ckh1zfgzc001r7kti869vc514"},{"post_id":"ckh1zfgz0000o7kti5rqj44b9","tag_id":"ckh1zfgz700157kti9ghygyk7","_id":"ckh1zfgzc001s7kti6gi8bael"},{"post_id":"ckh1zfgz0000o7kti5rqj44b9","tag_id":"ckh1zfgzb001p7kti7dl28ms4","_id":"ckh1zfgzc001u7kti699xgjl8"},{"post_id":"ckh1zfgz2000p7kti86y014s1","tag_id":"ckh1zfgz5000y7ktias7t8kvl","_id":"ckh1zfgzd001w7kti678p6zf6"},{"post_id":"ckh1zfgz2000p7kti86y014s1","tag_id":"ckh1zfgz700157kti9ghygyk7","_id":"ckh1zfgzd001x7ktiei6w2pfi"},{"post_id":"ckh1zfgz3000s7kti1821gf1k","tag_id":"ckh1zfgz5000y7ktias7t8kvl","_id":"ckh1zfgzd00207kti2us7e28k"},{"post_id":"ckh1zfgz3000s7kti1821gf1k","tag_id":"ckh1zfgz700157kti9ghygyk7","_id":"ckh1zfgzd00217kti9gma52k9"},{"post_id":"ckh1zfgz4000u7kti92awgtad","tag_id":"ckh1zfgz5000y7ktias7t8kvl","_id":"ckh1zfgze00247kti03kq770t"},{"post_id":"ckh1zfgz4000u7kti92awgtad","tag_id":"ckh1zfgz700157kti9ghygyk7","_id":"ckh1zfgze00257kti9kwl6fjp"},{"post_id":"ckh1zfgz600127kti5z5t1mpc","tag_id":"ckh1zfgz5000y7ktias7t8kvl","_id":"ckh1zfgzf00277kti1g1d7w3s"},{"post_id":"ckh1zfgz600127kti5z5t1mpc","tag_id":"ckh1zfgz700157kti9ghygyk7","_id":"ckh1zfgzf00287kticsllguyv"},{"post_id":"ckh1zfgz600127kti5z5t1mpc","tag_id":"ckh1zfgze00267kti3jzr2qs4","_id":"ckh1zfgzf00297ktifiep5t00"},{"post_id":"ckh1zfgzh002b7kti3k6x7t1h","tag_id":"ckh1zfgzl002e7kti34rhfvn7","_id":"ckh1zfgzn002j7kti0jopc9yx"},{"post_id":"ckh1zfgzi002c7kti1somgq3x","tag_id":"ckh1zfgzn002i7kti38me19t6","_id":"ckh1zfgzo002n7kti94zq8q5j"},{"post_id":"ckh1zfgzi002c7kti1somgq3x","tag_id":"ckh1zfgzn002l7kti2pzt1298","_id":"ckh1zfgzo002o7kti2a9de6qa"},{"post_id":"ckh3hprnk0000swti3l8tdf38","tag_id":"ckh1zfgz5000y7ktias7t8kvl","_id":"ckh3hprnx0001swti21ar2yrk"},{"post_id":"ckh3hprnk0000swti3l8tdf38","tag_id":"ckh1zfgz700157kti9ghygyk7","_id":"ckh3hprny0002swti5uyhb9oc"},{"post_id":"ckh481t2p0000cwti9rr25umz","tag_id":"ckh47y2n80002tgticn7tazjy","_id":"ckh481t2s0001cwti8b0x5fe7"},{"post_id":"ckh481t2p0000cwti9rr25umz","tag_id":"ckh47y2n90003tgti4pn6ey4j","_id":"ckh481t2t0002cwtidsz1hyji"},{"post_id":"ckh4ztka50000a0tibwr8foip","tag_id":"ckh1zfgz5000y7ktias7t8kvl","_id":"ckh4ztkak0001a0ticfc79g99"},{"post_id":"ckh4ztka50000a0tibwr8foip","tag_id":"ckh1zfgz700157kti9ghygyk7","_id":"ckh4ztkal0002a0tiesqt5szg"},{"post_id":"ckh8pdyvd0000pcti3vqgfd3m","tag_id":"ckh1zfgz5000y7ktias7t8kvl","_id":"ckh8pdyvg0001pcti3wfyf9ac"},{"post_id":"ckh8pdyvd0000pcti3vqgfd3m","tag_id":"ckh1zfgz700157kti9ghygyk7","_id":"ckh8pdyvg0002pctif817ezlr"}],"Tag":[{"name":"安装部署","_id":"ckh1zfgys00057kti4p12eken"},{"name":"配置","_id":"ckh1zfgyv000b7ktiain942w7"},{"name":"two pointer","_id":"ckh1zfgz5000y7ktias7t8kvl"},{"name":"algorithm","_id":"ckh1zfgz700157kti9ghygyk7"},{"name":"greedy","_id":"ckh1zfgzb001p7kti7dl28ms4"},{"name":"dp","_id":"ckh1zfgze00267kti3jzr2qs4"},{"name":"leetcode_summary","_id":"ckh1zfgzl002e7kti34rhfvn7"},{"name":"C++","_id":"ckh1zfgzn002i7kti38me19t6"},{"name":"Memory","_id":"ckh1zfgzn002l7kti2pzt1298"},{"name":"data structure","_id":"ckh47y2n80002tgticn7tazjy"},{"name":"link list","_id":"ckh47y2n90003tgti4pn6ey4j"}]}}