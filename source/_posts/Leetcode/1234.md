---
title: Leetcode 1234. Replace the Substring for Balanced String
date: 2020-10-29 20:46:24
categories: leetcode
tags:
	- two pointer
	- algorithm 
---


## 题目描述

[英文题目](https://leetcode.com/problems/replace-the-substring-for-balanced-string/)

[中文题目](https://leetcode-cn.com/problems/replace-the-substring-for-balanced-string/)

难度：中等

### 题意

说明：题目来自leetcode中文官网

有一个只含有 'Q', 'W', 'E', 'R' 四种字符，且长度为 n 的字符串。

假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。

 

给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。

你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。

请返回待替换子串的最小可能长度。

如果原字符串自身就是一个平衡字符串，则返回 0。

**示例：**

```txt
输入：s = "QWER"
输出：0
解释：s 已经是平衡的了。

------------
输入：s = "QQWE"
输出：1
解释：我们需要把一个 'Q' 替换成 'R'，这样得到的 "RQWE" (或 "QRWE") 是平衡的。


-------------
输入：s = "QQQW"
输出：2
解释：我们可以把前面的 "QQ" 替换成 "ER"。

-------------
输入：s = "QQQQ"
输出：3
解释：我们可以替换后 3 个 'Q'，使 s = "QWER"。
```



### 解题思路

该题目分类属于中等题，且用two pointer进行解决，核心思路见代码：

**代码如下：**

```java
class Solution {
    
    private int e = 0;
    private int w = 1;
    private int q = 2;
    private int r = 3;
    
    public int balancedString(String s) {
        int len = s.length();
        
        if (len == 0 || (len % 4 != 0)) {
            return 0;
        }
        
        int e = 0, w = 0, q = 0, r = 0;
        
        for (int i = 0; i < len; i++) {
            char c = s.charAt(i);
            if (c == 'E') {
                e++;
            } else if (c == 'W') {
                w++;
            } else if (c == 'Q') {
                q++;
            } else if (c == 'R') {
                r++;
            }
        }
        
        // t为target的简写，t是每个字符的目标个数
        int t = len / 4;
        if (e == w && w == r && r == q) return 0;
        
        // 以下四行的n为need的简写，算出其离目标的距离即该字符需要变换的个数
        // 需要注意的是，我们只计算大于目标的字符距离目标的个数，因为变换是相互的
        // 你也可以只计算小于目标的字符距离目标的个数
        int ne = (e <= t) ? 0 : e - t;
        int nw = (w <= t) ? 0 : w - t;
        int nq = (q <= t) ? 0 : q - t;
        int nr = (r <= t) ? 0 : r - t;
    
        
        int ans = len;
        
        int left = 0;
        int right = 0;
        
        // 以下声明中，c为current的简写
        // 下面四个变量代表在left和right指针区间内，各个字符的个数
        int cq = 0, cw = 0, ce = 0, cr = 0;
        
        while (right < len) {
            char c = s.charAt(right);
            if (c == 'Q') {
                cq++;
            } else if (c == 'W') {
                cw ++;
            } else if (c == 'E') {
                ce++;
            } else if (c == 'R') {
                cr++;
            }
            
            // 如果当前的指针范围内各个字符需要变换的个数都满足需求，则我们开始
            // 保存结果并缩小指针区间
            while (cq >= nq && cw >= nw && ce >= ne && cr >= nr) {
                ans = Math.min(ans, right - left + 1);
                char leftC = s.charAt(left);
                if (leftC == 'Q') {
                    cq--;
                } else if (leftC == 'W') {
                    cw--;
                } else if (leftC == 'E') {
                    ce--;
                } else if (leftC == 'R') {
                    cr--;
                }
                left++;
            }
            
            // 否则继续增大指针范围
            right++;
        } 
        
        
        return ans;
    }
    
}
```



