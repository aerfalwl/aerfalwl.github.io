---
title: 763. Partition Labels
date: 2020-10-27 21:36:28
categories: leetcode
tags:
	- two pointer
	- algorithm 
---


## 题目描述

[英文题目](https://leetcode.com/problems/partition-labels/)

[中文题目](https://leetcode-cn.com/problems/partition-labels/)

难度：中等

### 题意

说明：题目来自leetcode中文官网

字符串 `S` 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。

**示例：**

```txt
输入：S = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca", "defegde", "hijhklij"。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。
```



### 解题思路

该题目分类属于中等题，且用two pointer进行解决。

即首先找到每个字母最后出现的位置，之后划分段的时候，确保该段内每个字母出现的最右值的位置在该段内。不太好描述，直接看代码。



**代码如下：**

```java
class Solution {
    public List<Integer> partitionLabels(String S) {
        if(S.length() <= 0) {
            return null;
        }
        
        List<Integer> ans = new ArrayList<>();
        
        char[] s = S.toCharArray();
        int len = s.length;
        
        int[] max = new int[26];
        
        
        for (int i = 0; i < len; i++) {
            int curr = s[i] - 'a';
            if (max[curr] < i) max[curr] = i;
        }
        
        int left = 0, right = 0;
        while (right < len) {
            int maxRight = 0;
            while (right < len) {
                int curr = max[s[right] - 'a'];
                if (maxRight < curr) maxRight = curr;
                if (right == maxRight) {
                    ans.add(right - left + 1);
                    left = right + 1;
                    right++;
                    break;
                }
                right++;
            }
        }
        if (left != right) {
            ans.add(right - left);
        }
        return ans;
    }
}
```









### Two pointer解决套路

Two pointer和滑动窗口差不多，其套路一般为：

1. 一个左指针，一个右指针。其中左指针用于缩小范围，右指针用于扩大搜索范围。一般求滑动窗口的最小值都是在缩小左指针的时候取得的。
2. 右指针扩展的条件时：只要当前还没有满足条件，就暴力增长，直到第一次满足条件为止。
3. 左指针收缩的条件：只要当前指针的缩小还没影响窗口的可满足性，就一直暴力向左增长。一但当前指针向前移动的时候影响了窗口的可满足性，就记录下当前的窗口大小，并更新目前为止满足条件的最小窗口记录。之后，再次扩展右指针，使得窗口满足题目的条件。
4. 以此类推即可。

