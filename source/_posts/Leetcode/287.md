---
title: Leetcode 287. Find the Duplicate Number
date: 2020-11-02 00:17:25
categories: leetcode
tags:
	- two pointer
	- algorithm 
---


## 题目描述

[英文题目](https://leetcode.com/problems/find-the-duplicate-number/)

[中文题目](https://leetcode-cn.com/problems/find-the-duplicate-number/)

难度：中等

### 题意

给定一个包含`n+1`个数字的数组，该数组中所有数字都在范围`[1,n]`内，该数组中有且仅有一个数字出现了两次，求这个数字。

### 解题思路

该数组可以等价为一个链表，数组中的每个元素等价为一个节点，每个节点的值得`nums[i]`，该节点的`next`值为`nums[nums[i]]`，即该节点的值为下一个节点在数组中的索引。这样，原本的数组就转换为了一个链表，对于链表中的每个节点，有

```java
Node n;
n.val = nums[i];
n.next = nums[n.val] // 或者n.next = nums[num[i]]
```

以nums[0]为头节点，就能将这个数组转换为链表啦。当然，你也可以以任意一个节点为头节点，而不仅仅是Nums[0]。

转换为链表之后，链表中必存在环，因为有数字出现了两次，出现了两次意味着它是两个节点的next节点，也就是该数字是环的起点。

**例子一：**

假设现在有数组

```
index: 0 1 2 3 4 
value: 1 3 4 2 2
```

则以nums[0]为头节点，组成的链表为：

```
1->3->2->4
	  |__| 
```

我们发现，2在数组中出现了两次，同时它也是环的起点。

**例子二：**

```
index: 0 1 2 3 4
value: 3 1 3 4 2
```

则以nums[0]为头节点，组成的链表为：

```
3->4->2
|_____|   
```

同样，3出现了两次，它也是环的起点。

#### 如何判断环状链表的起点

[证明](https://aerfalwl.github.io/2020/11/01/Leetcode/142/)



### 代码

```java
class Solution {
    public int findDuplicate(int[] nums) {
        int slow = 0, fast = 0;
        slow = nums[slow];
        fast = nums[nums[fast]];
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[nums[fast]];
        }
        slow = 0;
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return fast;
    }
}
```

### 总结

**找环的起点：**

1. 两个指针：慢指针和快指针，慢指针一次走一步，快指针一次走两步。如果两个指针相遇，就是有环，如果两个指针不相遇，就是没环。
2. 将快指针放回链表起点，慢指针位置不变，两者都以慢速遍历指针，再次相遇的点即为环的起点。

**数组**

1. 数组中的每个元素可以有两层含义
   - 它可以作为一个值(value)
   - 该值也可以是数组的一个索引(index)