---
title: Leetcode 986. Interval List Intersections
date: 2020-11-04 22:17:22
categories: leetcode
tags:
	- two pointer
	- algorithm 
---


## 题目描述

[英文题目](https://leetcode.com/problems/interval-list-intersections/)

[中文题目](https://leetcode-cn.com/problems/interval-list-intersections/)

难度：中等

### 题意

求两组线段集合的交集。

**示例：**

```txt
Input: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]
Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]
```

### 解题思路

该题目分类属于中等题，且用two pointer进行解决。

#### 思路

1. 两个指针，一个指针指向线段集合A，一个指针指向线段集合B；
2. 依次移动两个指针，如果发现当前两个指针之间有交集，则求交集之后放入结果中，否则，视情况移动两个指针；

**代码如下：**

```java
class Solution {
    public int[][] intervalIntersection(int[][] A, int[][] B) {
        
        int lenA = A.length;
        int lenB = B.length;
        
        List<Node> list = new ArrayList<>();
        int currA = 0;
        int currB = 0;
        
        while (currA < lenA && currB < lenB) {
            if (A[currA][1] < B[currB][0]) { // 没交集的情况
                currA++;
                continue;
            }
            if (B[currB][1] < A[currA][0]) { // 没交集的情况
                currB++;
                continue;
            }
            int maxL = Math.max(A[currA][0], B[currB][0]);
            int minR = Math.min(A[currA][1], B[currB][1]);
            list.add(new Node(maxL, minR));
            if (A[currA][1] == minR) currA++;
            if (B[currB][1] == minR) currB++;
        }
        
        int[][] ans = new int[list.size()][2];
        int len = list.size();
        for (int i = 0; i < len; i++) {
            Node tmp = list.get(i);
            ans[i][0] = tmp.l;
            ans[i][1] = tmp.r;
        }
        return ans;
    }
    
    class Node {
        int l;
        int r;
        Node(int l_, int r_) {
            this.l = l_;
            this.r = r_;
        }
    }
}
```

