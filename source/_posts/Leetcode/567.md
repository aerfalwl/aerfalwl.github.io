---
title: Leetcode 567. Permutation in String
date: 2020-11-03 20:27:49
categories: leetcode
tags:
	- two pointer
	- algorithm 
---


## 题目描述

[英文题目](https://leetcode.com/problems/permutation-in-string/)

[中文题目](https://leetcode-cn.com/problems/permutation-in-string/)

难度：中等

### 题意

题目给出两个字符串`s1`和`s2`，返回`s1`的全排列之一是否是`s2`的子集。

**示例：**

```txt
Input: s1 = "ab" s2 = "eidbaooo"
Output: True
Explanation: s2 contains one permutation of s1 ("ba").

------------
Input:s1= "ab" s2 = "eidboaoo"
Output: False
```



### 解题思路

该题目分类属于中等题，且用two pointer进行解决，核心思路：

1. 如果字符串`a`是字符串`b`的subtring，则`b`字符串其中的一段，一定和a的长度相等；
2. a的全排列，就是将a中字符全部打乱，任意排列；且全排列不会更改字符串中字符出现的次数；

因此，在代码中：

	1. 计算`s1`中每个字符出现的个数，保存在数组中；
 	2. 两个指针遍历`s2`，假设两个指针之间形成的字符串为`tmpS`，若`tmpS`中每个字符的个数和`s1`中每个字符出现的个数相等，则返回`true`，遍历结束也没满足条件，返回false；

**代码如下：**

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int len1 = s1.length();
        int len2 = s2.length();
        int[] dp = new int[26];
        for (char s : s1.toCharArray()) {
            dp[s - 'a']++;
        }
        int need = len1;
        int left = 0;
        int right = 0;
        while (right < len2) {
            char c = s2.charAt(right);
            if (dp[c - 'a'] > 0) {
                dp[c - 'a']--;
                need--;
                right++;
            } else if (dp[c - 'a'] <= 0) {
                dp[s2.charAt(left) - 'a']++;
                left++;
                need++;
            }
            if (need == 0) {
                return true;
            }
        }
        return false;
    }
}
```



