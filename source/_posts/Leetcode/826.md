---
title: LeetCode 826. Most Profit Assigning Work
date: 2020-10-28 21:11:12
categories: leetcode
tags:
	- two pointer
	- algorithm 
	- dp
---


## 题目描述

[英文题目](https://leetcode.com/problems/most-profit-assigning-work/)

[中文题目](https://leetcode-cn.com/problems/most-profit-assigning-work/)

难度：中等

### 题意

说明：题目来自leetcode中文官网

有一些工作：`difficulty[i]` 表示第 `i` 个工作的难度，`profit[i]` 表示第 `i` 个工作的收益。

现在我们有一些工人。`worker[i]` 是第 `i` 个工人的能力，即该工人只能完成难度小于等于 `worker[i]` 的工作。

每一个工人都最多只能安排一个工作，但是一个工作可以完成多次。

举个例子，如果 3 个工人都尝试完成一份报酬为 1 的同样工作，那么总收益为 $3。如果一个工人不能完成任何工作，他的收益为 $0 。

我们能得到的最大收益是多少？

**示例：**

```txt
Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]
Output: 100 
Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately.。
```



### 解题思路

该题目分类属于中等题，且用two pointer进行解决。

#### 思路一

**核心**：找出每个工人能承受范围内工作的最大利润，求和即可。

1. 将所有job按照困难度从小到大排序，困难度相同时，按照利润从大到小排序。
2. 得到所有Job困难度下，能获得的最大利润。
3. 遍历worker，找到其能承受困难度下的最大利润，相加即可。

**代码如下：**

```java
class Solution {
    public int maxProfitAssignment(int[] d, int[] p, int[] w) {
        int len = d.length;
        if (len == 0) {
            return 0;
        }
        
        int[][] a = new int[len][2];
        
        for (int i = 0; i < len; i++) {
            a[i][0] = d[i];
            a[i][1] = p[i];
        }
        
        // 按照困难度从小到大排序
        Arrays.sort(a, (m, n) -> m[0] == n[0] ? n[1] - m[1] : m[0] - n[0]);
        
        
        // 该困难度下的最高利润
        int[] maxP = new int[len];
        
        maxP[0] = a[0][1];
        int max = a[0][1];
        for (int i = 1; i < len; i++) {
            max = Math.max(a[i][1], max);
            maxP[i] = max;
        }
        
        int sum = 0;
        int job = 0;
        
        // worker按照其能承受困难强度从小到大排序
        Arrays.sort(w);
        
        // 找到所有worker能承受困难下的最大利润
        max = 0;
        for (int i = 0; i < w.length; i++) {
            while (job < len) {
                if (w[i] >= a[job][0]) {
                    max = maxP[job];
                    job++;
                } else {
                    break;
                }
            }
            sum += max;
        }
        return sum;
    }
}
```

#### 思路二

利用DP的思想，dp[i]表示在worker能承受难度最大值为i时，其能获得的最大的利润。

```java
class Solution {
    public int maxProfitAssignment(int[] d, int[] p, int[] w) {
        int len = d.length;
        if (len == 0) {
            return 0;
        }
        
        int maxD = 0; // 最大难度值
        for (int num : d) {
            maxD = Math.max(maxD, num);
        }
        
        // dp[i] 表示在难度为i时，能获得的最大利润
        int[] dp = new int[maxD + 1];
        
        // 首先将题目给的数填充进来
        for (int i = 0; i < len; i++) {
            dp[d[i]] = Math.max(dp[d[i]], p[i]); 
        }
        
        int maxP = 0;
        // 可能出现难度高，但是利润小的工作，因此需要遍历再次找出特定难度下能获得的最大利润
        for (int i = 0; i <= maxD; i++) {
            maxP = Math.max(maxP, dp[i]);
            dp[i] = maxP;
        }
        
        int sum = 0;
        for (int n : w) {
            if (n > maxD) {
                sum += maxP;
            } else {
                sum += dp[n]; //将所有的利润求和
            }
        }
    
        return sum;
    }
}
```



