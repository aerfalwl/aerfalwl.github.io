# 初识Kafka

## Feture

1. 消息保留：是Kafka的一个重要特性，Broker默认的消息保留策略是，要不保留一段时间，要不保留到消息到达一定的字节数。当消息总量达到这些上限时，旧消息就被过期并被删除。紧凑型日志，只有最后一个带有特定键的消息会被保留，因为，人们只关心最后时刻发生的改变。
2. Kafka的消息复制机制只能在单个集群里进行，不能再多个集群之间进行。但是它提供一个叫做MirrorMaker的工具，可以用来实现集群之间的消息赋值。
3. 亚秒级的消息延迟。

## Kafka适用场景

1. 多个生产者
2. 多个消费者

## Kafka的使用场景

1. 活动跟踪，比如：用户网页访问次数和点击量。
2. 传递消息，比如向用户发通知。使用公共组件的好处：在公共组件上做一些有趣的转换，比如把多个消息聚合成一个单独的通知，而这些工作是无法在其它地方完成的。
3. 度量指标和日志记录。
4. 提交日志。
5. 流处理。

# 生产者

![Kafka生产者组件图](C:\Users\lwl\AppData\Roaming\Typora\typora-user-images\image-20201004160030424.png)

# 消费者

![消费者组群](C:\Users\lwl\AppData\Roaming\Typora\typora-user-images\image-20201005131625839.png)

如果消费者组群中消费者的数量多于主题分区的个数，则会有部分消费者被闲置，不会接收到任何消息。

# 深入Kafka

## Controller

1. Controller本质上也是一个broker，除了一般的broker的功能之外，它还负责首领的选举。集群中第一启动的Broker会在Zookeeper里创建一个临时节点/controller让自己成为控制器。
2. Controller负责在节点加入或者离开集群时进行分区首领的选举，并且使用epoch来避免脑裂，脑裂是指两个节点同时任务自己是当前的控制器。

## 复制

1. Kafka是一个可分区的，可复制的提交日志服务。
2.  副本
   1. 首领副本：每个分区有且仅有一个首领副本，为了保证一致性，所有生产者请求和消费者请求都会经过这个副本
   2. 跟随者副本：首领以外的副本都是跟随者副本，跟随者副本不处理来自客户端的的请求，它们唯一要做的就是从首领那里复制消息，保持与首领一致的状态，如果首领发生崩溃，则跟随者会被提升为新首领。

# Broker处理请求的方式

![image-20201005164403640](C:\Users\lwl\AppData\Roaming\Typora\typora-user-images\image-20201005164403640.png)

![image-20201005164434878](C:\Users\lwl\AppData\Roaming\Typora\typora-user-images\image-20201005164434878.png)

Kafka有用其它语言实现的客户端，如C, Python， Go语言等。Kafka网站上有它们的完整清单，这些客户端就是使用二进制协议与broker通信的。



## 分区分配

## 文件管理

1. Kafka将分区分为若干个片段。默认情况下，每个片段包含1GB或者一周的数据，以较小的那个为准。

### 文件格式

1. 我们把Kafka的消息和偏移量保存在文件中。

2. 键、值、偏移量、消息大小、校验和、消息格式版本号、压缩算法和时间戳。时间戳可以是生产者发送消息的时间，也可以是消息到达broker的时间，这个时间是可配置的。

3. 可以使用工具DUmpLogSegment来查看片段的内容，它可以显示每个消息的偏移量、校验和、魔术数、消息大小和压缩算法。

   ```shell
   bin/kafka-run-class.sh kafka.tools.DumpLogSegments
   ```

   ## 清理

   1. P84页，103