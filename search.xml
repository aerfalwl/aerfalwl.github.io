<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo+github搭建个人博客</title>
    <url>/2020/10/27/Config/hexo_config/</url>
    <content><![CDATA[<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>在电脑上搭建博客</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init xxx.github.io</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p>修改配置文件_config.yml，添加如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:xxx/youname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li><p>提交代码至仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean # 清空缓存</span><br><span class="line">hexo generate # 生成静态文件</span><br><span class="line">hexo deploy # 部署至远程仓库</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建分支用于保存原配置文件和原博客，因为hexo只会将它生成的静态文件上传，而不会上传相关配置文件和原markdown文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git checkout -b meta</span><br></pre></td></tr></table></figure>
</li>
<li><p>之后若有修改，则依次执行如下命令，<strong>注意顺序，且在meta分支执行</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo c &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;change&quot; &amp;&amp; git push origin meta</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="不同设备同步"><a href="#不同设备同步" class="headerlink" title="不同设备同步"></a>不同设备同步</h2><p>执行如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone -b meta https://github.com/XXX/xxx.git</span><br><span class="line">cd xxx.github.io</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 之后若有修改，则执行</span></span><br><span class="line">hexo c &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;change&quot; &amp;&amp; git push origin meta</span><br></pre></td></tr></table></figure>



<p>如果在别的设备上提交了，别忘了在提交之后先pull meta哈。</p>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>安装部署</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 插入图片</title>
    <url>/2020/10/28/Config/hexo_with_image/</url>
    <content><![CDATA[<p>本文主要介绍按照相对路径在hexo中插入图片的方法。</p>
<h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><ol>
<li><p>安装插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件_config.yml，将如下选项该为true：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">post_asset_foler: true</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改文件内容：node_modules/hexo-asset-image/index.js为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">        <span class="keyword">var</span> link = data.permalink;</span><br><span class="line">    <span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">    <span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">        xmlMode: <span class="literal">false</span>,</span><br><span class="line">        lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">        decodeEntities: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">            <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">            <span class="keyword">var</span> src = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">               !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">              <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">              <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">              <span class="keyword">var</span> linkArray = link.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">var</span> srcArray = src.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">                srcArray.shift();</span><br><span class="line">              src = srcArray.join(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">              $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class="line">              <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="built_in">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>至此配置完成，之后若hexo new post photo，则会在source/_posts文件夹下生成photo.md和photo文件夹，用户也可以在手动创建md文件的时候，创建对应名字的文件夹。</p>
</li>
<li><p>插入图片，假设photo文件夹下有如下文件图片：test.png，则用户可以在md文件中按照如下两种方式引用该图片。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">![描述](test.png) # </span><br><span class="line">![描述](photo/test.png) # 该种方式在Typora中可以直接显示图片，推荐该种方式。</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>安装部署</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/10/27/Kafka/2020-10-04-Kafka%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="初识Kafka"><a href="#初识Kafka" class="headerlink" title="初识Kafka"></a>初识Kafka</h1><h2 id="Feture"><a href="#Feture" class="headerlink" title="Feture"></a>Feture</h2><ol>
<li>消息保留：是Kafka的一个重要特性，Broker默认的消息保留策略是，要不保留一段时间，要不保留到消息到达一定的字节数。当消息总量达到这些上限时，旧消息就被过期并被删除。紧凑型日志，只有最后一个带有特定键的消息会被保留，因为，人们只关心最后时刻发生的改变。</li>
<li>Kafka的消息复制机制只能在单个集群里进行，不能再多个集群之间进行。但是它提供一个叫做MirrorMaker的工具，可以用来实现集群之间的消息赋值。</li>
<li>亚秒级的消息延迟。</li>
</ol>
<h2 id="Kafka适用场景"><a href="#Kafka适用场景" class="headerlink" title="Kafka适用场景"></a>Kafka适用场景</h2><ol>
<li>多个生产者</li>
<li>多个消费者</li>
</ol>
<h2 id="Kafka的使用场景"><a href="#Kafka的使用场景" class="headerlink" title="Kafka的使用场景"></a>Kafka的使用场景</h2><ol>
<li>活动跟踪，比如：用户网页访问次数和点击量。</li>
<li>传递消息，比如向用户发通知。使用公共组件的好处：在公共组件上做一些有趣的转换，比如把多个消息聚合成一个单独的通知，而这些工作是无法在其它地方完成的。</li>
<li>度量指标和日志记录。</li>
<li>提交日志。</li>
<li>流处理。</li>
</ol>
<h1 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h1><p><img src="/2020/10/27/Kafka/2020-10-04-Kafka%E7%AE%80%E4%BB%8B/Users\lwl\AppData\Roaming\Typora\typora-user-images\image-20201004160030424.png" alt="Kafka生产者组件图"></p>
<h1 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h1><p><img src="/2020/10/27/Kafka/2020-10-04-Kafka%E7%AE%80%E4%BB%8B/Users\lwl\AppData\Roaming\Typora\typora-user-images\image-20201005131625839.png" alt="消费者组群"></p>
<p>如果消费者组群中消费者的数量多于主题分区的个数，则会有部分消费者被闲置，不会接收到任何消息。</p>
<h1 id="深入Kafka"><a href="#深入Kafka" class="headerlink" title="深入Kafka"></a>深入Kafka</h1><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><ol>
<li>Controller本质上也是一个broker，除了一般的broker的功能之外，它还负责首领的选举。集群中第一启动的Broker会在Zookeeper里创建一个临时节点/controller让自己成为控制器。</li>
<li>Controller负责在节点加入或者离开集群时进行分区首领的选举，并且使用epoch来避免脑裂，脑裂是指两个节点同时任务自己是当前的控制器。</li>
</ol>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><ol>
<li>Kafka是一个可分区的，可复制的提交日志服务。</li>
<li>副本<ol>
<li>首领副本：每个分区有且仅有一个首领副本，为了保证一致性，所有生产者请求和消费者请求都会经过这个副本</li>
<li>跟随者副本：首领以外的副本都是跟随者副本，跟随者副本不处理来自客户端的的请求，它们唯一要做的就是从首领那里复制消息，保持与首领一致的状态，如果首领发生崩溃，则跟随者会被提升为新首领。</li>
</ol>
</li>
</ol>
<h1 id="Broker处理请求的方式"><a href="#Broker处理请求的方式" class="headerlink" title="Broker处理请求的方式"></a>Broker处理请求的方式</h1><p><img src="/2020/10/27/Kafka/2020-10-04-Kafka%E7%AE%80%E4%BB%8B/Users\lwl\AppData\Roaming\Typora\typora-user-images\image-20201005164403640.png" alt="image-20201005164403640"></p>
<p><img src="/2020/10/27/Kafka/2020-10-04-Kafka%E7%AE%80%E4%BB%8B/Users\lwl\AppData\Roaming\Typora\typora-user-images\image-20201005164434878.png" alt="image-20201005164434878"></p>
<p>Kafka有用其它语言实现的客户端，如C, Python， Go语言等。Kafka网站上有它们的完整清单，这些客户端就是使用二进制协议与broker通信的。</p>
<h2 id="分区分配"><a href="#分区分配" class="headerlink" title="分区分配"></a>分区分配</h2><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><ol>
<li>Kafka将分区分为若干个片段。默认情况下，每个片段包含1GB或者一周的数据，以较小的那个为准。</li>
</ol>
<h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3><ol>
<li><p>我们把Kafka的消息和偏移量保存在文件中。</p>
</li>
<li><p>键、值、偏移量、消息大小、校验和、消息格式版本号、压缩算法和时间戳。时间戳可以是生产者发送消息的时间，也可以是消息到达broker的时间，这个时间是可配置的。</p>
</li>
<li><p>可以使用工具DUmpLogSegment来查看片段的内容，它可以显示每个消息的偏移量、校验和、魔术数、消息大小和压缩算法。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-run-class.sh kafka.tools.DumpLogSegments</span><br></pre></td></tr></table></figure>

<h2 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h2><ol>
<li>P84页，103</li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>hexo 博客被google收录</title>
    <url>/2020/10/27/Config/hexo_google_site/</url>
    <content><![CDATA[<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>生成站点地图</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件_config.yml，添加如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">urlgoogle: https://xxx.github.io/ </span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改_config.xml，设置url为你的github.io</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">url: https://xxx.github.io</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>添加站点，登录<a href="https://www.google.com/webmasters/">Google 网站站长</a>，进入<code>Search Console</code>，进入如下页面</p>
<p><img src="/2020/10/27/Config/hexo_google_site/first.png" alt="首页"></p>
</li>
<li><p>选择网址前缀，输入<a href="https://xxx.github.io/">https://xxx.github.io</a></p>
</li>
<li><p>之后，下载Google验证文件，放在<code>theme/next/source</code>目录中。</p>
</li>
<li><p>生成robots.xt文件，在hexo的source目录下，放入如下内容：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /home/</span><br><span class="line">Allow: /archives/</span><br><span class="line">Allow: /categories/</span><br><span class="line">Allow: /tags/</span><br><span class="line"></span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line"></span><br><span class="line">Sitemap: https://aerfalwl.github.io/sitemap.xml</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="8">
<li><p>重新生成和部署</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署完成之后，进行验证即可，若操作无误，便会验证成功。</p>
</li>
<li><p>添加站点地图：</p>
<p><img src="/2020/10/27/Config/hexo_google_site/add_sitemap.png" alt="添加站点地图"></p>
</li>
<li><p>为了加快Google扫描网站的速度，可以通过以下方式建立索引：</p>
<ul>
<li>在浏览器中输入<a href="https://www.google.com/ping?sitemap=https://aerfalwl.github.io/sitemap.xml%E8%A6%81%E6%B1%82Google%E7%BB%99%E7%BD%91%E7%AB%99%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%EF%BC%9B">https://www.google.com/ping?sitemap=https://aerfalwl.github.io/sitemap.xml要求Google给网站建立索引；</a></li>
</ul>
</li>
<li><p>等待几分钟，在Google中搜索site:aerfalwl.github.io检验是否能看到网站内容。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>安装部署</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/10/27/Kafka/2020-10-04-%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<h2 id="Kafka与Broker不同"><a href="#Kafka与Broker不同" class="headerlink" title="Kafka与Broker不同"></a>Kafka与Broker不同</h2><ol>
<li>消息定期清理。各个主题设置单独的保留规则，以便满足不同消费者的需求，各个主题可以保留不同数量的消息。</li>
<li>多个消费者可以重复消费同一条消息。</li>
<li>Kafka可以在如下情况下自动创建主题：当一个生产者开始往主题写入消息时，当一个消费者开始从主题读取消息时，当任意一个客户端向主题发送元数据请求时。</li>
<li>客户端为了优化网络和磁盘空间，会对消息进行压缩，服务器需要对消息进行批量解压，设置偏移量，然后重新进行批量压缩，再保存在磁盘上。</li>
<li>kafka允许主题的名字为null, Refactor不允许。</li>
<li>Kafka的Consumer属于消费者组群。</li>
<li>消费者组群之间允许重复消费消息。<img src="/2020/10/27/Kafka/2020-10-04-%E6%AF%94%E8%BE%83/Users\lwl\AppData\Roaming\Typora\typora-user-images\image-20201005132432782.png" alt="image-20201005132432782"></li>
<li>Kafka中所有broker都缓存了元数据，因此，客户端可以向任何一个broker发送<strong>元数据请求</strong>，并得到客户端所感兴趣的主题所在分区，每个分区都包含哪些副本，以及哪个副本是首领。因此，consumer需要时不时的向broker发送元数据请求来刷新本地缓存的信息。</li>
<li></li>
</ol>
<h1 id="Kafka的一些Feture"><a href="#Kafka的一些Feture" class="headerlink" title="Kafka的一些Feture"></a>Kafka的一些Feture</h1><ol>
<li><p>Kafka的所有消息保存在磁盘上，存放这些日志片段的目录是通过log.dirs指定的，它是一组用逗号分割的本地文件系统路径。如果指定了多个路径，那么Broker会根据最少使用原则，把统一分区的日志片段保存在同一路径下。要注意：Broker会往拥有最少数据分区的路径新增分区，而不是往拥有最少磁盘空间的路径新增分区。</p>
</li>
<li><p>提供二进制连接协议，即用户直接向Kafka网络端口发送适当的字节序列，就可以实现从Kafka读取消息或往Kafka写消息</p>
</li>
<li><p>用户可以从指定偏移量开始读数据，例如seekToBeginning和seekToEnd</p>
</li>
<li><p>消费者既可以依赖于组群存在，也可以独立存在。</p>
</li>
<li><p>消费者请求数据的时候，可以设置broker返回数据的上限，也可以设置下限。这样可以在主题消息流量不是很大的情况下，减少CPU和网络开销。</p>
</li>
<li><p>日志压缩是Kafka的一个高级特性，因为有了这个特性，Kafka可以用来长时间保存数据。</p>
</li>
</ol>
<h2 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h2><ol>
<li>Kafka也需人为设置BrokerID,需要使用者自己保证该ID是唯一的，如果两个broker使用相同的BrokerID，则第二个broker就无法启动。在Broker启动时，它通过创建临时节点把自己的ID注册到Zookeeper。Kafka组件订阅Zookeeper的/brokers/ids路径（broker在Zookeeper上的注册路径），当有broker加入集群或者退出集群时，这些组件就能获得通知。</li>
</ol>
<h1 id="Refactor一些可以改进的地方"><a href="#Refactor一些可以改进的地方" class="headerlink" title="Refactor一些可以改进的地方"></a>Refactor一些可以改进的地方</h1><ol>
<li>发送消息长度超过MESSAGE_LENGTH时，返回错误码；</li>
<li>Consumer请求的topic不在此broker上，返回相关错误码；</li>
</ol>
<h1 id="日志维护"><a href="#日志维护" class="headerlink" title="日志维护"></a>日志维护</h1><h2 id="小收获"><a href="#小收获" class="headerlink" title="小收获"></a>小收获</h2><ol>
<li>除了设置socket 外，还需要设置TCP soc ke t 的读写缓冲区，它们的参数分别是net.i.pv4.tcp_wmem和net . i.pv4 . tc p_ wmem 。这些参数的值由3 个整数组成，它们使用空格分隔，分别表示最小值、默认值和最大值。最大值不能大于net.core.wmem_max可以和net.core.rmem_max指定的大小。例如，“4096 65536 204800。”表示最小值是4KB、默认值是64KB、最大值是2MB 。根据Kafka 服务器接收流量的实际情况，可能需要设置更高的最大值，为网络连接提供更大的缓冲空间。还有其他一些有用的网络参数。例如， 把net.ipv4.tcp_window_scaling 设为l ，启用TCP时间窗扩展，可以提升客户端传输数据的效率，传输的数据可以在服务器端进行缓冲。把net.1.pv4.tcp_max_syn_backlog 设为比默认值1024 更大的值，可以接受更多的井发连接, 把net.core.netdev_max_backlog 设为比默认值1000 更大的值，有助于应对网络流量的爆发，特别是在使用千兆网络的情况下，允许更多的数据包排队等待内核处理。</li>
<li></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/10/27/Filesystem/ZFS/</url>
    <content><![CDATA[<h2 id="Introduction-to-the-Kernel"><a href="#Introduction-to-the-Kernel" class="headerlink" title="Introduction to the Kernel"></a>Introduction to the Kernel</h2><ol>
<li>参考书籍The Design and Implementation of the FreeBSD Operating System, 2nd<br>Edition</li>
</ol>
<h1 id="Introduction-to-the-Zettabyte-Filesystem"><a href="#Introduction-to-the-Zettabyte-Filesystem" class="headerlink" title="Introduction to the Zettabyte Filesystem"></a>Introduction to the Zettabyte Filesystem</h1><ol>
<li>开始于Solaries。</li>
<li>Solaris是Sun Microsystem开发的一个Unix版本的操作系统；<ul>
<li>它是以下两种操作系统的合并版：SunOs和System V4</li>
</ul>
</li>
<li>Sun需要解决的问题是：传统的操作系统在处理大数据的时候，显现出了很大的缺点，因为大数据使得系统需要大量的磁盘。</li>
<li>为解决以上问题，Sun写了ZFS:<ul>
<li>Log Structured Filesystem，由Berkeley开发，展现出了它处理大问题大数据的一些优势</li>
<li>文件系统不可重复写的特性，给了它很多比较好的特性。</li>
</ul>
</li>
</ol>
<h1 id="ZFS的演变过程"><a href="#ZFS的演变过程" class="headerlink" title="ZFS的演变过程"></a>ZFS的演变过程</h1><ol>
<li>首先出现于OpenSolaris,  该操作系统是一款Solaris开源的操作系统，包括核心科技：ZFS和DTrace</li>
<li>随后，ZFS出现在了FreeBSD（一款Unix操作系统）中；</li>
<li>之后，Sun被Oracle收购，但是Larry Ellison不是一个开源爱好者，他不同意ZFS继续开源，但是已经开源的早期版本还在流传；</li>
<li>于是一些公司继续开发并维护OpenSolaris，并且将他作为一个开源项目；</li>
<li>一些组件变得很流行，像ZFS；</li>
<li>最后ZFS变为单独的OpenZFS项目；</li>
<li>当前开发OpenZFS的主要有四个组，它们每个月都有一次会议来协同工作：<ul>
<li>致力于OpenSolaris开发的组；</li>
<li>FressBSD开发者；</li>
<li>致力于将ZFS嵌入到Linux内核的Lawrence Livermore National Laboratory</li>
<li>致力于将ZFS嵌入到MacOs和Windows的Jorgen Lundman</li>
</ul>
</li>
<li>Sun Community Development License与GNU Public License不兼容：<ul>
<li>ZFS代码不能嵌入到Linux内核中；</li>
<li>所有将ZFS带入嵌入到Linux内核的人不能使用GPL interfaces（GPL Interface是Linux的一个特性，该特性说明只有GPL的代码之间才能相互使用和修改）</li>
<li>ZFS只能通过FUSE(用户态空间文件系统， Filesystem in Userspace)访问Linux Kernel。</li>
</ul>
</li>
<li>在2016年，Ubuntu开源了一版在Kernel态的ZFS，它没有使用GPL interfaces，因此，自己额外开发了一些函数。当前，Canonical（开发Ubuntu的公司）还没被起诉，更多详情访问<a href="https://wiki.ubuntu.com/ZFS">https://wiki.ubuntu.com/ZFS</a></li>
<li>当前，OpenZFS代码已经能在大多数Linux系统中配置使用。</li>
</ol>
<p>ZFS相关资料：<a href="https://openzfs.org/wiki/Main_Page">https://openzfs.org/wiki/Main_Page</a></p>
<p>Github网址：<a href="https://github.com/openzfs/zfs">https://github.com/openzfs/zfs</a></p>
<h1 id="Kernel-I-O-Structure"><a href="#Kernel-I-O-Structure" class="headerlink" title="Kernel I/O Structure"></a>Kernel I/O Structure</h1><ol>
<li>关于kernel的系统调用：<ul>
<li>一切在硬件和系统调用之间的都是操作系统(everything between this and the hardware is the operating system)。</li>
<li>当我们和subsystem进行交互时，其实是在和file descriptor、socket、kqueue交互</li>
</ul>
</li>
</ol>
<p><img src="/2020/10/27/Filesystem/ZFS/Users\CCDC\AppData\Roaming\Typora\typora-user-images\image-20201014101848952.png" alt="image-20201014101848952"></p>
<h1 id="FileSystem-Consistency"><a href="#FileSystem-Consistency" class="headerlink" title="FileSystem Consistency"></a>FileSystem Consistency</h1><ol>
<li>必须维护一些元数据信息：directories, inodes, bitmaps</li>
<li>维护元数据的一些规则：<ul>
<li>在一个结构被初始化之前不要指向它</li>
<li>在将一个对象的所有指针置为空之前，不要使新指针指向它</li>
<li>在新指针被设置之前，不要讲老指针设置为一个可用的资源(例如，rename foo to bar，则在将foo的旧指针指向bar之后，再删除老的foo)</li>
</ul>
</li>
</ol>
<h1 id="Keeping-Metadata-Consistent"><a href="#Keeping-Metadata-Consistent" class="headerlink" title="Keeping Metadata Consistent"></a>Keeping Metadata Consistent</h1><p>实现一致性的三种方法：</p>
<ol>
<li>同步写</li>
<li>使用非易失性RAM</li>
<li>原子更新(journaling and logging)</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Leetcode 1234. Replace the Substring for Balanced String</title>
    <url>/2020/10/29/Leetcode/1234/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.com/problems/replace-the-substring-for-balanced-string/">英文题目</a></p>
<p><a href="https://leetcode-cn.com/problems/replace-the-substring-for-balanced-string/">中文题目</a></p>
<p>难度：中等</p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>说明：题目来自leetcode中文官网</p>
<p>有一个只含有 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符，且长度为 n 的字符串。</p>
<p>假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。</p>
<p>给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。</p>
<p>你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。</p>
<p>请返回待替换子串的最小可能长度。</p>
<p>如果原字符串自身就是一个平衡字符串，则返回 0。</p>
<p><strong>示例：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;QWER&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：s 已经是平衡的了。</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">输入：s = &quot;QQWE&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：我们需要把一个 &#x27;Q&#x27; 替换成 &#x27;R&#x27;，这样得到的 &quot;RQWE&quot; (或 &quot;QRWE&quot;) 是平衡的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------</span><br><span class="line">输入：s = &quot;QQQW&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：我们可以把前面的 &quot;QQ&quot; 替换成 &quot;ER&quot;。</span><br><span class="line"></span><br><span class="line">-------------</span><br><span class="line">输入：s = &quot;QQQQ&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：我们可以替换后 3 个 &#x27;Q&#x27;，使 s = &quot;QWER&quot;。</span><br></pre></td></tr></table></figure>



<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决，核心思路见代码：</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> e = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> q = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> r = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">balancedString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span> || (len % <span class="number">4</span> != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> e = <span class="number">0</span>, w = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">                e++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">                w++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                q++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// t为target的简写，t是每个字符的目标个数</span></span><br><span class="line">        <span class="keyword">int</span> t = len / <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span> (e == w &amp;&amp; w == r &amp;&amp; r == q) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 以下四行的n为need的简写，算出其离目标的距离即该字符需要变换的个数</span></span><br><span class="line">        <span class="comment">// 需要注意的是，我们只计算大于目标的字符距离目标的个数，因为变换是相互的</span></span><br><span class="line">        <span class="comment">// 你也可以只计算小于目标的字符距离目标的个数</span></span><br><span class="line">        <span class="keyword">int</span> ne = (e &lt;= t) ? <span class="number">0</span> : e - t;</span><br><span class="line">        <span class="keyword">int</span> nw = (w &lt;= t) ? <span class="number">0</span> : w - t;</span><br><span class="line">        <span class="keyword">int</span> nq = (q &lt;= t) ? <span class="number">0</span> : q - t;</span><br><span class="line">        <span class="keyword">int</span> nr = (r &lt;= t) ? <span class="number">0</span> : r - t;</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = len;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 以下声明中，c为current的简写</span></span><br><span class="line">        <span class="comment">// 下面四个变量代表在left和right指针区间内，各个字符的个数</span></span><br><span class="line">        <span class="keyword">int</span> cq = <span class="number">0</span>, cw = <span class="number">0</span>, ce = <span class="number">0</span>, cr = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                cq++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">                cw ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">                ce++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                cr++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果当前的指针范围内各个字符需要变换的个数都满足需求，则我们开始</span></span><br><span class="line">            <span class="comment">// 保存结果并缩小指针区间</span></span><br><span class="line">            <span class="keyword">while</span> (cq &gt;= nq &amp;&amp; cw &gt;= nw &amp;&amp; ce &gt;= ne &amp;&amp; cr &gt;= nr) &#123;</span><br><span class="line">                ans = Math.min(ans, right - left + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">char</span> leftC = s.charAt(left);</span><br><span class="line">                <span class="keyword">if</span> (leftC == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                    cq--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftC == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">                    cw--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftC == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">                    ce--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftC == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                    cr--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 否则继续增大指针范围</span></span><br><span class="line">            right++;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 142. Linked List Cycle II</title>
    <url>/2020/11/01/Leetcode/142/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.com/problems/linked-list-cycle-ii/">英文题目</a></p>
<p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">中文题目</a></p>
<p>难度：中等</p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>简单来说，就是判断一个链表是否有环，如果有的话，返回环的起点。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决。该问题可以拆解为两个子问题：</p>
<h4 id="如何判断一个链表是否有环"><a href="#如何判断一个链表是否有环" class="headerlink" title="如何判断一个链表是否有环"></a>如何判断一个链表是否有环</h4><p>这个问题比较简单，我们设置一快一慢两个指针，快指针每次走一步，慢指针每次走两步，则如果时间充裕，两个指针一定会相遇。</p>
<p>该问题类似于小学题目中的追击问题：操场上两个同学的跑步，一个同学的速度是<code>x</code>，另一个同学的速度是<code>y</code>，假设<code>x&gt;y</code>，则最快多长时间两个人可以相遇？答案是<code>s/(x-y)</code>，且初次相遇时两者路程差一定是<code>S</code>。判断链表有环时，其实不能完全套用这个问题，因为两个人跑步时，操场上所有的点都是它们可以相遇的点，但是链表问题中，环上只有几个点可以是它们相遇的点，因此，初次相遇时，两者的路程差不一定是<code>S</code>，而是可能是<code>nS</code>，但是可以证明它们一定是可以相遇的。</p>
<h4 id="如何判断环的起点"><a href="#如何判断环的起点" class="headerlink" title="如何判断环的起点"></a>如何判断环的起点</h4><p>证明如下图所示：</p>
<p><img src="/2020/11/01/Leetcode/142/zhengming.png" alt="证明"></p>
<p>看不懂没关系，记住下面的技巧即可：</p>
<p>简单来说：两个指针相遇之后，将快指针放回原点，慢指针位置不变，两者都以慢指针的速度遍历节点。则再次相遇时，便是环的起点。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow != <span class="keyword">null</span> &amp;&amp; fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next; <span class="comment">// 一次走一步</span></span><br><span class="line">            fast = fast.next.next; <span class="comment">// 一次走两步</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="keyword">false</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        fast = head; <span class="comment">// 快指针放回起点</span></span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123; </span><br><span class="line">            fast = fast.next; <span class="comment">// 以相同速度前进 </span></span><br><span class="line">            slow = slow.next; <span class="comment">// 以相同速度前进 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow; <span class="comment">// 交点即环的起点</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>两个指针：慢指针和快指针，慢指针一次走一步，快指针一次走两步。如果两个指针相遇，就是有环，如果两个指针不相遇，就是没环。</li>
<li>将快指针放回链表起点，慢指针位置不变，两者都以慢速遍历指针，再次相遇的点即为环的起点。</li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 532. K-diff Pairs in an Array</title>
    <url>/2020/10/31/Leetcode/523/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.com/problems/k-diff-pairs-in-an-array/">英文题目</a></p>
<p><a href="https://leetcode-cn.com/problems/k-diff-pairs-in-an-array/">中文题目</a></p>
<p>难度：中等</p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>说明：题目来自leetcode中文官网</p>
<p>给定一个整数数组和一个整数 k，你需要在数组里找到不同的 k-diff 数对，并返回不同的 k-diff 数对 的数目。</p>
<p>这里将 k-diff 数对定义为一个整数对 (nums[i], nums[j])，并满足下述全部条件：</p>
<p>0 &lt;= i, j &lt; nums.length<br>i != j<br>|nums[i] - nums[j]| == k<br>注意，|val| 表示 val 的绝对值。</p>
<p><strong>示例：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [3, 1, 4, 1, 5], k = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。</span><br><span class="line">尽管数组中有两个1，但我们只应返回不同的数对的数量。</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">输入：nums = [1, 2, 3, 4, 5], k = 1</span><br><span class="line">输出：4</span><br><span class="line">解释：数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。</span><br><span class="line"></span><br><span class="line">-------------</span><br><span class="line">输入：nums = [1, 3, 1, 5, 4], k = 0</span><br><span class="line">输出：1</span><br><span class="line">解释：数组中只有一个 0-diff 数对，(1, 1)。</span><br></pre></td></tr></table></figure>



<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决，核心思路见代码：</p>
<ol>
<li>数组排序</li>
<li>前后两个指针遍历数组，如果当前指针所指的差值等于k，则是我们想要的答案，需要注意的地方是 ：<ul>
<li>题目要求找到唯一的数组对，因此，排序之后相同的数字会排在一起，这里需要跳过重复的数字</li>
<li>k为0的情况，注意别让两个指针重合了</li>
</ul>
</li>
</ol>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPairs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span> || nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; len) &#123;</span><br><span class="line">            <span class="keyword">int</span> lv = nums[l];</span><br><span class="line">            <span class="keyword">int</span> rv = nums[r];</span><br><span class="line">            <span class="keyword">if</span> (rv - lv == k) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">int</span> preL = lv;</span><br><span class="line">                <span class="keyword">int</span> preR = rv;</span><br><span class="line">                <span class="keyword">while</span>((r + <span class="number">1</span> &lt; len) &amp;&amp; nums[++r] == preR) &#123;&#125; <span class="comment">// 跳过重复数字</span></span><br><span class="line">                <span class="keyword">while</span>((l + <span class="number">1</span> &lt; len) &amp;&amp; nums[++l] == preL) &#123;&#125; <span class="comment">// 跳过重复数字</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rv - lv &lt; k) &#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rv - lv &gt; k) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (l == r) r = l + <span class="number">1</span>; <span class="comment">// 避免k=0时，左右指针重合的情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>1616. Split Two Strings to Make Palindrome</title>
    <url>/2020/10/30/Leetcode/1616/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.com/problems/split-two-strings-to-make-palindrome/">英文题目</a></p>
<p><a href="https://leetcode-cn.com/problems/split-two-strings-to-make-palindrome/">中文题目</a></p>
<p>难度：中等</p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>说明：题目来自leetcode中文官网</p>
<p>给你两个字符串 a 和 b ，它们长度相同。请你选择一个下标，将两个字符串都在 相同的下标 分割开。由 a 可以得到两个字符串： aprefix 和 asuffix ，满足 a = aprefix + asuffix ，同理，由 b 可以得到两个字符串 bprefix 和 bsuffix ，满足 b = bprefix + bsuffix 。请你判断 aprefix + bsuffix 或者 bprefix + asuffix 能否构成回文串。</p>
<p>当你将一个字符串 s 分割成 sprefix 和 ssuffix 时， ssuffix 或者 sprefix 可以为空。比方说， s = “abc” 那么 “” + “abc” ， “a” + “bc” ， “ab” + “c” 和 “abc” + “” 都是合法分割。</p>
<p>如果 能构成回文字符串 ，那么请返回 true，否则返回 false 。</p>
<p>请注意， x + y 表示连接字符串 x 和 y 。</p>
<p><strong>示例：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：a = &quot;x&quot;, b = &quot;y&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：如果 a 或者 b 是回文串，那么答案一定为 true ，因为你可以如下分割：</span><br><span class="line">aprefix = &quot;&quot;, asuffix = &quot;x&quot;</span><br><span class="line">bprefix = &quot;&quot;, bsuffix = &quot;y&quot;</span><br><span class="line">那么 aprefix + bsuffix = &quot;&quot; + &quot;y&quot; = &quot;y&quot; 是回文串。</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">输入：a = &quot;ulacfd&quot;, b = &quot;jizalu&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：在下标为 3 处分割：</span><br><span class="line">aprefix = &quot;ula&quot;, asuffix = &quot;cfd&quot;</span><br><span class="line">bprefix = &quot;jiz&quot;, bsuffix = &quot;alu&quot;</span><br><span class="line">那么 aprefix + bsuffix = &quot;ula&quot; + &quot;alu&quot; = &quot;ulaalu&quot; 是回文串</span><br></pre></td></tr></table></figure>



<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决，核心思路见代码：</p>
<ol>
<li>如果a前缀加上b后缀为回文，则在遍历过程中，一定存在以下情况：<ul>
<li>a的左指针，对称在b的右指针所指向的值是相等的，如果不相等，则它们之间的那一段必定是回文才能保证拼接之后是回文；</li>
</ul>
</li>
<li>反过来，对于b和a也是一样的。</li>
</ol>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPalindromeFormation</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(a, b) || helper(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = a.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; len; i++, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.charAt(i) != b.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> isP(a, i, j) || isP(b, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isP</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(j)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>algorithm</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 287. Find the Duplicate Number</title>
    <url>/2020/11/02/Leetcode/287/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.com/problems/find-the-duplicate-number/">英文题目</a></p>
<p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">中文题目</a></p>
<p>难度：中等</p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个包含<code>n+1</code>个数字的数组，该数组中所有数字都在范围<code>[1,n]</code>内，该数组中有且仅有一个数字出现了两次，求这个数字。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>该数组可以等价为一个链表，数组中的每个元素等价为一个节点，每个节点的值得<code>nums[i]</code>，该节点的<code>next</code>值为<code>nums[nums[i]]</code>，即该节点的值为下一个节点在数组中的索引。这样，原本的数组就转换为了一个链表，对于链表中的每个节点，有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node n;</span><br><span class="line">n.val = nums[i];</span><br><span class="line">n.next = nums[n.val] <span class="comment">// 或者n.next = nums[num[i]]</span></span><br></pre></td></tr></table></figure>

<p>以nums[0]为头节点，就能将这个数组转换为链表啦。当然，你也可以以任意一个节点为头节点，而不仅仅是Nums[0]。</p>
<p>转换为链表之后，链表中必存在环，因为有数字出现了两次，出现了两次意味着它是两个节点的next节点，也就是该数字是环的起点。</p>
<p><strong>例子一：</strong></p>
<p>假设现在有数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index: 0 1 2 3 4 </span><br><span class="line">value: 1 3 4 2 2</span><br></pre></td></tr></table></figure>

<p>则以nums[0]为头节点，组成的链表为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1-&gt;3-&gt;2-&gt;4</span><br><span class="line">	  |__| </span><br></pre></td></tr></table></figure>

<p>我们发现，2在数组中出现了两次，同时它也是环的起点。</p>
<p><strong>例子二：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index: 0 1 2 3 4</span><br><span class="line">value: 3 1 3 4 2</span><br></pre></td></tr></table></figure>

<p>则以nums[0]为头节点，组成的链表为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3-&gt;4-&gt;2</span><br><span class="line">|_____|   </span><br></pre></td></tr></table></figure>

<p>同样，3出现了两次，它也是环的起点。</p>
<h4 id="如何判断环状链表的起点"><a href="#如何判断环状链表的起点" class="headerlink" title="如何判断环状链表的起点"></a>如何判断环状链表的起点</h4><p><a href="https://aerfalwl.github.io/2020/11/01/Leetcode/142/">证明</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[nums[fast]];</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>找环的起点：</strong></p>
<ol>
<li>两个指针：慢指针和快指针，慢指针一次走一步，快指针一次走两步。如果两个指针相遇，就是有环，如果两个指针不相遇，就是没环。</li>
<li>将快指针放回链表起点，慢指针位置不变，两者都以慢速遍历指针，再次相遇的点即为环的起点。</li>
</ol>
<p><strong>数组</strong></p>
<ol>
<li>数组中的每个元素可以有两层含义<ul>
<li>它可以作为一个值(value)</li>
<li>该值也可以是数组的一个索引(index)</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 567. Permutation in String</title>
    <url>/2020/11/03/Leetcode/567/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.com/problems/permutation-in-string/">英文题目</a></p>
<p><a href="https://leetcode-cn.com/problems/permutation-in-string/">中文题目</a></p>
<p>难度：中等</p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>题目给出两个字符串<code>s1</code>和<code>s2</code>，返回<code>s1</code>的全排列之一是否是<code>s2</code>的子集。</p>
<p><strong>示例：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Input: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</span><br><span class="line">Output: True</span><br><span class="line">Explanation: s2 contains one permutation of s1 (&quot;ba&quot;).</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">Input:s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure>



<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决，核心思路：</p>
<ol>
<li>如果字符串<code>a</code>是字符串<code>b</code>的subtring，则<code>b</code>字符串其中的一段，一定和a的长度相等；</li>
<li>a的全排列，就是将a中字符全部打乱，任意排列；且全排列不会更改字符串中字符出现的次数；</li>
</ol>
<p>因此，在代码中：</p>
<pre><code>1. 计算`s1`中每个字符出现的个数，保存在数组中；
 2. 两个指针遍历`s2`，假设两个指针之间形成的字符串为`tmpS`，若`tmpS`中每个字符的个数和`s1`中每个字符出现的个数相等，则返回`true`，遍历结束也没满足条件，返回false；</code></pre>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s1.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = s2.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> s : s1.toCharArray()) &#123;</span><br><span class="line">            dp[s - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> need = len1;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; len2) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s2.charAt(right);</span><br><span class="line">            <span class="keyword">if</span> (dp[c - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[c - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                need--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[c - <span class="string">&#x27;a&#x27;</span>] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                dp[s2.charAt(left) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">                left++;</span><br><span class="line">                need++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (need == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>763. Partition Labels</title>
    <url>/2020/10/27/Leetcode/763/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.com/problems/partition-labels/">英文题目</a></p>
<p><a href="https://leetcode-cn.com/problems/partition-labels/">中文题目</a></p>
<p>难度：中等</p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>说明：题目来自leetcode中文官网</p>
<p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p>
<p><strong>示例：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：S = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">输出：[9,7,8]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。</span><br></pre></td></tr></table></figure>



<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决。</p>
<p>即首先找到每个字母最后出现的位置，之后划分段的时候，确保该段内每个字母出现的最右值的位置在该段内。不太好描述，直接看代码。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.length() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span>[] s = S.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len = s.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] max = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (max[curr] &lt; i) max[curr] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxRight = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">                <span class="keyword">int</span> curr = max[s[right] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">if</span> (maxRight &lt; curr) maxRight = curr;</span><br><span class="line">                <span class="keyword">if</span> (right == maxRight) &#123;</span><br><span class="line">                    ans.add(right - left + <span class="number">1</span>);</span><br><span class="line">                    left = right + <span class="number">1</span>;</span><br><span class="line">                    right++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != right) &#123;</span><br><span class="line">            ans.add(right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="Two-pointer解决套路"><a href="#Two-pointer解决套路" class="headerlink" title="Two pointer解决套路"></a>Two pointer解决套路</h3><p>Two pointer和滑动窗口差不多，其套路一般为：</p>
<ol>
<li>一个左指针，一个右指针。其中左指针用于缩小范围，右指针用于扩大搜索范围。一般求滑动窗口的最小值都是在缩小左指针的时候取得的。</li>
<li>右指针扩展的条件时：只要当前还没有满足条件，就暴力增长，直到第一次满足条件为止。</li>
<li>左指针收缩的条件：只要当前指针的缩小还没影响窗口的可满足性，就一直暴力向左增长。一但当前指针向前移动的时候影响了窗口的可满足性，就记录下当前的窗口大小，并更新目前为止满足条件的最小窗口记录。之后，再次扩展右指针，使得窗口满足题目的条件。</li>
<li>以此类推即可。</li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/10/27/Leetcode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p><a href="https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/367697">https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/367697</a></p>
<ul>
<li><ol>
<li><a href="https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1)">Count Number of Nice Subarrays</a></li>
</ol>
</li>
<li><ol>
<li><a href="https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/367697">Replace the Substring for Balanced String</a></li>
</ol>
</li>
<li><ol>
<li><a href="https://leetcode.com/problems/max-consecutive-ones-iii/discuss/247564/javacpython-sliding-window/379427?page=3">Max Consecutive Ones III</a></li>
</ol>
</li>
<li><ol>
<li><a href="https://leetcode.com/problems/binary-subarrays-with-sum/discuss/186683/">Binary Subarrays With Sum</a></li>
</ol>
</li>
<li><ol>
<li><a href="https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/234482/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1)">Subarrays with K Different Integers</a></li>
</ol>
</li>
<li><ol>
<li><a href="https://leetcode.com/problems/fruit-into-baskets/discuss/170740/Sliding-Window-for-K-Elements">Fruit Into Baskets</a></li>
</ol>
</li>
<li><ol>
<li><a href="https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/C%2B%2BJavaPython-O(N)-Using-Deque">Shortest Subarray with Sum at Least K</a></li>
</ol>
</li>
<li><ol>
<li><a href="https://leetcode.com/problems/minimum-size-subarray-sum/discuss/433123">Minimum Size Subarray Sum</a></li>
</ol>
</li>
</ul>
<p><a href="https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/204290/Monotonic-Queue-Summary">https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/204290/Monotonic-Queue-Summary</a></p>
]]></content>
  </entry>
  <entry>
    <title>LeetCode 826. Most Profit Assigning Work</title>
    <url>/2020/10/28/Leetcode/826/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.com/problems/most-profit-assigning-work/">英文题目</a></p>
<p><a href="https://leetcode-cn.com/problems/most-profit-assigning-work/">中文题目</a></p>
<p>难度：中等</p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>说明：题目来自leetcode中文官网</p>
<p>有一些工作：<code>difficulty[i]</code> 表示第 <code>i</code> 个工作的难度，<code>profit[i]</code> 表示第 <code>i</code> 个工作的收益。</p>
<p>现在我们有一些工人。<code>worker[i]</code> 是第 <code>i</code> 个工人的能力，即该工人只能完成难度小于等于 <code>worker[i]</code> 的工作。</p>
<p>每一个工人都最多只能安排一个工作，但是一个工作可以完成多次。</p>
<p>举个例子，如果 3 个工人都尝试完成一份报酬为 1 的同样工作，那么总收益为 $3。如果一个工人不能完成任何工作，他的收益为 $0 。</p>
<p>我们能得到的最大收益是多少？</p>
<p><strong>示例：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]</span><br><span class="line">Output: 100 </span><br><span class="line">Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately.。</span><br></pre></td></tr></table></figure>



<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决。</p>
<h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p><strong>核心</strong>：找出每个工人能承受范围内工作的最大利润，求和即可。</p>
<ol>
<li>将所有job按照困难度从小到大排序，困难度相同时，按照利润从大到小排序。</li>
<li>得到所有Job困难度下，能获得的最大利润。</li>
<li>遍历worker，找到其能承受困难度下的最大利润，相加即可。</li>
</ol>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfitAssignment</span><span class="params">(<span class="keyword">int</span>[] d, <span class="keyword">int</span>[] p, <span class="keyword">int</span>[] w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = d.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[len][<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            a[i][<span class="number">0</span>] = d[i];</span><br><span class="line">            a[i][<span class="number">1</span>] = p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 按照困难度从小到大排序</span></span><br><span class="line">        Arrays.sort(a, (m, n) -&gt; m[<span class="number">0</span>] == n[<span class="number">0</span>] ? n[<span class="number">1</span>] - m[<span class="number">1</span>] : m[<span class="number">0</span>] - n[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 该困难度下的最高利润</span></span><br><span class="line">        <span class="keyword">int</span>[] maxP = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        </span><br><span class="line">        maxP[<span class="number">0</span>] = a[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> max = a[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            max = Math.max(a[i][<span class="number">1</span>], max);</span><br><span class="line">            maxP[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> job = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// worker按照其能承受困难强度从小到大排序</span></span><br><span class="line">        Arrays.sort(w);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到所有worker能承受困难下的最大利润</span></span><br><span class="line">        max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (job &lt; len) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w[i] &gt;= a[job][<span class="number">0</span>]) &#123;</span><br><span class="line">                    max = maxP[job];</span><br><span class="line">                    job++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p>利用DP的思想，dp[i]表示在worker能承受难度最大值为i时，其能获得的最大的利润。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfitAssignment</span><span class="params">(<span class="keyword">int</span>[] d, <span class="keyword">int</span>[] p, <span class="keyword">int</span>[] w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = d.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxD = <span class="number">0</span>; <span class="comment">// 最大难度值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : d) &#123;</span><br><span class="line">            maxD = Math.max(maxD, num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dp[i] 表示在难度为i时，能获得的最大利润</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[maxD + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 首先将题目给的数填充进来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[d[i]] = Math.max(dp[d[i]], p[i]); </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxP = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 可能出现难度高，但是利润小的工作，因此需要遍历再次找出特定难度下能获得的最大利润</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxD; i++) &#123;</span><br><span class="line">            maxP = Math.max(maxP, dp[i]);</span><br><span class="line">            dp[i] = maxP;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : w) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &gt; maxD) &#123;</span><br><span class="line">                sum += maxP;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += dp[n]; <span class="comment">//将所有的利润求和</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>algorithm</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/10/27/LinuxCmd/20200814-%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%AF%E5%90%A6%E5%BC%80%E6%94%BE/</url>
    <content><![CDATA[<h1 id="查看远程服务器的端口是否开放"><a href="#查看远程服务器的端口是否开放" class="headerlink" title="查看远程服务器的端口是否开放"></a>查看远程服务器的端口是否开放</h1><h2 id="1-nc（netcat）"><a href="#1-nc（netcat）" class="headerlink" title="1. nc（netcat）"></a>1. nc（netcat）</h2><p>nc是一个简单的Unix工具，使用TCP或者UDP协议读写网络连接上的数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc [OPTIONS...] [hostname] [port]</span><br></pre></td></tr></table></figure>

<p>如果未开放，则会显示请求被拒绝。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc node1 9100</span><br><span class="line"><span class="comment"># Ncat: Connection refused.</span></span><br></pre></td></tr></table></figure>

<p>如果指定端口开放，则会显示连接成功。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc node1 9100</span><br><span class="line"><span class="comment"># Ncat: Connection succeeded</span></span><br></pre></td></tr></table></figure>

<h2 id="2-telnet"><a href="#2-telnet" class="headerlink" title="2. telnet"></a>2. telnet</h2><p>命令格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">telnet [HostName or IP] [PortNumber]</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/10/27/LinuxCmd/20200814netstat/</url>
    <content><![CDATA[<h1 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h1><p>查看所有在监听的端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -ntlp</span><br></pre></td></tr></table></figure>

<p>待整理</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/10/27/LinuxCmd/%E4%BD%BF%E7%94%A8GDB%E6%9F%A5%E7%9C%8Bcore%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="2-使用GDB查看core文件"><a href="#2-使用GDB查看core文件" class="headerlink" title="2 使用GDB查看core文件"></a>2 使用GDB查看core文件</h1><p>默认编译出来的程序在出现Segmentation fault 时并没有生成core崩溃文件，可以在gcc/g++编译时增加-g选项。</p>
<p>如果仍然没有生成core文件，则可能是因为系统设置了core文件大小为0，可以通过：<code>ulimit -a</code> 查询得知。</p>
<p>执行 <code>ulimit -c unlimited</code> 命令后可以使core文件大小不受限制。此时再次运行程序应该就能在同级目录看到<code>core.XXX</code>文件了</p>
<p>使用 <code>gdb ./a.out core.XXX</code> 可以查看出错所在行信息，这样就进入了 gdb core 调试模式。</p>
<p>追踪产生segmenttation fault的位置及代码函数调用情况：</p>
<p><code>gdb&gt;bt</code></p>
<p>这样，一般就可以看到出错的代码是哪一句了，还可以打印出相应变量的数值，进行进一步分析。</p>
<p><a href="https://www.cnblogs.com/kuliuheng/p/11698378.html#_labelTop">返回目录</a></p>
<h1 id="3-使用GDB调试程序"><a href="#3-使用GDB调试程序" class="headerlink" title="3 使用GDB调试程序"></a><strong>3 使用GDB调试程序</strong></h1><p>如上述流程不能解决问题，下面可使用gdb单步调试程序。重新编译程序，编译命令中加入-g。如：</p>
<p>gcc -lm -O3 -g file.c -o file<br>之后使用gdb命令</p>
<p><code>gdb file</code><br>开始调试。</p>
<p>输入<code>start</code>使程序运行到<code>main</code>中第一行运行代码。<code>next</code>或者n为执行下一行程序，<code>until xx</code>执行到xx行，print或p可输出变量值，<code>b xx</code>用于在xx行设置断点，<code>run</code>或<code>r</code>用于执行程序至下一断点，<code>d xx</code>删除xx行断点。</p>
<p>我们可以先run一遍程序，这时它会提示出错行信息。然后<code>until</code>到出错行前5行，交替执行<code>next</code>和<code>print</code>，输出与出错行变量相关变量或指针的值。最终定位出错的根本操作在哪一行。修改之即可。</p>
]]></content>
  </entry>
  <entry>
    <title>Summary of Two Pointer</title>
    <url>/2020/11/03/LeetcodeSummary/TwoPointer/</url>
    <content><![CDATA[<h3 id="Two-pointer解决套路"><a href="#Two-pointer解决套路" class="headerlink" title="Two pointer解决套路"></a>Two pointer解决套路</h3><p>Two pointer和滑动窗口差不多，其套路一般为：</p>
<ol>
<li>一个左指针，一个右指针。其中左指针用于缩小范围，右指针用于扩大搜索范围。一般求滑动窗口的最小值都是在缩小左指针的时候取得的。</li>
<li>右指针扩展的条件时：只要当前还没有满足条件，就暴力增长，直到第一次满足条件为止。</li>
<li>左指针收缩的条件：只要当前指针的缩小还没影响窗口的可满足性，就一直暴力向左增长。一但当前指针向前移动的时候影响了窗口的可满足性，就记录下当前的窗口大小，并更新目前为止满足条件的最小窗口记录。之后，再次扩展右指针，使得窗口满足题目的条件。</li>
<li>以此类推即可。</li>
</ol>
]]></content>
      <categories>
        <category>leetcode_summary</category>
      </categories>
      <tags>
        <tag>leetcode_summary</tag>
      </tags>
  </entry>
  <entry>
    <title>C++六种内存模型</title>
    <url>/2020/10/30/Memory/Dynamic_memory_in_CPP/</url>
    <content><![CDATA[<h2 id="C-内存模型"><a href="#C-内存模型" class="headerlink" title="C++内存模型"></a>C++内存模型</h2><p>C++规定了6种访存顺序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> memory_order &#123;</span><br><span class="line">    memory_order_relaxed,</span><br><span class="line">    memory_order_consume,</span><br><span class="line">    memory_order_acquire,</span><br><span class="line">    memory_order_release,</span><br><span class="line">    memory_order_acq_rel,</span><br><span class="line">    memory_order_seq_cst</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这6种内存模型可以分为3类</p>
<ol>
<li>顺序一致性模型, memory_order_seq_cst</li>
<li>Acquire-release模型，也称为获取释放内存模型。<ul>
<li>memory_order_consume</li>
<li>memory_order_acquire</li>
<li>memory_order_release</li>
<li>memory_order_acq_rel</li>
</ul>
</li>
<li>Relax模型，即memory_order_relaxed，宽松的内存序列化模型</li>
</ol>
<h3 id="memory-order-relaxed"><a href="#memory-order-relaxed" class="headerlink" title="memory_order_relaxed"></a>memory_order_relaxed</h3><p>只保证当前操作的原子性，不考虑线程之间的同步，其它线程可以读到新值，也可以读到旧值。</p>
<h3 id="memory-order-consume"><a href="#memory-order-consume" class="headerlink" title="memory_order_consume"></a>memory_order_consume</h3><h3 id="memory-order-acquire"><a href="#memory-order-acquire" class="headerlink" title="memory_order_acquire"></a>memory_order_acquire</h3><p>acquire于内存的load操作对应，也就是读操作。设置该标志，表示在这条语句之后设置了barrier。</p>
<p>即所有后续操作的读操作必须在本条原子操作完成之后执行。</p>
<h3 id="memory-order-release"><a href="#memory-order-release" class="headerlink" title="memory_order_release"></a>memory_order_release</h3><p>release 对应于内存的 store操作，也就是写内存。设置标志，表示在这条语句之前设置了barrier。即所有之前的写操作完成之后才能执行本条原子操作。</p>
<p>该语句和memory_order_qcquire有点相似，但是如何<code>见字如面</code>呢，即如何第一眼看到便区分开来呢。我是这样区分的：</p>
<ol>
<li>acquire和release的对象都是barrier；</li>
<li>acquire即请求，请求之后，便得到了barrier，因此是在这条语句之后设置了barrier，因此后续的读(load)操作必须在本条原子操作完成之后；</li>
<li>release即释放，要想释放，必须先拥有，即该条语句之前已经拥有了barrier，因此之前的写(store)操作完成之后，才能执行本条原子操作；</li>
<li>acquire操作常用来读取数据的同步，release操作常用来写数据的同步。</li>
</ol>
<h3 id="memory-order-acq-rel"><a href="#memory-order-acq-rel" class="headerlink" title="memory_order_acq_rel"></a>memory_order_acq_rel</h3><p>对读取和写入施加acquire-release语句，无法被重排。</p>
<p>可以看见其他线程施加release语义的所有写入，同时自己的release结束后所有写入对其施加acquire语义的线程可见。</p>
<h3 id="memory-order-seq-cst"><a href="#memory-order-seq-cst" class="headerlink" title="memory_order_seq_cst"></a>memory_order_seq_cst</h3>]]></content>
      <categories>
        <category>Memory</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/10/27/Socket/2020-09-21-TCP%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0/</url>
    <content><![CDATA[<h1 id="TCP-最大连接数为28232"><a href="#TCP-最大连接数为28232" class="headerlink" title="TCP 最大连接数为28232"></a>TCP 最大连接数为28232</h1><p>Linux对外的端口分配是有一定限制的，默认不超过28232个。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/ip_local_range</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出为</span></span><br><span class="line">32768 60999</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>两个数字相减刚好为28232。如果要对其范围进行修改，可将两个数字更改为10000 65535，注意用户可用端口方位为1024~65535.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;10000 65535&quot; &gt; /proc/sys/net/ipv4/ip_local_port_range</span><br><span class="line">sysctl -p	</span><br></pre></td></tr></table></figure>

<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>快速回收端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/sysctl.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 末尾添加上</span></span><br><span class="line">net.ipv4.tcp_tw_recycle=1</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>

<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><p>系统在高并发短连接的情况下，会出现大量处于TIME_WAIT的SOCKET。</p>
<p>这里短连接是指：<strong>业务处理+传输数据的时间 远远小于 TIMEWAIT超时的时间”的连接</strong></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/10/27/Socket/20200914-socket_close_shutdown/</url>
    <content><![CDATA[<h1 id="Socket-之Close与Shutdown"><a href="#Socket-之Close与Shutdown" class="headerlink" title="Socket 之Close与Shutdown"></a>Socket 之Close与Shutdown</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol>
<li>close会释放文件句柄，而shutdown不会。</li>
<li>close把描述符的引用计数减1，仅在该计数变为0时关闭套接字。shutdown可以不管引用计数就激发TCP的正常连接终止序列，因此在多进程环境中：close()是关闭本进程的socket id，但链接还是开着的，用这个socket id的其它进程还能用这个链接，能读或写这个socket id，而shutdown执行的操作对所有进程有效。</li>
</ol>
<h2 id="Strace"><a href="#Strace" class="headerlink" title="Strace"></a>Strace</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strace ./exec</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Leetcode 986. Interval List Intersections</title>
    <url>/2020/11/04/Leetcode/986/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.com/problems/interval-list-intersections/">英文题目</a></p>
<p><a href="https://leetcode-cn.com/problems/interval-list-intersections/">中文题目</a></p>
<p>难度：中等</p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>求两组线段集合的交集。</p>
<p><strong>示例：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Input: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]</span><br><span class="line">Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]</span><br></pre></td></tr></table></figure>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>两个指针，一个指针指向线段集合A，一个指针指向线段集合B；</li>
<li>依次移动两个指针，如果发现当前两个指针之间有交集，则求交集之后放入结果中，否则，视情况移动两个指针；</li>
</ol>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] intervalIntersection(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lenA = A.length;</span><br><span class="line">        <span class="keyword">int</span> lenB = B.length;</span><br><span class="line">        </span><br><span class="line">        List&lt;Node&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> currA = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> currB = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (currA &lt; lenA &amp;&amp; currB &lt; lenB) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[currA][<span class="number">1</span>] &lt; B[currB][<span class="number">0</span>]) &#123; <span class="comment">// 没交集的情况</span></span><br><span class="line">                currA++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (B[currB][<span class="number">1</span>] &lt; A[currA][<span class="number">0</span>]) &#123; <span class="comment">// 没交集的情况</span></span><br><span class="line">                currB++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> maxL = Math.max(A[currA][<span class="number">0</span>], B[currB][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> minR = Math.min(A[currA][<span class="number">1</span>], B[currB][<span class="number">1</span>]);</span><br><span class="line">            list.add(<span class="keyword">new</span> Node(maxL, minR));</span><br><span class="line">            <span class="keyword">if</span> (A[currA][<span class="number">1</span>] == minR) currA++;</span><br><span class="line">            <span class="keyword">if</span> (B[currB][<span class="number">1</span>] == minR) currB++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> len = list.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            Node tmp = list.get(i);</span><br><span class="line">            ans[i][<span class="number">0</span>] = tmp.l;</span><br><span class="line">            ans[i][<span class="number">1</span>] = tmp.r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        Node(<span class="keyword">int</span> l_, <span class="keyword">int</span> r_) &#123;</span><br><span class="line">            <span class="keyword">this</span>.l = l_;</span><br><span class="line">            <span class="keyword">this</span>.r = r_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>SkipList in LevelDB</title>
    <url>/2020/11/05/NiceCode/142/</url>
    <content><![CDATA[<p>LevelDB中有一份非常优雅的SkipList的实现方式，这里拿过来供学习。</p>
<p>SkipList的一些特性：</p>
<ol>
<li>最底层是0层，该层最长，最高层是大层，该层最短；</li>
<li>查找的过程总是从左上至右下；</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"><span class="comment">// found in the LICENSE file. See the AUTHORS file for names of contributors.</span></span><br><span class="line"></span><br><span class="line">#ifndef STORAGE_LEVELDB_DB_SKIPLIST_H_</span><br><span class="line">#define STORAGE_LEVELDB_DB_SKIPLIST_H_</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread safety</span></span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Writes require external synchronization, most likely a mutex.</span></span><br><span class="line"><span class="comment">// Reads require a guarantee that the SkipList will not be destroyed</span></span><br><span class="line"><span class="comment">// while the read is in progress.  Apart from that, reads progress</span></span><br><span class="line"><span class="comment">// without any internal locking or synchronization.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Invariants:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// (1) Allocated nodes are never deleted until the SkipList is</span></span><br><span class="line"><span class="comment">// destroyed.  This is trivially guaranteed by the code since we</span></span><br><span class="line"><span class="comment">// never delete any skip list nodes.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// (2) The contents of a Node except for the next/prev pointers are</span></span><br><span class="line"><span class="comment">// immutable after the Node has been linked into the SkipList.</span></span><br><span class="line"><span class="comment">// Only Insert() modifies the list, and it is careful to initialize</span></span><br><span class="line"><span class="comment">// a node and use release-stores to publish the nodes in one or</span></span><br><span class="line"><span class="comment">// more lists.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ... prev vs. next pointer ordering ...</span></span><br><span class="line"></span><br><span class="line">#include &lt;atomic&gt;</span><br><span class="line">#include &lt;cassert&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;util/arena.h&quot;</span><br><span class="line">#include &quot;util/random.h&quot;</span><br><span class="line"></span><br><span class="line">namespace leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Arena</span></span>;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SkipList</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  struct Node;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Create a new SkipList object that will use &quot;cmp&quot; for comparing keys,</span></span><br><span class="line">  <span class="comment">// and will allocate memory using &quot;*arena&quot;.  Objects allocated in the arena</span></span><br><span class="line">  <span class="comment">// must remain allocated for the lifetime of the skiplist object.</span></span><br><span class="line">  <span class="function">explicit <span class="title">SkipList</span><span class="params">(Comparator cmp, Arena* arena)</span></span>;</span><br><span class="line"></span><br><span class="line">  SkipList(<span class="keyword">const</span> SkipList&amp;) = delete;</span><br><span class="line">  SkipList&amp; operator=(<span class="keyword">const</span> SkipList&amp;) = delete;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert key into the list.</span></span><br><span class="line">  <span class="comment">// REQUIRES: nothing that compares equal to key is currently in the list.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns true iff an entry that compares equal to key is in the list.</span></span><br><span class="line">  <span class="function">bool <span class="title">Contains</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Iteration over the contents of a skip list</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Initialize an iterator over the specified list.</span></span><br><span class="line">    <span class="comment">// The returned iterator is not valid.</span></span><br><span class="line">    <span class="function">explicit <span class="title">Iterator</span><span class="params">(<span class="keyword">const</span> SkipList* list)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns true iff the iterator is positioned at a valid node.</span></span><br><span class="line">    <span class="function">bool <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the key at the current position.</span></span><br><span class="line">    <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">    <span class="keyword">const</span> Key&amp; key() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Advances to the next position.</span></span><br><span class="line">    <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Advances to the previous position.</span></span><br><span class="line">    <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Advance to the first entry with a key &gt;= target</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Key&amp; target)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Position at the first entry in list.</span></span><br><span class="line">    <span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Position at the last entry in list.</span></span><br><span class="line">    <span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> SkipList* list_;</span><br><span class="line">    Node* node_;</span><br><span class="line">    <span class="comment">// Intentionally copyable</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> </span>&#123; kMaxHeight = <span class="number">12</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function">inline <span class="keyword">int</span> <span class="title">GetMaxHeight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max_height_.load(std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Node* NewNode(<span class="keyword">const</span> Key&amp; key, <span class="keyword">int</span> height);</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">RandomHeight</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">bool <span class="title">Equal</span><span class="params">(<span class="keyword">const</span> Key&amp; a, <span class="keyword">const</span> Key&amp; b)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (compare_(a, b) == <span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return true if key is greater than the data stored in &quot;n&quot;</span></span><br><span class="line">  <span class="function">bool <span class="title">KeyIsAfterNode</span><span class="params">(<span class="keyword">const</span> Key&amp; key, Node* n)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the earliest node that comes at or after key.</span></span><br><span class="line">  <span class="comment">// Return nullptr if there is no such node.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// If prev is non-null, fills prev[level] with pointer to previous</span></span><br><span class="line">  <span class="comment">// node at &quot;level&quot; for every level in [0..max_height_-1].</span></span><br><span class="line">  Node* FindGreaterOrEqual(<span class="keyword">const</span> Key&amp; key, Node** prev) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the latest node with a key &lt; key.</span></span><br><span class="line">  <span class="comment">// Return head_ if there is no such node.</span></span><br><span class="line">  Node* FindLessThan(<span class="keyword">const</span> Key&amp; key) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the last node in the list.</span></span><br><span class="line">  <span class="comment">// Return head_ if list is empty.</span></span><br><span class="line">  Node* FindLast() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Immutable after construction</span></span><br><span class="line">  Comparator <span class="keyword">const</span> compare_;</span><br><span class="line">  Arena* <span class="keyword">const</span> arena_;  <span class="comment">// Arena used for allocations of nodes</span></span><br><span class="line"></span><br><span class="line">  Node* <span class="keyword">const</span> head_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Modified only by Insert().  Read racily by readers, but stale</span></span><br><span class="line">  <span class="comment">// values are ok.</span></span><br><span class="line">  std::atomic&lt;<span class="keyword">int</span>&gt; max_height_;  <span class="comment">// Height of the entire list</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read/written only by Insert().</span></span><br><span class="line">  Random rnd_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implementation details follow</span></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">struct SkipList&lt;Key, Comparator&gt;::Node &#123;</span><br><span class="line">  <span class="function">explicit <span class="title">Node</span><span class="params">(<span class="keyword">const</span> Key&amp; k)</span> : <span class="title">key</span><span class="params">(k)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  Key <span class="keyword">const</span> key;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Accessors/mutators for links.  Wrapped in methods so we can</span></span><br><span class="line">  <span class="comment">// add the appropriate barriers as necessary.</span></span><br><span class="line">  Node* Next(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Use an &#x27;acquire load&#x27; so that we observe a fully initialized</span></span><br><span class="line">    <span class="comment">// version of the returned Node.</span></span><br><span class="line">    <span class="keyword">return</span> next_[n].load(std::memory_order_acquire);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetNext</span><span class="params">(<span class="keyword">int</span> n, Node* x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Use a &#x27;release store&#x27; so that anybody who reads through this</span></span><br><span class="line">    <span class="comment">// pointer observes a fully initialized version of the inserted node.</span></span><br><span class="line">    next_[n].store(x, std::memory_order_release);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No-barrier variants that can be safely used in a few locations.</span></span><br><span class="line">  Node* NoBarrier_Next(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> next_[n].load(std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">NoBarrier_SetNext</span><span class="params">(<span class="keyword">int</span> n, Node* x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">    next_[n].store(x, std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Array of length equal to the node height.  next_[0] is lowest level link.</span></span><br><span class="line">  std::atomic&lt;Node*&gt; next_[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">typename SkipList&lt;Key, Comparator&gt;::Node* SkipList&lt;Key, Comparator&gt;::NewNode(</span><br><span class="line">    <span class="keyword">const</span> Key&amp; key, <span class="keyword">int</span> height) &#123;</span><br><span class="line">  <span class="keyword">char</span>* <span class="keyword">const</span> node_memory = arena_-&gt;AllocateAligned(</span><br><span class="line">      sizeof(Node) + sizeof(std::atomic&lt;Node*&gt;) * (height - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> (node_memory) Node(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">inline SkipList&lt;Key, Comparator&gt;::Iterator::Iterator(const SkipList* list) &#123;</span><br><span class="line">  list_ = list;</span><br><span class="line">  node_ = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">inline bool SkipList&lt;Key, Comparator&gt;::Iterator::Valid() const &#123;</span><br><span class="line">  <span class="keyword">return</span> node_ != nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">inline const Key&amp; SkipList&lt;Key, Comparator&gt;::Iterator::key() const &#123;</span><br><span class="line">  <span class="keyword">assert</span>(Valid());</span><br><span class="line">  <span class="keyword">return</span> node_-&gt;key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">inline void SkipList&lt;Key, Comparator&gt;::Iterator::Next() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(Valid());</span><br><span class="line">  node_ = node_-&gt;Next(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">inline void SkipList&lt;Key, Comparator&gt;::Iterator::Prev() &#123;</span><br><span class="line">  <span class="comment">// Instead of using explicit &quot;prev&quot; links, we just search for the</span></span><br><span class="line">  <span class="comment">// last node that falls before key.</span></span><br><span class="line">  <span class="keyword">assert</span>(Valid());</span><br><span class="line">  node_ = list_-&gt;FindLessThan(node_-&gt;key);</span><br><span class="line">  <span class="keyword">if</span> (node_ == list_-&gt;head_) &#123;</span><br><span class="line">    node_ = nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">inline void SkipList&lt;Key, Comparator&gt;::Iterator::Seek(const Key&amp; target) &#123;</span><br><span class="line">  node_ = list_-&gt;FindGreaterOrEqual(target, nullptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">inline void SkipList&lt;Key, Comparator&gt;::Iterator::SeekToFirst() &#123;</span><br><span class="line">  node_ = list_-&gt;head_-&gt;Next(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">inline void SkipList&lt;Key, Comparator&gt;::Iterator::SeekToLast() &#123;</span><br><span class="line">  node_ = list_-&gt;FindLast();</span><br><span class="line">  <span class="keyword">if</span> (node_ == list_-&gt;head_) &#123;</span><br><span class="line">    node_ = nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">int SkipList&lt;Key, Comparator&gt;::RandomHeight() &#123;</span><br><span class="line">  <span class="comment">// Increase height with probability 1 in kBranching</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> unsigned <span class="keyword">int</span> kBranching = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">int</span> height = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// TODO lwl，这里不会使得kMaxHeight超过最大值么</span></span><br><span class="line">  <span class="keyword">while</span> (height &lt; kMaxHeight &amp;&amp; ((rnd_.Next() % kBranching) == <span class="number">0</span>)) &#123;</span><br><span class="line">    height++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">assert</span>(height &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">assert</span>(height &lt;= kMaxHeight);</span><br><span class="line">  <span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">bool SkipList&lt;Key, Comparator&gt;::KeyIsAfterNode(const Key&amp; key, Node* n) const &#123;</span><br><span class="line">  <span class="comment">// null n is considered infinite</span></span><br><span class="line">  <span class="keyword">return</span> (n != nullptr) &amp;&amp; (compare_(n-&gt;key, key) &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">typename SkipList&lt;Key, Comparator&gt;::Node*</span><br><span class="line">SkipList&lt;Key, Comparator&gt;::FindGreaterOrEqual(<span class="keyword">const</span> Key&amp; key,</span><br><span class="line">                                              Node** prev) <span class="keyword">const</span> &#123;</span><br><span class="line">  Node* x = head_;</span><br><span class="line">  <span class="keyword">int</span> level = GetMaxHeight() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    Node* next = x-&gt;Next(level);</span><br><span class="line">    <span class="keyword">if</span> (KeyIsAfterNode(key, next)) &#123;</span><br><span class="line">      <span class="comment">// Keep searching in this list</span></span><br><span class="line">      x = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (prev != nullptr) prev[level] = x;</span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Switch to next list</span></span><br><span class="line">        level--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">typename SkipList&lt;Key, Comparator&gt;::Node*</span><br><span class="line">SkipList&lt;Key, Comparator&gt;::FindLessThan(<span class="keyword">const</span> Key&amp; key) <span class="keyword">const</span> &#123;</span><br><span class="line">  Node* x = head_;</span><br><span class="line">  <span class="keyword">int</span> level = GetMaxHeight() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(x == head_ || compare_(x-&gt;key, key) &lt; <span class="number">0</span>);</span><br><span class="line">    Node* next = x-&gt;Next(level);</span><br><span class="line">    <span class="keyword">if</span> (next == nullptr || compare_(next-&gt;key, key) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Switch to next list</span></span><br><span class="line">        level--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">typename SkipList&lt;Key, Comparator&gt;::Node* SkipList&lt;Key, Comparator&gt;::FindLast()</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">  Node* x = head_;</span><br><span class="line">  <span class="keyword">int</span> level = GetMaxHeight() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    Node* next = x-&gt;Next(level);</span><br><span class="line">    <span class="keyword">if</span> (next == nullptr) &#123;</span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Switch to next list</span></span><br><span class="line">        level--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">SkipList&lt;Key, Comparator&gt;::SkipList(Comparator cmp, Arena* arena)</span><br><span class="line">    : compare_(cmp),</span><br><span class="line">      arena_(arena),</span><br><span class="line">      head_(NewNode(<span class="number">0</span> <span class="comment">/* any key will do */</span>, kMaxHeight)),</span><br><span class="line">      max_height_(<span class="number">1</span>),</span><br><span class="line">      rnd_(<span class="number">0xdeadbeef</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kMaxHeight; i++) &#123;</span><br><span class="line">    head_-&gt;SetNext(i, nullptr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">void SkipList&lt;Key, Comparator&gt;::Insert(const Key&amp; key) &#123;</span><br><span class="line">  <span class="comment">// TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()</span></span><br><span class="line">  <span class="comment">// here since Insert() is externally synchronized.</span></span><br><span class="line">  Node* prev[kMaxHeight];</span><br><span class="line">  Node* x = FindGreaterOrEqual(key, prev);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Our data structure does not allow duplicate insertion</span></span><br><span class="line">  <span class="keyword">assert</span>(x == nullptr || !Equal(key, x-&gt;key));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> height = RandomHeight();</span><br><span class="line">  <span class="keyword">if</span> (height &gt; GetMaxHeight()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = GetMaxHeight(); i &lt; height; i++) &#123;</span><br><span class="line">      prev[i] = head_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// It is ok to mutate max_height_ without any synchronization</span></span><br><span class="line">    <span class="comment">// with concurrent readers.  A concurrent reader that observes</span></span><br><span class="line">    <span class="comment">// the new value of max_height_ will see either the old value of</span></span><br><span class="line">    <span class="comment">// new level pointers from head_ (nullptr), or a new value set in</span></span><br><span class="line">    <span class="comment">// the loop below.  In the former case the reader will</span></span><br><span class="line">    <span class="comment">// immediately drop to the next level since nullptr sorts after all</span></span><br><span class="line">    <span class="comment">// keys.  In the latter case the reader will use the new node.</span></span><br><span class="line">    max_height_.store(height, std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  x = NewNode(key, height);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">    <span class="comment">// NoBarrier_SetNext() suffices since we will add a barrier when</span></span><br><span class="line">    <span class="comment">// we publish a pointer to &quot;x&quot; in prev[i].</span></span><br><span class="line">    x-&gt;NoBarrier_SetNext(i, prev[i]-&gt;NoBarrier_Next(i));</span><br><span class="line">    prev[i]-&gt;SetNext(i, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">bool SkipList&lt;Key, Comparator&gt;::Contains(const Key&amp; key) const &#123;</span><br><span class="line">  Node* x = FindGreaterOrEqual(key, nullptr);</span><br><span class="line">  <span class="keyword">if</span> (x != nullptr &amp;&amp; Equal(key, x-&gt;key)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br><span class="line"></span><br><span class="line">#endif  // STORAGE_LEVELDB_DB_SKIPLIST_H_</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol>
<li>两个指针：慢指针和快指针，慢指针一次走一步，快指针一次走两步。如果两个指针相遇，就是有环，如果两个指针不相遇，就是没环。</li>
<li>将快指针放回链表起点，慢指针位置不变，两者都以慢速遍历指针，再次相遇的点即为环的起点。</li>
</ol>
]]></content>
      <categories>
        <category>nicecode</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>link list</tag>
      </tags>
  </entry>
</search>
