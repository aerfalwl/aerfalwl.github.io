<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo+github搭建个人博客</title>
    <url>/2020/10/27/Config/hexo_config/</url>
    <content><![CDATA[<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>在电脑上搭建博客</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init xxx.github.io</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p>修改配置文件_config.yml，添加如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:xxx/youname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li><p>提交代码至仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean # 清空缓存</span><br><span class="line">hexo generate # 生成静态文件</span><br><span class="line">hexo deploy # 部署至远程仓库</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建分支用于保存原配置文件和原博客，因为hexo只会将它生成的静态文件上传，而不会上传相关配置文件和原markdown文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git checkout -b meta</span><br></pre></td></tr></table></figure>
</li>
<li><p>之后若有修改，则依次执行如下命令，<strong>注意顺序，且在meta分支执行</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo c &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;change&quot; &amp;&amp; git push origin meta</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="不同设备同步"><a href="#不同设备同步" class="headerlink" title="不同设备同步"></a>不同设备同步</h2><p>执行如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone -b meta https://github.com/XXX/xxx.git</span><br><span class="line">cd xxx.github.io</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 之后若有修改，则执行</span></span><br><span class="line">hexo c &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;change&quot; &amp;&amp; git push origin meta</span><br></pre></td></tr></table></figure>



<p>如果在别的设备上提交了，别忘了在提交之后先pull meta哈。</p>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>安装部署</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 插入图片</title>
    <url>/2020/10/28/Config/hexo_with_image/</url>
    <content><![CDATA[<p>本文主要介绍按照相对路径在hexo中插入图片的方法。</p>
<h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><ol>
<li><p>安装插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件_config.yml，将如下选项该为true：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">post_asset_foler: true</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改文件内容：node_modules/hexo-asset-image/index.js为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">        <span class="keyword">var</span> link = data.permalink;</span><br><span class="line">    <span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">    <span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">        xmlMode: <span class="literal">false</span>,</span><br><span class="line">        lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">        decodeEntities: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">            <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">            <span class="keyword">var</span> src = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">               !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">              <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">              <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">              <span class="keyword">var</span> linkArray = link.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">var</span> srcArray = src.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">                srcArray.shift();</span><br><span class="line">              src = srcArray.join(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">              $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class="line">              <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="built_in">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>至此配置完成，之后若hexo new post photo，则会在source/_posts文件夹下生成photo.md和photo文件夹，用户也可以在手动创建md文件的时候，创建对应名字的文件夹。</p>
</li>
<li><p>插入图片，假设photo文件夹下有如下文件图片：test.png，则用户可以在md文件中按照如下两种方式引用该图片。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">![描述](test.png) # </span><br><span class="line">![描述](photo/test.png) # 该种方式在Typora中可以直接显示图片，推荐该种方式。</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>安装部署</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/10/27/Kafka/2020-10-04-Kafka%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="初识Kafka"><a href="#初识Kafka" class="headerlink" title="初识Kafka"></a>初识Kafka</h1><h2 id="Feture"><a href="#Feture" class="headerlink" title="Feture"></a>Feture</h2><ol>
<li>消息保留：是Kafka的一个重要特性，Broker默认的消息保留策略是，要不保留一段时间，要不保留到消息到达一定的字节数。当消息总量达到这些上限时，旧消息就被过期并被删除。紧凑型日志，只有最后一个带有特定键的消息会被保留，因为，人们只关心最后时刻发生的改变。</li>
<li>Kafka的消息复制机制只能在单个集群里进行，不能再多个集群之间进行。但是它提供一个叫做MirrorMaker的工具，可以用来实现集群之间的消息赋值。</li>
<li>亚秒级的消息延迟。</li>
</ol>
<h2 id="Kafka适用场景"><a href="#Kafka适用场景" class="headerlink" title="Kafka适用场景"></a>Kafka适用场景</h2><ol>
<li>多个生产者</li>
<li>多个消费者</li>
</ol>
<h2 id="Kafka的使用场景"><a href="#Kafka的使用场景" class="headerlink" title="Kafka的使用场景"></a>Kafka的使用场景</h2><ol>
<li>活动跟踪，比如：用户网页访问次数和点击量。</li>
<li>传递消息，比如向用户发通知。使用公共组件的好处：在公共组件上做一些有趣的转换，比如把多个消息聚合成一个单独的通知，而这些工作是无法在其它地方完成的。</li>
<li>度量指标和日志记录。</li>
<li>提交日志。</li>
<li>流处理。</li>
</ol>
<h1 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h1><p><img src="/2020/10/27/Kafka/2020-10-04-Kafka%E7%AE%80%E4%BB%8B/Users\lwl\AppData\Roaming\Typora\typora-user-images\image-20201004160030424.png" alt="Kafka生产者组件图"></p>
<h1 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h1><p><img src="/2020/10/27/Kafka/2020-10-04-Kafka%E7%AE%80%E4%BB%8B/Users\lwl\AppData\Roaming\Typora\typora-user-images\image-20201005131625839.png" alt="消费者组群"></p>
<p>如果消费者组群中消费者的数量多于主题分区的个数，则会有部分消费者被闲置，不会接收到任何消息。</p>
<h1 id="深入Kafka"><a href="#深入Kafka" class="headerlink" title="深入Kafka"></a>深入Kafka</h1><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><ol>
<li>Controller本质上也是一个broker，除了一般的broker的功能之外，它还负责首领的选举。集群中第一启动的Broker会在Zookeeper里创建一个临时节点/controller让自己成为控制器。</li>
<li>Controller负责在节点加入或者离开集群时进行分区首领的选举，并且使用epoch来避免脑裂，脑裂是指两个节点同时任务自己是当前的控制器。</li>
</ol>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><ol>
<li>Kafka是一个可分区的，可复制的提交日志服务。</li>
<li>副本<ol>
<li>首领副本：每个分区有且仅有一个首领副本，为了保证一致性，所有生产者请求和消费者请求都会经过这个副本</li>
<li>跟随者副本：首领以外的副本都是跟随者副本，跟随者副本不处理来自客户端的的请求，它们唯一要做的就是从首领那里复制消息，保持与首领一致的状态，如果首领发生崩溃，则跟随者会被提升为新首领。</li>
</ol>
</li>
</ol>
<h1 id="Broker处理请求的方式"><a href="#Broker处理请求的方式" class="headerlink" title="Broker处理请求的方式"></a>Broker处理请求的方式</h1><p><img src="/2020/10/27/Kafka/2020-10-04-Kafka%E7%AE%80%E4%BB%8B/Users\lwl\AppData\Roaming\Typora\typora-user-images\image-20201005164403640.png" alt="image-20201005164403640"></p>
<p><img src="/2020/10/27/Kafka/2020-10-04-Kafka%E7%AE%80%E4%BB%8B/Users\lwl\AppData\Roaming\Typora\typora-user-images\image-20201005164434878.png" alt="image-20201005164434878"></p>
<p>Kafka有用其它语言实现的客户端，如C, Python， Go语言等。Kafka网站上有它们的完整清单，这些客户端就是使用二进制协议与broker通信的。</p>
<h2 id="分区分配"><a href="#分区分配" class="headerlink" title="分区分配"></a>分区分配</h2><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><ol>
<li>Kafka将分区分为若干个片段。默认情况下，每个片段包含1GB或者一周的数据，以较小的那个为准。</li>
</ol>
<h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3><ol>
<li><p>我们把Kafka的消息和偏移量保存在文件中。</p>
</li>
<li><p>键、值、偏移量、消息大小、校验和、消息格式版本号、压缩算法和时间戳。时间戳可以是生产者发送消息的时间，也可以是消息到达broker的时间，这个时间是可配置的。</p>
</li>
<li><p>可以使用工具DUmpLogSegment来查看片段的内容，它可以显示每个消息的偏移量、校验和、魔术数、消息大小和压缩算法。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-run-class.sh kafka.tools.DumpLogSegments</span><br></pre></td></tr></table></figure>

<h2 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h2><ol>
<li>P84页，103</li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>hexo 博客被google收录</title>
    <url>/2020/10/27/Config/hexo_google_site/</url>
    <content><![CDATA[<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>生成站点地图</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件_config.yml，添加如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">urlgoogle: https://xxx.github.io/ </span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改_config.xml，设置url为你的github.io</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">url: https://xxx.github.io</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>添加站点，登录<a href="https://www.google.com/webmasters/">Google 网站站长</a>，进入<code>Search Console</code>，进入如下页面</p>
<p><img src="/2020/10/27/Config/hexo_google_site/first.png" alt="首页"></p>
</li>
<li><p>选择网址前缀，输入<a href="https://xxx.github.io/">https://xxx.github.io</a></p>
</li>
<li><p>之后，下载Google验证文件，放在<code>theme/next/source</code>目录中。</p>
</li>
<li><p>生成robots.xt文件，在hexo的source目录下，放入如下内容：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /home/</span><br><span class="line">Allow: /archives/</span><br><span class="line">Allow: /categories/</span><br><span class="line">Allow: /tags/</span><br><span class="line"></span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line"></span><br><span class="line">Sitemap: https://aerfalwl.github.io/sitemap.xml</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="8">
<li><p>重新生成和部署</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署完成之后，进行验证即可，若操作无误，便会验证成功。</p>
</li>
<li><p>添加站点地图：</p>
<p><img src="/2020/10/27/Config/hexo_google_site/add_sitemap.png" alt="添加站点地图"></p>
</li>
<li><p>为了加快Google扫描网站的速度，可以通过以下方式建立索引：</p>
<ul>
<li>在浏览器中输入<a href="https://www.google.com/ping?sitemap=https://aerfalwl.github.io/sitemap.xml%E8%A6%81%E6%B1%82Google%E7%BB%99%E7%BD%91%E7%AB%99%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%EF%BC%9B">https://www.google.com/ping?sitemap=https://aerfalwl.github.io/sitemap.xml要求Google给网站建立索引；</a></li>
</ul>
</li>
<li><p>等待几分钟，在Google中搜索site:aerfalwl.github.io检验是否能看到网站内容。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>安装部署</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/10/27/Kafka/2020-10-04-%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<h2 id="Kafka与Broker不同"><a href="#Kafka与Broker不同" class="headerlink" title="Kafka与Broker不同"></a>Kafka与Broker不同</h2><ol>
<li>消息定期清理。各个主题设置单独的保留规则，以便满足不同消费者的需求，各个主题可以保留不同数量的消息。</li>
<li>多个消费者可以重复消费同一条消息。</li>
<li>Kafka可以在如下情况下自动创建主题：当一个生产者开始往主题写入消息时，当一个消费者开始从主题读取消息时，当任意一个客户端向主题发送元数据请求时。</li>
<li>客户端为了优化网络和磁盘空间，会对消息进行压缩，服务器需要对消息进行批量解压，设置偏移量，然后重新进行批量压缩，再保存在磁盘上。</li>
<li>kafka允许主题的名字为null, Refactor不允许。</li>
<li>Kafka的Consumer属于消费者组群。</li>
<li>消费者组群之间允许重复消费消息。<img src="/2020/10/27/Kafka/2020-10-04-%E6%AF%94%E8%BE%83/Users\lwl\AppData\Roaming\Typora\typora-user-images\image-20201005132432782.png" alt="image-20201005132432782"></li>
<li>Kafka中所有broker都缓存了元数据，因此，客户端可以向任何一个broker发送<strong>元数据请求</strong>，并得到客户端所感兴趣的主题所在分区，每个分区都包含哪些副本，以及哪个副本是首领。因此，consumer需要时不时的向broker发送元数据请求来刷新本地缓存的信息。</li>
<li></li>
</ol>
<h1 id="Kafka的一些Feture"><a href="#Kafka的一些Feture" class="headerlink" title="Kafka的一些Feture"></a>Kafka的一些Feture</h1><ol>
<li><p>Kafka的所有消息保存在磁盘上，存放这些日志片段的目录是通过log.dirs指定的，它是一组用逗号分割的本地文件系统路径。如果指定了多个路径，那么Broker会根据最少使用原则，把统一分区的日志片段保存在同一路径下。要注意：Broker会往拥有最少数据分区的路径新增分区，而不是往拥有最少磁盘空间的路径新增分区。</p>
</li>
<li><p>提供二进制连接协议，即用户直接向Kafka网络端口发送适当的字节序列，就可以实现从Kafka读取消息或往Kafka写消息</p>
</li>
<li><p>用户可以从指定偏移量开始读数据，例如seekToBeginning和seekToEnd</p>
</li>
<li><p>消费者既可以依赖于组群存在，也可以独立存在。</p>
</li>
<li><p>消费者请求数据的时候，可以设置broker返回数据的上限，也可以设置下限。这样可以在主题消息流量不是很大的情况下，减少CPU和网络开销。</p>
</li>
<li><p>日志压缩是Kafka的一个高级特性，因为有了这个特性，Kafka可以用来长时间保存数据。</p>
</li>
</ol>
<h2 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h2><ol>
<li>Kafka也需人为设置BrokerID,需要使用者自己保证该ID是唯一的，如果两个broker使用相同的BrokerID，则第二个broker就无法启动。在Broker启动时，它通过创建临时节点把自己的ID注册到Zookeeper。Kafka组件订阅Zookeeper的/brokers/ids路径（broker在Zookeeper上的注册路径），当有broker加入集群或者退出集群时，这些组件就能获得通知。</li>
</ol>
<h1 id="Refactor一些可以改进的地方"><a href="#Refactor一些可以改进的地方" class="headerlink" title="Refactor一些可以改进的地方"></a>Refactor一些可以改进的地方</h1><ol>
<li>发送消息长度超过MESSAGE_LENGTH时，返回错误码；</li>
<li>Consumer请求的topic不在此broker上，返回相关错误码；</li>
</ol>
<h1 id="日志维护"><a href="#日志维护" class="headerlink" title="日志维护"></a>日志维护</h1><h2 id="小收获"><a href="#小收获" class="headerlink" title="小收获"></a>小收获</h2><ol>
<li>除了设置socket 外，还需要设置TCP soc ke t 的读写缓冲区，它们的参数分别是net.i.pv4.tcp_wmem和net . i.pv4 . tc p_ wmem 。这些参数的值由3 个整数组成，它们使用空格分隔，分别表示最小值、默认值和最大值。最大值不能大于net.core.wmem_max可以和net.core.rmem_max指定的大小。例如，“4096 65536 204800。”表示最小值是4KB、默认值是64KB、最大值是2MB 。根据Kafka 服务器接收流量的实际情况，可能需要设置更高的最大值，为网络连接提供更大的缓冲空间。还有其他一些有用的网络参数。例如， 把net.ipv4.tcp_window_scaling 设为l ，启用TCP时间窗扩展，可以提升客户端传输数据的效率，传输的数据可以在服务器端进行缓冲。把net.1.pv4.tcp_max_syn_backlog 设为比默认值1024 更大的值，可以接受更多的井发连接, 把net.core.netdev_max_backlog 设为比默认值1000 更大的值，有助于应对网络流量的爆发，特别是在使用千兆网络的情况下，允许更多的数据包排队等待内核处理。</li>
<li></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/10/27/Filesystem/ZFS/</url>
    <content><![CDATA[<h2 id="Introduction-to-the-Kernel"><a href="#Introduction-to-the-Kernel" class="headerlink" title="Introduction to the Kernel"></a>Introduction to the Kernel</h2><ol>
<li>参考书籍The Design and Implementation of the FreeBSD Operating System, 2nd<br>Edition</li>
</ol>
<h1 id="Introduction-to-the-Zettabyte-Filesystem"><a href="#Introduction-to-the-Zettabyte-Filesystem" class="headerlink" title="Introduction to the Zettabyte Filesystem"></a>Introduction to the Zettabyte Filesystem</h1><ol>
<li>开始于Solaries。</li>
<li>Solaris是Sun Microsystem开发的一个Unix版本的操作系统；<ul>
<li>它是以下两种操作系统的合并版：SunOs和System V4</li>
</ul>
</li>
<li>Sun需要解决的问题是：传统的操作系统在处理大数据的时候，显现出了很大的缺点，因为大数据使得系统需要大量的磁盘。</li>
<li>为解决以上问题，Sun写了ZFS:<ul>
<li>Log Structured Filesystem，由Berkeley开发，展现出了它处理大问题大数据的一些优势</li>
<li>文件系统不可重复写的特性，给了它很多比较好的特性。</li>
</ul>
</li>
</ol>
<h1 id="ZFS的演变过程"><a href="#ZFS的演变过程" class="headerlink" title="ZFS的演变过程"></a>ZFS的演变过程</h1><ol>
<li>首先出现于OpenSolaris,  该操作系统是一款Solaris开源的操作系统，包括核心科技：ZFS和DTrace</li>
<li>随后，ZFS出现在了FreeBSD（一款Unix操作系统）中；</li>
<li>之后，Sun被Oracle收购，但是Larry Ellison不是一个开源爱好者，他不同意ZFS继续开源，但是已经开源的早期版本还在流传；</li>
<li>于是一些公司继续开发并维护OpenSolaris，并且将他作为一个开源项目；</li>
<li>一些组件变得很流行，像ZFS；</li>
<li>最后ZFS变为单独的OpenZFS项目；</li>
<li>当前开发OpenZFS的主要有四个组，它们每个月都有一次会议来协同工作：<ul>
<li>致力于OpenSolaris开发的组；</li>
<li>FressBSD开发者；</li>
<li>致力于将ZFS嵌入到Linux内核的Lawrence Livermore National Laboratory</li>
<li>致力于将ZFS嵌入到MacOs和Windows的Jorgen Lundman</li>
</ul>
</li>
<li>Sun Community Development License与GNU Public License不兼容：<ul>
<li>ZFS代码不能嵌入到Linux内核中；</li>
<li>所有将ZFS带入嵌入到Linux内核的人不能使用GPL interfaces（GPL Interface是Linux的一个特性，该特性说明只有GPL的代码之间才能相互使用和修改）</li>
<li>ZFS只能通过FUSE(用户态空间文件系统， Filesystem in Userspace)访问Linux Kernel。</li>
</ul>
</li>
<li>在2016年，Ubuntu开源了一版在Kernel态的ZFS，它没有使用GPL interfaces，因此，自己额外开发了一些函数。当前，Canonical（开发Ubuntu的公司）还没被起诉，更多详情访问<a href="https://wiki.ubuntu.com/ZFS">https://wiki.ubuntu.com/ZFS</a></li>
<li>当前，OpenZFS代码已经能在大多数Linux系统中配置使用。</li>
</ol>
<p>ZFS相关资料：<a href="https://openzfs.org/wiki/Main_Page">https://openzfs.org/wiki/Main_Page</a></p>
<p>Github网址：<a href="https://github.com/openzfs/zfs">https://github.com/openzfs/zfs</a></p>
<h1 id="Kernel-I-O-Structure"><a href="#Kernel-I-O-Structure" class="headerlink" title="Kernel I/O Structure"></a>Kernel I/O Structure</h1><ol>
<li>关于kernel的系统调用：<ul>
<li>一切在硬件和系统调用之间的都是操作系统(everything between this and the hardware is the operating system)。</li>
<li>当我们和subsystem进行交互时，其实是在和file descriptor、socket、kqueue交互</li>
</ul>
</li>
</ol>
<p><img src="/2020/10/27/Filesystem/ZFS/Users\CCDC\AppData\Roaming\Typora\typora-user-images\image-20201014101848952.png" alt="image-20201014101848952"></p>
<h1 id="FileSystem-Consistency"><a href="#FileSystem-Consistency" class="headerlink" title="FileSystem Consistency"></a>FileSystem Consistency</h1><ol>
<li>必须维护一些元数据信息：directories, inodes, bitmaps</li>
<li>维护元数据的一些规则：<ul>
<li>在一个结构被初始化之前不要指向它</li>
<li>在将一个对象的所有指针置为空之前，不要使新指针指向它</li>
<li>在新指针被设置之前，不要讲老指针设置为一个可用的资源(例如，rename foo to bar，则在将foo的旧指针指向bar之后，再删除老的foo)</li>
</ul>
</li>
</ol>
<h1 id="Keeping-Metadata-Consistent"><a href="#Keeping-Metadata-Consistent" class="headerlink" title="Keeping Metadata Consistent"></a>Keeping Metadata Consistent</h1><p>实现一致性的三种方法：</p>
<ol>
<li>同步写</li>
<li>使用非易失性RAM</li>
<li>原子更新(journaling and logging)</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Leetcode 1234. Replace the Substring for Balanced String</title>
    <url>/2020/10/29/Leetcode/1234/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.com/problems/replace-the-substring-for-balanced-string/">英文题目</a></p>
<p><a href="https://leetcode-cn.com/problems/replace-the-substring-for-balanced-string/">中文题目</a></p>
<p>难度：中等</p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>说明：题目来自leetcode中文官网</p>
<p>有一个只含有 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符，且长度为 n 的字符串。</p>
<p>假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。</p>
<p>给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。</p>
<p>你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。</p>
<p>请返回待替换子串的最小可能长度。</p>
<p>如果原字符串自身就是一个平衡字符串，则返回 0。</p>
<p><strong>示例：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;QWER&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：s 已经是平衡的了。</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">输入：s = &quot;QQWE&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：我们需要把一个 &#x27;Q&#x27; 替换成 &#x27;R&#x27;，这样得到的 &quot;RQWE&quot; (或 &quot;QRWE&quot;) 是平衡的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------</span><br><span class="line">输入：s = &quot;QQQW&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：我们可以把前面的 &quot;QQ&quot; 替换成 &quot;ER&quot;。</span><br><span class="line"></span><br><span class="line">-------------</span><br><span class="line">输入：s = &quot;QQQQ&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：我们可以替换后 3 个 &#x27;Q&#x27;，使 s = &quot;QWER&quot;。</span><br></pre></td></tr></table></figure>



<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决，核心思路见代码：</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> e = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> q = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> r = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">balancedString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span> || (len % <span class="number">4</span> != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> e = <span class="number">0</span>, w = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">                e++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">                w++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                q++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// t为target的简写，t是每个字符的目标个数</span></span><br><span class="line">        <span class="keyword">int</span> t = len / <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span> (e == w &amp;&amp; w == r &amp;&amp; r == q) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 以下四行的n为need的简写，算出其离目标的距离即该字符需要变换的个数</span></span><br><span class="line">        <span class="comment">// 需要注意的是，我们只计算大于目标的字符距离目标的个数，因为变换是相互的</span></span><br><span class="line">        <span class="comment">// 你也可以只计算小于目标的字符距离目标的个数</span></span><br><span class="line">        <span class="keyword">int</span> ne = (e &lt;= t) ? <span class="number">0</span> : e - t;</span><br><span class="line">        <span class="keyword">int</span> nw = (w &lt;= t) ? <span class="number">0</span> : w - t;</span><br><span class="line">        <span class="keyword">int</span> nq = (q &lt;= t) ? <span class="number">0</span> : q - t;</span><br><span class="line">        <span class="keyword">int</span> nr = (r &lt;= t) ? <span class="number">0</span> : r - t;</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = len;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 以下声明中，c为current的简写</span></span><br><span class="line">        <span class="comment">// 下面四个变量代表在left和right指针区间内，各个字符的个数</span></span><br><span class="line">        <span class="keyword">int</span> cq = <span class="number">0</span>, cw = <span class="number">0</span>, ce = <span class="number">0</span>, cr = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                cq++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">                cw ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">                ce++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                cr++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果当前的指针范围内各个字符需要变换的个数都满足需求，则我们开始</span></span><br><span class="line">            <span class="comment">// 保存结果并缩小指针区间</span></span><br><span class="line">            <span class="keyword">while</span> (cq &gt;= nq &amp;&amp; cw &gt;= nw &amp;&amp; ce &gt;= ne &amp;&amp; cr &gt;= nr) &#123;</span><br><span class="line">                ans = Math.min(ans, right - left + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">char</span> leftC = s.charAt(left);</span><br><span class="line">                <span class="keyword">if</span> (leftC == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                    cq--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftC == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">                    cw--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftC == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">                    ce--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftC == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                    cr--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 否则继续增大指针范围</span></span><br><span class="line">            right++;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 142. Linked List Cycle II</title>
    <url>/2020/11/01/Leetcode/142/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.com/problems/linked-list-cycle-ii/">英文题目</a></p>
<p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">中文题目</a></p>
<p>难度：中等</p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>简单来说，就是判断一个链表是否有环，如果有的话，返回环的起点。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决。该问题可以拆解为两个子问题：</p>
<h4 id="如何判断一个链表是否有环"><a href="#如何判断一个链表是否有环" class="headerlink" title="如何判断一个链表是否有环"></a>如何判断一个链表是否有环</h4><p>这个问题比较简单，我们设置一快一慢两个指针，快指针每次走一步，慢指针每次走两步，则如果时间充裕，两个指针一定会相遇。</p>
<p>该问题类似于小学题目中的追击问题：操场上两个同学的跑步，一个同学的速度是<code>x</code>，另一个同学的速度是<code>y</code>，假设<code>x&gt;y</code>，则最快多长时间两个人可以相遇？答案是<code>s/(x-y)</code>，且初次相遇时两者路程差一定是<code>S</code>。判断链表有环时，其实不能完全套用这个问题，因为两个人跑步时，操场上所有的点都是它们可以相遇的点，但是链表问题中，环上只有几个点可以是它们相遇的点，因此，初次相遇时，两者的路程差不一定是<code>S</code>，而是可能是<code>nS</code>，但是可以证明它们一定是可以相遇的。</p>
<h4 id="如何判断环的起点"><a href="#如何判断环的起点" class="headerlink" title="如何判断环的起点"></a>如何判断环的起点</h4><p>证明如下图所示：</p>
<p><img src="/2020/11/01/Leetcode/142/zhengming.png" alt="证明"></p>
<p>看不懂没关系，记住下面的技巧即可：</p>
<p>简单来说：两个指针相遇之后，将快指针放回原点，慢指针位置不变，两者都以慢指针的速度遍历节点。则再次相遇时，便是环的起点。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow != <span class="keyword">null</span> &amp;&amp; fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next; <span class="comment">// 一次走一步</span></span><br><span class="line">            fast = fast.next.next; <span class="comment">// 一次走两步</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="keyword">false</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        fast = head; <span class="comment">// 快指针放回起点</span></span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123; </span><br><span class="line">            fast = fast.next; <span class="comment">// 以相同速度前进 </span></span><br><span class="line">            slow = slow.next; <span class="comment">// 以相同速度前进 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow; <span class="comment">// 交点即环的起点</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>两个指针：慢指针和快指针，慢指针一次走一步，快指针一次走两步。如果两个指针相遇，就是有环，如果两个指针不相遇，就是没环。</li>
<li>将快指针放回链表起点，慢指针位置不变，两者都以慢速遍历指针，再次相遇的点即为环的起点。</li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 532. K-diff Pairs in an Array</title>
    <url>/2020/10/31/Leetcode/523/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.com/problems/k-diff-pairs-in-an-array/">英文题目</a></p>
<p><a href="https://leetcode-cn.com/problems/k-diff-pairs-in-an-array/">中文题目</a></p>
<p>难度：中等</p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>说明：题目来自leetcode中文官网</p>
<p>给定一个整数数组和一个整数 k，你需要在数组里找到不同的 k-diff 数对，并返回不同的 k-diff 数对 的数目。</p>
<p>这里将 k-diff 数对定义为一个整数对 (nums[i], nums[j])，并满足下述全部条件：</p>
<p>0 &lt;= i, j &lt; nums.length<br>i != j<br>|nums[i] - nums[j]| == k<br>注意，|val| 表示 val 的绝对值。</p>
<p><strong>示例：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：nums = [3, 1, 4, 1, 5], k = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。</span><br><span class="line">尽管数组中有两个1，但我们只应返回不同的数对的数量。</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">输入：nums = [1, 2, 3, 4, 5], k = 1</span><br><span class="line">输出：4</span><br><span class="line">解释：数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。</span><br><span class="line"></span><br><span class="line">-------------</span><br><span class="line">输入：nums = [1, 3, 1, 5, 4], k = 0</span><br><span class="line">输出：1</span><br><span class="line">解释：数组中只有一个 0-diff 数对，(1, 1)。</span><br></pre></td></tr></table></figure>



<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决，核心思路见代码：</p>
<ol>
<li>数组排序</li>
<li>前后两个指针遍历数组，如果当前指针所指的差值等于k，则是我们想要的答案，需要注意的地方是 ：<ul>
<li>题目要求找到唯一的数组对，因此，排序之后相同的数字会排在一起，这里需要跳过重复的数字</li>
<li>k为0的情况，注意别让两个指针重合了</li>
</ul>
</li>
</ol>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPairs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span> || nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; len) &#123;</span><br><span class="line">            <span class="keyword">int</span> lv = nums[l];</span><br><span class="line">            <span class="keyword">int</span> rv = nums[r];</span><br><span class="line">            <span class="keyword">if</span> (rv - lv == k) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">int</span> preL = lv;</span><br><span class="line">                <span class="keyword">int</span> preR = rv;</span><br><span class="line">                <span class="keyword">while</span>((r + <span class="number">1</span> &lt; len) &amp;&amp; nums[++r] == preR) &#123;&#125; <span class="comment">// 跳过重复数字</span></span><br><span class="line">                <span class="keyword">while</span>((l + <span class="number">1</span> &lt; len) &amp;&amp; nums[++l] == preL) &#123;&#125; <span class="comment">// 跳过重复数字</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rv - lv &lt; k) &#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rv - lv &gt; k) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (l == r) r = l + <span class="number">1</span>; <span class="comment">// 避免k=0时，左右指针重合的情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>1616. Split Two Strings to Make Palindrome</title>
    <url>/2020/10/30/Leetcode/1616/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.com/problems/split-two-strings-to-make-palindrome/">英文题目</a></p>
<p><a href="https://leetcode-cn.com/problems/split-two-strings-to-make-palindrome/">中文题目</a></p>
<p>难度：中等</p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>说明：题目来自leetcode中文官网</p>
<p>给你两个字符串 a 和 b ，它们长度相同。请你选择一个下标，将两个字符串都在 相同的下标 分割开。由 a 可以得到两个字符串： aprefix 和 asuffix ，满足 a = aprefix + asuffix ，同理，由 b 可以得到两个字符串 bprefix 和 bsuffix ，满足 b = bprefix + bsuffix 。请你判断 aprefix + bsuffix 或者 bprefix + asuffix 能否构成回文串。</p>
<p>当你将一个字符串 s 分割成 sprefix 和 ssuffix 时， ssuffix 或者 sprefix 可以为空。比方说， s = “abc” 那么 “” + “abc” ， “a” + “bc” ， “ab” + “c” 和 “abc” + “” 都是合法分割。</p>
<p>如果 能构成回文字符串 ，那么请返回 true，否则返回 false 。</p>
<p>请注意， x + y 表示连接字符串 x 和 y 。</p>
<p><strong>示例：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：a = &quot;x&quot;, b = &quot;y&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：如果 a 或者 b 是回文串，那么答案一定为 true ，因为你可以如下分割：</span><br><span class="line">aprefix = &quot;&quot;, asuffix = &quot;x&quot;</span><br><span class="line">bprefix = &quot;&quot;, bsuffix = &quot;y&quot;</span><br><span class="line">那么 aprefix + bsuffix = &quot;&quot; + &quot;y&quot; = &quot;y&quot; 是回文串。</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">输入：a = &quot;ulacfd&quot;, b = &quot;jizalu&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：在下标为 3 处分割：</span><br><span class="line">aprefix = &quot;ula&quot;, asuffix = &quot;cfd&quot;</span><br><span class="line">bprefix = &quot;jiz&quot;, bsuffix = &quot;alu&quot;</span><br><span class="line">那么 aprefix + bsuffix = &quot;ula&quot; + &quot;alu&quot; = &quot;ulaalu&quot; 是回文串</span><br></pre></td></tr></table></figure>



<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决，核心思路见代码：</p>
<ol>
<li>如果a前缀加上b后缀为回文，则在遍历过程中，一定存在以下情况：<ul>
<li>a的左指针，对称在b的右指针所指向的值是相等的，如果不相等，则它们之间的那一段必定是回文才能保证拼接之后是回文；</li>
</ul>
</li>
<li>反过来，对于b和a也是一样的。</li>
</ol>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPalindromeFormation</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(a, b) || helper(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = a.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; len; i++, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.charAt(i) != b.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> isP(a, i, j) || isP(b, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isP</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(j)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>algorithm</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 287. Find the Duplicate Number</title>
    <url>/2020/11/02/Leetcode/287/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.com/problems/find-the-duplicate-number/">英文题目</a></p>
<p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">中文题目</a></p>
<p>难度：中等</p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个包含<code>n+1</code>个数字的数组，该数组中所有数字都在范围<code>[1,n]</code>内，该数组中有且仅有一个数字出现了两次，求这个数字。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>该数组可以等价为一个链表，数组中的每个元素等价为一个节点，每个节点的值得<code>nums[i]</code>，该节点的<code>next</code>值为<code>nums[nums[i]]</code>，即该节点的值为下一个节点在数组中的索引。这样，原本的数组就转换为了一个链表，对于链表中的每个节点，有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node n;</span><br><span class="line">n.val = nums[i];</span><br><span class="line">n.next = nums[n.val] <span class="comment">// 或者n.next = nums[num[i]]</span></span><br></pre></td></tr></table></figure>

<p>以nums[0]为头节点，就能将这个数组转换为链表啦。当然，你也可以以任意一个节点为头节点，而不仅仅是Nums[0]。</p>
<p>转换为链表之后，链表中必存在环，因为有数字出现了两次，出现了两次意味着它是两个节点的next节点，也就是该数字是环的起点。</p>
<p><strong>例子一：</strong></p>
<p>假设现在有数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index: 0 1 2 3 4 </span><br><span class="line">value: 1 3 4 2 2</span><br></pre></td></tr></table></figure>

<p>则以nums[0]为头节点，组成的链表为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1-&gt;3-&gt;2-&gt;4</span><br><span class="line">	  |__| </span><br></pre></td></tr></table></figure>

<p>我们发现，2在数组中出现了两次，同时它也是环的起点。</p>
<p><strong>例子二：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index: 0 1 2 3 4</span><br><span class="line">value: 3 1 3 4 2</span><br></pre></td></tr></table></figure>

<p>则以nums[0]为头节点，组成的链表为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3-&gt;4-&gt;2</span><br><span class="line">|_____|   </span><br></pre></td></tr></table></figure>

<p>同样，3出现了两次，它也是环的起点。</p>
<h4 id="如何判断环状链表的起点"><a href="#如何判断环状链表的起点" class="headerlink" title="如何判断环状链表的起点"></a>如何判断环状链表的起点</h4><p><a href="https://aerfalwl.github.io/2020/11/01/Leetcode/142/">证明</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[nums[fast]];</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>找环的起点：</strong></p>
<ol>
<li>两个指针：慢指针和快指针，慢指针一次走一步，快指针一次走两步。如果两个指针相遇，就是有环，如果两个指针不相遇，就是没环。</li>
<li>将快指针放回链表起点，慢指针位置不变，两者都以慢速遍历指针，再次相遇的点即为环的起点。</li>
</ol>
<p><strong>数组</strong></p>
<ol>
<li>数组中的每个元素可以有两层含义<ul>
<li>它可以作为一个值(value)</li>
<li>该值也可以是数组的一个索引(index)</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 567. Permutation in String</title>
    <url>/2020/11/03/Leetcode/567/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.com/problems/permutation-in-string/">英文题目</a></p>
<p><a href="https://leetcode-cn.com/problems/permutation-in-string/">中文题目</a></p>
<p>难度：中等</p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>题目给出两个字符串<code>s1</code>和<code>s2</code>，返回<code>s1</code>的全排列之一是否是<code>s2</code>的子集。</p>
<p><strong>示例：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Input: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</span><br><span class="line">Output: True</span><br><span class="line">Explanation: s2 contains one permutation of s1 (&quot;ba&quot;).</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">Input:s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure>



<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决，核心思路：</p>
<ol>
<li>如果字符串<code>a</code>是字符串<code>b</code>的subtring，则<code>b</code>字符串其中的一段，一定和a的长度相等；</li>
<li>a的全排列，就是将a中字符全部打乱，任意排列；且全排列不会更改字符串中字符出现的次数；</li>
</ol>
<p>因此，在代码中：</p>
<pre><code>1. 计算`s1`中每个字符出现的个数，保存在数组中；
 2. 两个指针遍历`s2`，假设两个指针之间形成的字符串为`tmpS`，若`tmpS`中每个字符的个数和`s1`中每个字符出现的个数相等，则返回`true`，遍历结束也没满足条件，返回false；</code></pre>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s1.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = s2.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> s : s1.toCharArray()) &#123;</span><br><span class="line">            dp[s - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> need = len1;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; len2) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s2.charAt(right);</span><br><span class="line">            <span class="keyword">if</span> (dp[c - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[c - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                need--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[c - <span class="string">&#x27;a&#x27;</span>] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                dp[s2.charAt(left) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">                left++;</span><br><span class="line">                need++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (need == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>763. Partition Labels</title>
    <url>/2020/10/27/Leetcode/763/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.com/problems/partition-labels/">英文题目</a></p>
<p><a href="https://leetcode-cn.com/problems/partition-labels/">中文题目</a></p>
<p>难度：中等</p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>说明：题目来自leetcode中文官网</p>
<p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p>
<p><strong>示例：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：S = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">输出：[9,7,8]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。</span><br></pre></td></tr></table></figure>



<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决。</p>
<p>即首先找到每个字母最后出现的位置，之后划分段的时候，确保该段内每个字母出现的最右值的位置在该段内。不太好描述，直接看代码。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.length() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span>[] s = S.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len = s.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] max = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (max[curr] &lt; i) max[curr] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxRight = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">                <span class="keyword">int</span> curr = max[s[right] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">if</span> (maxRight &lt; curr) maxRight = curr;</span><br><span class="line">                <span class="keyword">if</span> (right == maxRight) &#123;</span><br><span class="line">                    ans.add(right - left + <span class="number">1</span>);</span><br><span class="line">                    left = right + <span class="number">1</span>;</span><br><span class="line">                    right++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != right) &#123;</span><br><span class="line">            ans.add(right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="Two-pointer解决套路"><a href="#Two-pointer解决套路" class="headerlink" title="Two pointer解决套路"></a>Two pointer解决套路</h3><p>Two pointer和滑动窗口差不多，其套路一般为：</p>
<ol>
<li>一个左指针，一个右指针。其中左指针用于缩小范围，右指针用于扩大搜索范围。一般求滑动窗口的最小值都是在缩小左指针的时候取得的。</li>
<li>右指针扩展的条件时：只要当前还没有满足条件，就暴力增长，直到第一次满足条件为止。</li>
<li>左指针收缩的条件：只要当前指针的缩小还没影响窗口的可满足性，就一直暴力向左增长。一但当前指针向前移动的时候影响了窗口的可满足性，就记录下当前的窗口大小，并更新目前为止满足条件的最小窗口记录。之后，再次扩展右指针，使得窗口满足题目的条件。</li>
<li>以此类推即可。</li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/10/27/Leetcode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p><a href="https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/367697">https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/367697</a></p>
<ul>
<li><ol>
<li><a href="https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1)">Count Number of Nice Subarrays</a></li>
</ol>
</li>
<li><ol>
<li><a href="https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/367697">Replace the Substring for Balanced String</a></li>
</ol>
</li>
<li><ol>
<li><a href="https://leetcode.com/problems/max-consecutive-ones-iii/discuss/247564/javacpython-sliding-window/379427?page=3">Max Consecutive Ones III</a></li>
</ol>
</li>
<li><ol>
<li><a href="https://leetcode.com/problems/binary-subarrays-with-sum/discuss/186683/">Binary Subarrays With Sum</a></li>
</ol>
</li>
<li><ol>
<li><a href="https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/234482/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1)">Subarrays with K Different Integers</a></li>
</ol>
</li>
<li><ol>
<li><a href="https://leetcode.com/problems/fruit-into-baskets/discuss/170740/Sliding-Window-for-K-Elements">Fruit Into Baskets</a></li>
</ol>
</li>
<li><ol>
<li><a href="https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/C%2B%2BJavaPython-O(N)-Using-Deque">Shortest Subarray with Sum at Least K</a></li>
</ol>
</li>
<li><ol>
<li><a href="https://leetcode.com/problems/minimum-size-subarray-sum/discuss/433123">Minimum Size Subarray Sum</a></li>
</ol>
</li>
</ul>
<p><a href="https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/204290/Monotonic-Queue-Summary">https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/204290/Monotonic-Queue-Summary</a></p>
]]></content>
  </entry>
  <entry>
    <title>LeetCode 826. Most Profit Assigning Work</title>
    <url>/2020/10/28/Leetcode/826/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.com/problems/most-profit-assigning-work/">英文题目</a></p>
<p><a href="https://leetcode-cn.com/problems/most-profit-assigning-work/">中文题目</a></p>
<p>难度：中等</p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>说明：题目来自leetcode中文官网</p>
<p>有一些工作：<code>difficulty[i]</code> 表示第 <code>i</code> 个工作的难度，<code>profit[i]</code> 表示第 <code>i</code> 个工作的收益。</p>
<p>现在我们有一些工人。<code>worker[i]</code> 是第 <code>i</code> 个工人的能力，即该工人只能完成难度小于等于 <code>worker[i]</code> 的工作。</p>
<p>每一个工人都最多只能安排一个工作，但是一个工作可以完成多次。</p>
<p>举个例子，如果 3 个工人都尝试完成一份报酬为 1 的同样工作，那么总收益为 $3。如果一个工人不能完成任何工作，他的收益为 $0 。</p>
<p>我们能得到的最大收益是多少？</p>
<p><strong>示例：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]</span><br><span class="line">Output: 100 </span><br><span class="line">Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately.。</span><br></pre></td></tr></table></figure>



<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决。</p>
<h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p><strong>核心</strong>：找出每个工人能承受范围内工作的最大利润，求和即可。</p>
<ol>
<li>将所有job按照困难度从小到大排序，困难度相同时，按照利润从大到小排序。</li>
<li>得到所有Job困难度下，能获得的最大利润。</li>
<li>遍历worker，找到其能承受困难度下的最大利润，相加即可。</li>
</ol>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfitAssignment</span><span class="params">(<span class="keyword">int</span>[] d, <span class="keyword">int</span>[] p, <span class="keyword">int</span>[] w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = d.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[len][<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            a[i][<span class="number">0</span>] = d[i];</span><br><span class="line">            a[i][<span class="number">1</span>] = p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 按照困难度从小到大排序</span></span><br><span class="line">        Arrays.sort(a, (m, n) -&gt; m[<span class="number">0</span>] == n[<span class="number">0</span>] ? n[<span class="number">1</span>] - m[<span class="number">1</span>] : m[<span class="number">0</span>] - n[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 该困难度下的最高利润</span></span><br><span class="line">        <span class="keyword">int</span>[] maxP = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        </span><br><span class="line">        maxP[<span class="number">0</span>] = a[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> max = a[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            max = Math.max(a[i][<span class="number">1</span>], max);</span><br><span class="line">            maxP[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> job = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// worker按照其能承受困难强度从小到大排序</span></span><br><span class="line">        Arrays.sort(w);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到所有worker能承受困难下的最大利润</span></span><br><span class="line">        max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (job &lt; len) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w[i] &gt;= a[job][<span class="number">0</span>]) &#123;</span><br><span class="line">                    max = maxP[job];</span><br><span class="line">                    job++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p>利用DP的思想，dp[i]表示在worker能承受难度最大值为i时，其能获得的最大的利润。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfitAssignment</span><span class="params">(<span class="keyword">int</span>[] d, <span class="keyword">int</span>[] p, <span class="keyword">int</span>[] w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = d.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxD = <span class="number">0</span>; <span class="comment">// 最大难度值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : d) &#123;</span><br><span class="line">            maxD = Math.max(maxD, num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dp[i] 表示在难度为i时，能获得的最大利润</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[maxD + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 首先将题目给的数填充进来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[d[i]] = Math.max(dp[d[i]], p[i]); </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxP = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 可能出现难度高，但是利润小的工作，因此需要遍历再次找出特定难度下能获得的最大利润</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxD; i++) &#123;</span><br><span class="line">            maxP = Math.max(maxP, dp[i]);</span><br><span class="line">            dp[i] = maxP;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : w) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &gt; maxD) &#123;</span><br><span class="line">                sum += maxP;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += dp[n]; <span class="comment">//将所有的利润求和</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>algorithm</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/10/27/LinuxCmd/20200814-%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%AF%E5%90%A6%E5%BC%80%E6%94%BE/</url>
    <content><![CDATA[<h1 id="查看远程服务器的端口是否开放"><a href="#查看远程服务器的端口是否开放" class="headerlink" title="查看远程服务器的端口是否开放"></a>查看远程服务器的端口是否开放</h1><h2 id="1-nc（netcat）"><a href="#1-nc（netcat）" class="headerlink" title="1. nc（netcat）"></a>1. nc（netcat）</h2><p>nc是一个简单的Unix工具，使用TCP或者UDP协议读写网络连接上的数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc [OPTIONS...] [hostname] [port]</span><br></pre></td></tr></table></figure>

<p>如果未开放，则会显示请求被拒绝。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc node1 9100</span><br><span class="line"><span class="comment"># Ncat: Connection refused.</span></span><br></pre></td></tr></table></figure>

<p>如果指定端口开放，则会显示连接成功。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc node1 9100</span><br><span class="line"><span class="comment"># Ncat: Connection succeeded</span></span><br></pre></td></tr></table></figure>

<h2 id="2-telnet"><a href="#2-telnet" class="headerlink" title="2. telnet"></a>2. telnet</h2><p>命令格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">telnet [HostName or IP] [PortNumber]</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/10/27/LinuxCmd/20200814netstat/</url>
    <content><![CDATA[<h1 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h1><p>查看所有在监听的端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -ntlp</span><br></pre></td></tr></table></figure>

<p>待整理</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/10/27/LinuxCmd/%E4%BD%BF%E7%94%A8GDB%E6%9F%A5%E7%9C%8Bcore%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="2-使用GDB查看core文件"><a href="#2-使用GDB查看core文件" class="headerlink" title="2 使用GDB查看core文件"></a>2 使用GDB查看core文件</h1><p>默认编译出来的程序在出现Segmentation fault 时并没有生成core崩溃文件，可以在gcc/g++编译时增加-g选项。</p>
<p>如果仍然没有生成core文件，则可能是因为系统设置了core文件大小为0，可以通过：<code>ulimit -a</code> 查询得知。</p>
<p>执行 <code>ulimit -c unlimited</code> 命令后可以使core文件大小不受限制。此时再次运行程序应该就能在同级目录看到<code>core.XXX</code>文件了</p>
<p>使用 <code>gdb ./a.out core.XXX</code> 可以查看出错所在行信息，这样就进入了 gdb core 调试模式。</p>
<p>追踪产生segmenttation fault的位置及代码函数调用情况：</p>
<p><code>gdb&gt;bt</code></p>
<p>这样，一般就可以看到出错的代码是哪一句了，还可以打印出相应变量的数值，进行进一步分析。</p>
<p><a href="https://www.cnblogs.com/kuliuheng/p/11698378.html#_labelTop">返回目录</a></p>
<h1 id="3-使用GDB调试程序"><a href="#3-使用GDB调试程序" class="headerlink" title="3 使用GDB调试程序"></a><strong>3 使用GDB调试程序</strong></h1><p>如上述流程不能解决问题，下面可使用gdb单步调试程序。重新编译程序，编译命令中加入-g。如：</p>
<p>gcc -lm -O3 -g file.c -o file<br>之后使用gdb命令</p>
<p><code>gdb file</code><br>开始调试。</p>
<p>输入<code>start</code>使程序运行到<code>main</code>中第一行运行代码。<code>next</code>或者n为执行下一行程序，<code>until xx</code>执行到xx行，print或p可输出变量值，<code>b xx</code>用于在xx行设置断点，<code>run</code>或<code>r</code>用于执行程序至下一断点，<code>d xx</code>删除xx行断点。</p>
<p>我们可以先run一遍程序，这时它会提示出错行信息。然后<code>until</code>到出错行前5行，交替执行<code>next</code>和<code>print</code>，输出与出错行变量相关变量或指针的值。最终定位出错的根本操作在哪一行。修改之即可。</p>
]]></content>
  </entry>
  <entry>
    <title>Summary of Two Pointer</title>
    <url>/2020/11/03/LeetcodeSummary/TwoPointer/</url>
    <content><![CDATA[<h3 id="Two-pointer解决套路"><a href="#Two-pointer解决套路" class="headerlink" title="Two pointer解决套路"></a>Two pointer解决套路</h3><p>Two pointer和滑动窗口差不多，其套路一般为：</p>
<ol>
<li>一个左指针，一个右指针。其中左指针用于缩小范围，右指针用于扩大搜索范围。一般求滑动窗口的最小值都是在缩小左指针的时候取得的。</li>
<li>右指针扩展的条件时：只要当前还没有满足条件，就暴力增长，直到第一次满足条件为止。</li>
<li>左指针收缩的条件：只要当前指针的缩小还没影响窗口的可满足性，就一直暴力向左增长。一但当前指针向前移动的时候影响了窗口的可满足性，就记录下当前的窗口大小，并更新目前为止满足条件的最小窗口记录。之后，再次扩展右指针，使得窗口满足题目的条件。</li>
<li>以此类推即可。</li>
</ol>
]]></content>
      <categories>
        <category>leetcode_summary</category>
      </categories>
      <tags>
        <tag>leetcode_summary</tag>
      </tags>
  </entry>
  <entry>
    <title>C++六种内存模型</title>
    <url>/2020/10/30/Memory/Dynamic_memory_in_CPP/</url>
    <content><![CDATA[<h2 id="C-内存模型"><a href="#C-内存模型" class="headerlink" title="C++内存模型"></a>C++内存模型</h2><p>C++规定了6种访存顺序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> memory_order &#123;</span><br><span class="line">    memory_order_relaxed,</span><br><span class="line">    memory_order_consume,</span><br><span class="line">    memory_order_acquire,</span><br><span class="line">    memory_order_release,</span><br><span class="line">    memory_order_acq_rel,</span><br><span class="line">    memory_order_seq_cst</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这6种内存模型可以分为3类</p>
<ol>
<li>顺序一致性模型, memory_order_seq_cst</li>
<li>Acquire-release模型，也称为获取释放内存模型。<ul>
<li>memory_order_consume</li>
<li>memory_order_acquire</li>
<li>memory_order_release</li>
<li>memory_order_acq_rel</li>
</ul>
</li>
<li>Relax模型，即memory_order_relaxed，宽松的内存序列化模型</li>
</ol>
<h3 id="memory-order-relaxed"><a href="#memory-order-relaxed" class="headerlink" title="memory_order_relaxed"></a>memory_order_relaxed</h3><p>只保证当前操作的原子性，不考虑线程之间的同步，其它线程可以读到新值，也可以读到旧值。</p>
<h3 id="memory-order-consume"><a href="#memory-order-consume" class="headerlink" title="memory_order_consume"></a>memory_order_consume</h3><h3 id="memory-order-acquire"><a href="#memory-order-acquire" class="headerlink" title="memory_order_acquire"></a>memory_order_acquire</h3><p>acquire于内存的load操作对应，也就是读操作。设置该标志，表示在这条语句之后设置了barrier。</p>
<p>即所有后续操作的读操作必须在本条原子操作完成之后执行。</p>
<h3 id="memory-order-release"><a href="#memory-order-release" class="headerlink" title="memory_order_release"></a>memory_order_release</h3><p>release 对应于内存的 store操作，也就是写内存。设置标志，表示在这条语句之前设置了barrier。即所有之前的写操作完成之后才能执行本条原子操作。</p>
<p>该语句和memory_order_qcquire有点相似，但是如何<code>见字如面</code>呢，即如何第一眼看到便区分开来呢。我是这样区分的：</p>
<ol>
<li>acquire和release的对象都是barrier；</li>
<li>acquire即请求，请求之后，便得到了barrier，因此是在这条语句之后设置了barrier，因此后续的读(load)操作必须在本条原子操作完成之后；</li>
<li>release即释放，要想释放，必须先拥有，即该条语句之前已经拥有了barrier，因此之前的写(store)操作完成之后，才能执行本条原子操作；</li>
<li>acquire操作常用来读取数据的同步，release操作常用来写数据的同步。</li>
</ol>
<h3 id="memory-order-acq-rel"><a href="#memory-order-acq-rel" class="headerlink" title="memory_order_acq_rel"></a>memory_order_acq_rel</h3><p>对读取和写入施加acquire-release语句，无法被重排。</p>
<p>可以看见其他线程施加release语义的所有写入，同时自己的release结束后所有写入对其施加acquire语义的线程可见。</p>
<h3 id="memory-order-seq-cst"><a href="#memory-order-seq-cst" class="headerlink" title="memory_order_seq_cst"></a>memory_order_seq_cst</h3>]]></content>
      <categories>
        <category>Memory</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/10/27/Socket/2020-09-21-TCP%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0/</url>
    <content><![CDATA[<h1 id="TCP-最大连接数为28232"><a href="#TCP-最大连接数为28232" class="headerlink" title="TCP 最大连接数为28232"></a>TCP 最大连接数为28232</h1><p>Linux对外的端口分配是有一定限制的，默认不超过28232个。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/ip_local_range</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出为</span></span><br><span class="line">32768 60999</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>两个数字相减刚好为28232。如果要对其范围进行修改，可将两个数字更改为10000 65535，注意用户可用端口方位为1024~65535.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;10000 65535&quot; &gt; /proc/sys/net/ipv4/ip_local_port_range</span><br><span class="line">sysctl -p	</span><br></pre></td></tr></table></figure>

<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>快速回收端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/sysctl.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 末尾添加上</span></span><br><span class="line">net.ipv4.tcp_tw_recycle=1</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>

<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><p>系统在高并发短连接的情况下，会出现大量处于TIME_WAIT的SOCKET。</p>
<p>这里短连接是指：<strong>业务处理+传输数据的时间 远远小于 TIMEWAIT超时的时间”的连接</strong></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/10/27/Socket/20200914-socket_close_shutdown/</url>
    <content><![CDATA[<h1 id="Socket-之Close与Shutdown"><a href="#Socket-之Close与Shutdown" class="headerlink" title="Socket 之Close与Shutdown"></a>Socket 之Close与Shutdown</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol>
<li>close会释放文件句柄，而shutdown不会。</li>
<li>close把描述符的引用计数减1，仅在该计数变为0时关闭套接字。shutdown可以不管引用计数就激发TCP的正常连接终止序列，因此在多进程环境中：close()是关闭本进程的socket id，但链接还是开着的，用这个socket id的其它进程还能用这个链接，能读或写这个socket id，而shutdown执行的操作对所有进程有效。</li>
</ol>
<h2 id="Strace"><a href="#Strace" class="headerlink" title="Strace"></a>Strace</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strace ./exec</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Leetcode 986. Interval List Intersections</title>
    <url>/2020/11/04/Leetcode/986/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.com/problems/interval-list-intersections/">英文题目</a></p>
<p><a href="https://leetcode-cn.com/problems/interval-list-intersections/">中文题目</a></p>
<p>难度：中等</p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>求两组线段集合的交集。</p>
<p><strong>示例：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Input: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]</span><br><span class="line">Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]</span><br></pre></td></tr></table></figure>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>该题目分类属于中等题，且用two pointer进行解决。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>两个指针，一个指针指向线段集合A，一个指针指向线段集合B；</li>
<li>依次移动两个指针，如果发现当前两个指针之间有交集，则求交集之后放入结果中，否则，视情况移动两个指针；</li>
</ol>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] intervalIntersection(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lenA = A.length;</span><br><span class="line">        <span class="keyword">int</span> lenB = B.length;</span><br><span class="line">        </span><br><span class="line">        List&lt;Node&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> currA = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> currB = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (currA &lt; lenA &amp;&amp; currB &lt; lenB) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[currA][<span class="number">1</span>] &lt; B[currB][<span class="number">0</span>]) &#123; <span class="comment">// 没交集的情况</span></span><br><span class="line">                currA++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (B[currB][<span class="number">1</span>] &lt; A[currA][<span class="number">0</span>]) &#123; <span class="comment">// 没交集的情况</span></span><br><span class="line">                currB++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> maxL = Math.max(A[currA][<span class="number">0</span>], B[currB][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> minR = Math.min(A[currA][<span class="number">1</span>], B[currB][<span class="number">1</span>]);</span><br><span class="line">            list.add(<span class="keyword">new</span> Node(maxL, minR));</span><br><span class="line">            <span class="keyword">if</span> (A[currA][<span class="number">1</span>] == minR) currA++;</span><br><span class="line">            <span class="keyword">if</span> (B[currB][<span class="number">1</span>] == minR) currB++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> len = list.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            Node tmp = list.get(i);</span><br><span class="line">            ans[i][<span class="number">0</span>] = tmp.l;</span><br><span class="line">            ans[i][<span class="number">1</span>] = tmp.r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        Node(<span class="keyword">int</span> l_, <span class="keyword">int</span> r_) &#123;</span><br><span class="line">            <span class="keyword">this</span>.l = l_;</span><br><span class="line">            <span class="keyword">this</span>.r = r_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>SkipList in LevelDB</title>
    <url>/2020/11/05/NiceCode/SkipList/</url>
    <content><![CDATA[<p>LevelDB中有一份非常优雅的SkipList的实现方式，这里拿过来供学习。</p>
<p>SkipList的一些特性：</p>
<ol>
<li>最底层是0层，该层最长，最高层是大层，该层最短；</li>
<li>查找的过程总是从左上至右下；</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"><span class="comment">// found in the LICENSE file. See the AUTHORS file for names of contributors.</span></span><br><span class="line"></span><br><span class="line">#ifndef STORAGE_LEVELDB_DB_SKIPLIST_H_</span><br><span class="line">#define STORAGE_LEVELDB_DB_SKIPLIST_H_</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread safety</span></span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Writes require external synchronization, most likely a mutex.</span></span><br><span class="line"><span class="comment">// Reads require a guarantee that the SkipList will not be destroyed</span></span><br><span class="line"><span class="comment">// while the read is in progress.  Apart from that, reads progress</span></span><br><span class="line"><span class="comment">// without any internal locking or synchronization.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Invariants:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// (1) Allocated nodes are never deleted until the SkipList is</span></span><br><span class="line"><span class="comment">// destroyed.  This is trivially guaranteed by the code since we</span></span><br><span class="line"><span class="comment">// never delete any skip list nodes.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// (2) The contents of a Node except for the next/prev pointers are</span></span><br><span class="line"><span class="comment">// immutable after the Node has been linked into the SkipList.</span></span><br><span class="line"><span class="comment">// Only Insert() modifies the list, and it is careful to initialize</span></span><br><span class="line"><span class="comment">// a node and use release-stores to publish the nodes in one or</span></span><br><span class="line"><span class="comment">// more lists.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ... prev vs. next pointer ordering ...</span></span><br><span class="line"></span><br><span class="line">#include &lt;atomic&gt;</span><br><span class="line">#include &lt;cassert&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;util/arena.h&quot;</span><br><span class="line">#include &quot;util/random.h&quot;</span><br><span class="line"></span><br><span class="line">namespace leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Arena</span></span>;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SkipList</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  struct Node;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Create a new SkipList object that will use &quot;cmp&quot; for comparing keys,</span></span><br><span class="line">  <span class="comment">// and will allocate memory using &quot;*arena&quot;.  Objects allocated in the arena</span></span><br><span class="line">  <span class="comment">// must remain allocated for the lifetime of the skiplist object.</span></span><br><span class="line">  <span class="function">explicit <span class="title">SkipList</span><span class="params">(Comparator cmp, Arena* arena)</span></span>;</span><br><span class="line"></span><br><span class="line">  SkipList(<span class="keyword">const</span> SkipList&amp;) = delete;</span><br><span class="line">  SkipList&amp; operator=(<span class="keyword">const</span> SkipList&amp;) = delete;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert key into the list.</span></span><br><span class="line">  <span class="comment">// REQUIRES: nothing that compares equal to key is currently in the list.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns true iff an entry that compares equal to key is in the list.</span></span><br><span class="line">  <span class="function">bool <span class="title">Contains</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Iteration over the contents of a skip list</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Initialize an iterator over the specified list.</span></span><br><span class="line">    <span class="comment">// The returned iterator is not valid.</span></span><br><span class="line">    <span class="function">explicit <span class="title">Iterator</span><span class="params">(<span class="keyword">const</span> SkipList* list)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns true iff the iterator is positioned at a valid node.</span></span><br><span class="line">    <span class="function">bool <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the key at the current position.</span></span><br><span class="line">    <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">    <span class="keyword">const</span> Key&amp; key() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Advances to the next position.</span></span><br><span class="line">    <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Advances to the previous position.</span></span><br><span class="line">    <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Advance to the first entry with a key &gt;= target</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Key&amp; target)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Position at the first entry in list.</span></span><br><span class="line">    <span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Position at the last entry in list.</span></span><br><span class="line">    <span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> SkipList* list_;</span><br><span class="line">    Node* node_;</span><br><span class="line">    <span class="comment">// Intentionally copyable</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> </span>&#123; kMaxHeight = <span class="number">12</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function">inline <span class="keyword">int</span> <span class="title">GetMaxHeight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max_height_.load(std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Node* NewNode(<span class="keyword">const</span> Key&amp; key, <span class="keyword">int</span> height);</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">RandomHeight</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">bool <span class="title">Equal</span><span class="params">(<span class="keyword">const</span> Key&amp; a, <span class="keyword">const</span> Key&amp; b)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (compare_(a, b) == <span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return true if key is greater than the data stored in &quot;n&quot;</span></span><br><span class="line">  <span class="function">bool <span class="title">KeyIsAfterNode</span><span class="params">(<span class="keyword">const</span> Key&amp; key, Node* n)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the earliest node that comes at or after key.</span></span><br><span class="line">  <span class="comment">// Return nullptr if there is no such node.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// If prev is non-null, fills prev[level] with pointer to previous</span></span><br><span class="line">  <span class="comment">// node at &quot;level&quot; for every level in [0..max_height_-1].</span></span><br><span class="line">  Node* FindGreaterOrEqual(<span class="keyword">const</span> Key&amp; key, Node** prev) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the latest node with a key &lt; key.</span></span><br><span class="line">  <span class="comment">// Return head_ if there is no such node.</span></span><br><span class="line">  Node* FindLessThan(<span class="keyword">const</span> Key&amp; key) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the last node in the list.</span></span><br><span class="line">  <span class="comment">// Return head_ if list is empty.</span></span><br><span class="line">  Node* FindLast() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Immutable after construction</span></span><br><span class="line">  Comparator <span class="keyword">const</span> compare_;</span><br><span class="line">  Arena* <span class="keyword">const</span> arena_;  <span class="comment">// Arena used for allocations of nodes</span></span><br><span class="line"></span><br><span class="line">  Node* <span class="keyword">const</span> head_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Modified only by Insert().  Read racily by readers, but stale</span></span><br><span class="line">  <span class="comment">// values are ok.</span></span><br><span class="line">  std::atomic&lt;<span class="keyword">int</span>&gt; max_height_;  <span class="comment">// Height of the entire list</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read/written only by Insert().</span></span><br><span class="line">  Random rnd_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implementation details follow</span></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">struct SkipList&lt;Key, Comparator&gt;::Node &#123;</span><br><span class="line">  <span class="function">explicit <span class="title">Node</span><span class="params">(<span class="keyword">const</span> Key&amp; k)</span> : <span class="title">key</span><span class="params">(k)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  Key <span class="keyword">const</span> key;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Accessors/mutators for links.  Wrapped in methods so we can</span></span><br><span class="line">  <span class="comment">// add the appropriate barriers as necessary.</span></span><br><span class="line">  Node* Next(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Use an &#x27;acquire load&#x27; so that we observe a fully initialized</span></span><br><span class="line">    <span class="comment">// version of the returned Node.</span></span><br><span class="line">    <span class="keyword">return</span> next_[n].load(std::memory_order_acquire);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetNext</span><span class="params">(<span class="keyword">int</span> n, Node* x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Use a &#x27;release store&#x27; so that anybody who reads through this</span></span><br><span class="line">    <span class="comment">// pointer observes a fully initialized version of the inserted node.</span></span><br><span class="line">    next_[n].store(x, std::memory_order_release);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No-barrier variants that can be safely used in a few locations.</span></span><br><span class="line">  Node* NoBarrier_Next(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> next_[n].load(std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">NoBarrier_SetNext</span><span class="params">(<span class="keyword">int</span> n, Node* x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span>(n &gt;= <span class="number">0</span>);</span><br><span class="line">    next_[n].store(x, std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Array of length equal to the node height.  next_[0] is lowest level link.</span></span><br><span class="line">  std::atomic&lt;Node*&gt; next_[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">typename SkipList&lt;Key, Comparator&gt;::Node* SkipList&lt;Key, Comparator&gt;::NewNode(</span><br><span class="line">    <span class="keyword">const</span> Key&amp; key, <span class="keyword">int</span> height) &#123;</span><br><span class="line">  <span class="keyword">char</span>* <span class="keyword">const</span> node_memory = arena_-&gt;AllocateAligned(</span><br><span class="line">      sizeof(Node) + sizeof(std::atomic&lt;Node*&gt;) * (height - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> (node_memory) Node(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">inline SkipList&lt;Key, Comparator&gt;::Iterator::Iterator(const SkipList* list) &#123;</span><br><span class="line">  list_ = list;</span><br><span class="line">  node_ = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">inline bool SkipList&lt;Key, Comparator&gt;::Iterator::Valid() const &#123;</span><br><span class="line">  <span class="keyword">return</span> node_ != nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">inline const Key&amp; SkipList&lt;Key, Comparator&gt;::Iterator::key() const &#123;</span><br><span class="line">  <span class="keyword">assert</span>(Valid());</span><br><span class="line">  <span class="keyword">return</span> node_-&gt;key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">inline void SkipList&lt;Key, Comparator&gt;::Iterator::Next() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(Valid());</span><br><span class="line">  node_ = node_-&gt;Next(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">inline void SkipList&lt;Key, Comparator&gt;::Iterator::Prev() &#123;</span><br><span class="line">  <span class="comment">// Instead of using explicit &quot;prev&quot; links, we just search for the</span></span><br><span class="line">  <span class="comment">// last node that falls before key.</span></span><br><span class="line">  <span class="keyword">assert</span>(Valid());</span><br><span class="line">  node_ = list_-&gt;FindLessThan(node_-&gt;key);</span><br><span class="line">  <span class="keyword">if</span> (node_ == list_-&gt;head_) &#123;</span><br><span class="line">    node_ = nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">inline void SkipList&lt;Key, Comparator&gt;::Iterator::Seek(const Key&amp; target) &#123;</span><br><span class="line">  node_ = list_-&gt;FindGreaterOrEqual(target, nullptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">inline void SkipList&lt;Key, Comparator&gt;::Iterator::SeekToFirst() &#123;</span><br><span class="line">  node_ = list_-&gt;head_-&gt;Next(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">inline void SkipList&lt;Key, Comparator&gt;::Iterator::SeekToLast() &#123;</span><br><span class="line">  node_ = list_-&gt;FindLast();</span><br><span class="line">  <span class="keyword">if</span> (node_ == list_-&gt;head_) &#123;</span><br><span class="line">    node_ = nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">int SkipList&lt;Key, Comparator&gt;::RandomHeight() &#123;</span><br><span class="line">  <span class="comment">// Increase height with probability 1 in kBranching</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> unsigned <span class="keyword">int</span> kBranching = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">int</span> height = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// TODO lwl，这里不会使得kMaxHeight超过最大值么</span></span><br><span class="line">  <span class="keyword">while</span> (height &lt; kMaxHeight &amp;&amp; ((rnd_.Next() % kBranching) == <span class="number">0</span>)) &#123;</span><br><span class="line">    height++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">assert</span>(height &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">assert</span>(height &lt;= kMaxHeight);</span><br><span class="line">  <span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">bool SkipList&lt;Key, Comparator&gt;::KeyIsAfterNode(const Key&amp; key, Node* n) const &#123;</span><br><span class="line">  <span class="comment">// null n is considered infinite</span></span><br><span class="line">  <span class="keyword">return</span> (n != nullptr) &amp;&amp; (compare_(n-&gt;key, key) &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">typename SkipList&lt;Key, Comparator&gt;::Node*</span><br><span class="line">SkipList&lt;Key, Comparator&gt;::FindGreaterOrEqual(<span class="keyword">const</span> Key&amp; key,</span><br><span class="line">                                              Node** prev) <span class="keyword">const</span> &#123;</span><br><span class="line">  Node* x = head_;</span><br><span class="line">  <span class="keyword">int</span> level = GetMaxHeight() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    Node* next = x-&gt;Next(level);</span><br><span class="line">    <span class="keyword">if</span> (KeyIsAfterNode(key, next)) &#123;</span><br><span class="line">      <span class="comment">// Keep searching in this list</span></span><br><span class="line">      x = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (prev != nullptr) prev[level] = x;</span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Switch to next list</span></span><br><span class="line">        level--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">typename SkipList&lt;Key, Comparator&gt;::Node*</span><br><span class="line">SkipList&lt;Key, Comparator&gt;::FindLessThan(<span class="keyword">const</span> Key&amp; key) <span class="keyword">const</span> &#123;</span><br><span class="line">  Node* x = head_;</span><br><span class="line">  <span class="keyword">int</span> level = GetMaxHeight() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(x == head_ || compare_(x-&gt;key, key) &lt; <span class="number">0</span>);</span><br><span class="line">    Node* next = x-&gt;Next(level);</span><br><span class="line">    <span class="keyword">if</span> (next == nullptr || compare_(next-&gt;key, key) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Switch to next list</span></span><br><span class="line">        level--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">typename SkipList&lt;Key, Comparator&gt;::Node* SkipList&lt;Key, Comparator&gt;::FindLast()</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">  Node* x = head_;</span><br><span class="line">  <span class="keyword">int</span> level = GetMaxHeight() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    Node* next = x-&gt;Next(level);</span><br><span class="line">    <span class="keyword">if</span> (next == nullptr) &#123;</span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Switch to next list</span></span><br><span class="line">        level--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">SkipList&lt;Key, Comparator&gt;::SkipList(Comparator cmp, Arena* arena)</span><br><span class="line">    : compare_(cmp),</span><br><span class="line">      arena_(arena),</span><br><span class="line">      head_(NewNode(<span class="number">0</span> <span class="comment">/* any key will do */</span>, kMaxHeight)),</span><br><span class="line">      max_height_(<span class="number">1</span>),</span><br><span class="line">      rnd_(<span class="number">0xdeadbeef</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kMaxHeight; i++) &#123;</span><br><span class="line">    head_-&gt;SetNext(i, nullptr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">void SkipList&lt;Key, Comparator&gt;::Insert(const Key&amp; key) &#123;</span><br><span class="line">  <span class="comment">// TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()</span></span><br><span class="line">  <span class="comment">// here since Insert() is externally synchronized.</span></span><br><span class="line">  Node* prev[kMaxHeight];</span><br><span class="line">  Node* x = FindGreaterOrEqual(key, prev);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Our data structure does not allow duplicate insertion</span></span><br><span class="line">  <span class="keyword">assert</span>(x == nullptr || !Equal(key, x-&gt;key));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> height = RandomHeight();</span><br><span class="line">  <span class="keyword">if</span> (height &gt; GetMaxHeight()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = GetMaxHeight(); i &lt; height; i++) &#123;</span><br><span class="line">      prev[i] = head_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// It is ok to mutate max_height_ without any synchronization</span></span><br><span class="line">    <span class="comment">// with concurrent readers.  A concurrent reader that observes</span></span><br><span class="line">    <span class="comment">// the new value of max_height_ will see either the old value of</span></span><br><span class="line">    <span class="comment">// new level pointers from head_ (nullptr), or a new value set in</span></span><br><span class="line">    <span class="comment">// the loop below.  In the former case the reader will</span></span><br><span class="line">    <span class="comment">// immediately drop to the next level since nullptr sorts after all</span></span><br><span class="line">    <span class="comment">// keys.  In the latter case the reader will use the new node.</span></span><br><span class="line">    max_height_.store(height, std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  x = NewNode(key, height);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">    <span class="comment">// NoBarrier_SetNext() suffices since we will add a barrier when</span></span><br><span class="line">    <span class="comment">// we publish a pointer to &quot;x&quot; in prev[i].</span></span><br><span class="line">    x-&gt;NoBarrier_SetNext(i, prev[i]-&gt;NoBarrier_Next(i));</span><br><span class="line">    prev[i]-&gt;SetNext(i, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">bool SkipList&lt;Key, Comparator&gt;::Contains(const Key&amp; key) const &#123;</span><br><span class="line">  Node* x = FindGreaterOrEqual(key, nullptr);</span><br><span class="line">  <span class="keyword">if</span> (x != nullptr &amp;&amp; Equal(key, x-&gt;key)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br><span class="line"></span><br><span class="line">#endif  // STORAGE_LEVELDB_DB_SKIPLIST_H_</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>nicecode</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>link list</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 925. Long Pressed Name</title>
    <url>/2020/11/05/Leetcode/925/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.com/problems/long-pressed-name/">英文题目</a></p>
<p><a href="https://leetcode-cn.com/problems/long-pressed-name/">中文题目</a></p>
<p>难度：简单</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLongPressedName</span><span class="params">(String name, String typed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == name || <span class="keyword">null</span> == typed) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> lenN = name.length();</span><br><span class="line">        <span class="keyword">int</span> lenT = typed.length();</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (n &lt; lenN &amp;&amp; t &lt; lenT) &#123;</span><br><span class="line">            <span class="keyword">char</span> cn = name.charAt(n);</span><br><span class="line">            <span class="keyword">char</span> ct = typed.charAt(t);</span><br><span class="line">            <span class="keyword">if</span> (cn == ct) &#123;</span><br><span class="line">                n++;</span><br><span class="line">                t++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">char</span> pre = typed.charAt(t - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (pre == ct) &#123;</span><br><span class="line">                <span class="keyword">while</span> (pre == ct) &#123;</span><br><span class="line">                    t++;</span><br><span class="line">                    <span class="keyword">if</span> (t &gt;= lenT) <span class="keyword">break</span>;</span><br><span class="line">                    ct = typed.charAt(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n != lenN) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (t &lt; lenT) &#123;</span><br><span class="line">            <span class="keyword">char</span> ct = typed.charAt(t);</span><br><span class="line">            <span class="keyword">if</span> (ct != name.charAt(n - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>844. Backspace String Compare</title>
    <url>/2020/11/08/Leetcode/844/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.com/problems/backspace-string-compare/">英文题目</a></p>
<p><a href="https://leetcode-cn.com/problems/backspace-string-compare/">中文题目</a></p>
<p>难度：Easy</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>直接模拟删除字符串的方法，即遇到删除键便删除前面的字符，最后判断两个字符串是否相等。这里直接用数据结构stack来模仿删除字符的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getStr(S).equals(getStr(T));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getStr</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c!= <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stack.empty()) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: stack) &#123;</span><br><span class="line">            sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>从后往前遍历字符串，因为从前遍历的时候，遇到一个字符串，我们并不能确定该字符串是否会被删除，而从后往前遍历的时候，一个字符串是否被删除是可以确定的，因为在遍历的过程中，遇到删除键我们便往前删除一个字符即可。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = S.length();</span><br><span class="line">        <span class="keyword">int</span> tLen = T.length();</span><br><span class="line">        <span class="keyword">int</span> sp = sLen - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tp = tLen - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> back = <span class="number">0</span>; <span class="comment">// 还需要删除的字符个数</span></span><br><span class="line">            <span class="keyword">while</span> (sp &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (S.charAt(sp) == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    sp--;</span><br><span class="line">                    back++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (back &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        sp--;</span><br><span class="line">                        back--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            back = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (tp &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (T.charAt(tp) == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    tp--;</span><br><span class="line">                    back++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (back &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        tp--;</span><br><span class="line">                        back--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            System.out.println(sp + <span class="string">&quot;:&quot;</span> + tp);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (sp &gt;= <span class="number">0</span> &amp;&amp; tp &gt;= <span class="number">0</span> &amp;&amp; S.charAt(sp) == T.charAt(tp)) &#123;</span><br><span class="line">                sp--;</span><br><span class="line">                tp--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sp &lt; <span class="number">0</span> &amp;&amp; tp &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 845. Longest Mountain in Array</title>
    <url>/2020/11/08/Leetcode/845/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.com/problems/longest-mountain-in-array/">英文题目</a></p>
<p><a href="https://leetcode-cn.com/problems/longest-mountain-in-array/">中文题目</a></p>
<p>难度：Medium</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>直接模拟该山的形状即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestMountain</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = left;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> up = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">boolean</span> down = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// walk through the flat road</span></span><br><span class="line">            <span class="keyword">while</span> (A[pre] == A[right]) &#123;</span><br><span class="line">                pre++;</span><br><span class="line">                right++;</span><br><span class="line">                <span class="keyword">if</span> (right &gt;= len) <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            left = pre;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// walk up the road</span></span><br><span class="line">            <span class="keyword">while</span> (A[pre] &lt; A[right]) &#123;</span><br><span class="line">                pre++;</span><br><span class="line">                right++;</span><br><span class="line">                up = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (right &gt;= len) <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// walk through the flat road</span></span><br><span class="line">            <span class="keyword">while</span> (A[pre] == A[right]) &#123;</span><br><span class="line">                pre++;</span><br><span class="line">                right++;</span><br><span class="line">                up = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (right &gt;= len) <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// walk down the road</span></span><br><span class="line">            <span class="keyword">while</span> (A[pre] &gt; A[right]) &#123;</span><br><span class="line">                pre++;</span><br><span class="line">                right++;</span><br><span class="line">                down = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (right &gt;= len) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (up &amp;&amp; down) &#123;</span><br><span class="line">                ans = Math.max(ans, right - left);</span><br><span class="line">                left = pre;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 881. Boats to Save People</title>
    <url>/2020/11/08/Leetcode/881/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode.com/problems/boats-to-save-people/">英文题目</a></p>
<p><a href="https://leetcode-cn.com/problems/boats-to-save-people/">中文题目</a></p>
<p>难度：Medium</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>数组排序，两个指针一个指向开头，一个指向结尾，如果当前两人重量之和大于limit，则新增一个boat，且right指针左移，否则，两人一起放在新增boat上，left指针右移，right指针左移。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRescueBoats</span><span class="params">(<span class="keyword">int</span>[] people, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (people.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(people);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = people.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                ans = ans + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (people[left] + people[right] &lt;= limit) &#123;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans+=<span class="number">1</span>;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>two pointer</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Google C++ 编程规范</title>
    <url>/2020/11/18/CodeStyle/Google%20C%20PlusPlus%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><ol>
<li>头文件包含顺序，本类的头文件、C库、C++库、其他的.h库，项目内的.h库。</li>
<li>项目内头文件推荐按照字典序排序。</li>
<li>头文件的包含推荐使用其在项目中的完整路径。</li>
</ol>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><h3 id="不具名命名空间"><a href="#不具名命名空间" class="headerlink" title="不具名命名空间"></a>不具名命名空间</h3><p>就是namespace不加名字，在.cc文件中，允许甚至提倡使用不具名命名空间，以避免运行时的命名冲突：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123; <span class="comment">// .cc 文件中</span></span><br><span class="line"><span class="comment">// 命名空间的内容无需缩进</span></span><br><span class="line"><span class="keyword">enum</span> &#123; UNUSED, EOF, ERROR &#125;; <span class="comment">// 经常使用的符号</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AtEof</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> pos_ == EOF; &#125; <span class="comment">// 使用本命名空间内的符号EOF</span></span><br><span class="line">&#125; <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure>

<p>不能再.h文件中使用不具名命名空间。</p>
<h3 id="具名命名空间"><a href="#具名命名空间" class="headerlink" title="具名命名空间"></a>具名命名空间</h3><p>具名命名空间的格式为：namespace xxxname{}</p>
<p>命名空间之前包含：</p>
<ol>
<li>文件包含</li>
<li>全局标识的声明/定义</li>
<li>类的前置声明</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h 文件</span></span><br><span class="line"><span class="keyword">namespace</span> mynamespace &#123;</span><br><span class="line"><span class="comment">// 所有声明都置于命名空间中</span></span><br><span class="line"><span class="comment">// 注意不要使用缩进</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="comment">// namespace mynamespace</span></span><br><span class="line"><span class="comment">// .cc 文件</span></span><br><span class="line"><span class="keyword">namespace</span> mynamespace &#123;</span><br><span class="line"><span class="comment">// 函数定义都置于命名空间中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyClass::Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace mynamespace</span></span><br></pre></td></tr></table></figure>

<p>还应该注意的点是：</p>
<ol>
<li><p>不要声明命名空间std下的任何内容，包括标准库类的前置声明。声明std下的实体会导致不明确的行为，如，不可移植。</p>
</li>
<li><p>声明标准库下的实体，需要包含对应的头文件。</p>
</li>
<li><p>最好不要使用using指示符，以保证命名空间下的所有名称都正常使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 禁止 污染命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在.cc文件，.h文件的函数、方法或者类中，可以使用Using</span></span><br><span class="line"><span class="comment">// 允许：.cc 文件中</span></span><br><span class="line"><span class="comment">// .h 文件中，必须在函数、方法或类的内部使用</span></span><br><span class="line"><span class="keyword">using</span> ::foo::bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在.cc 文件、.h 文件的函数、方法或类中，还可以使用命名空间别名。</span></span><br><span class="line"><span class="comment">// 允许：.cc 文件中</span></span><br><span class="line"><span class="comment">// .h 文件中，必须在函数、方法或类的内部使用</span></span><br><span class="line"><span class="keyword">namespace</span> fbz = ::foo::bar::baz;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="非成员函数、静态成员函数和全局函数"><a href="#非成员函数、静态成员函数和全局函数" class="headerlink" title="非成员函数、静态成员函数和全局函数"></a>非成员函数、静态成员函数和全局函数</h2><p>使用命名空间内的非成员函数或静态成员函数，尽量不要使用全局函数。</p>
<h1 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h1><ol>
<li><p>将函数变量尽可能置于最小作用域内，在声明变量时将其初始化。</p>
</li>
<li><p>尽可能在小的作用域中声明变量，离第一次越近越好。</p>
</li>
<li><p>应使用初始化代替声明+赋值的方式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">i = f(); <span class="comment">// 坏——初始化和声明分离</span></span><br><span class="line">nt j = g(); <span class="comment">// 好——初始化时声明</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果变量是一个对象，每次进入作用域要调用其构造函数，退出作用域要调用其析构函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 低效的实现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">	Foo f; <span class="comment">// 构造函数和析构函数分别调用1000000 次！</span></span><br><span class="line">	f.DoSomething(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo f; <span class="comment">// 构造函数和析构函数只调用1 次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">	f.DoSomething(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><ol>
<li><p>class 类型的全局变量是被禁止的，内建类型的全局变量是允许的，当然多线程代码中非常数全局变量也是被禁止的。永远不要使用函数返回值初始化全局变量。</p>
</li>
<li><p>对于全局的字符串常量，使用C 风格的字符串，而不要使用STL 的字符串。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> kFrogSays[] = <span class="string">&quot;ribbet&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态成员变量视作全局变量，所以，也不能是class 类型。</p>
</li>
</ol>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><ol>
<li><p>构造函数中只进行简单的初始化，，可能的话，使用Init()方法集中初始化为有意义的（non-trivial）数据。</p>
</li>
<li><p>构造函数内调用虚函数，调用不会派发到子类实现中，即使当前没有子类化实现，将来仍是隐患。</p>
</li>
<li><p>如果构建了全局类型的class，则该类的构造函数将在main()之前被调用。</p>
</li>
<li><p>如果对象需要有意义的（non-trivial）初始化，考虑使用另外的Init()方法并（或）增加一个成员标记用于指示对象是否已经初始化成功。</p>
</li>
<li><p>如果类中定义了成员变量，没有提供其他构造函数，你需要定义一个默认构造函数（没有参数）。默认构造函数更适合于初始化对象，使对象内部状态（internal state）一致、有效。</p>
</li>
<li><p>对单参数构造函数使用C++关键字explicit。</p>
</li>
<li><p>不需要拷贝时应使用DISALLOW_COPY_AND_ASSIGN，仅在代码中需要拷贝一个类对象的时候使用拷贝构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 禁止使用拷贝构造函数和赋值操作的宏</span></span><br><span class="line"><span class="comment">// 应在类的private:中使用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISALLOW_COPY_AND_ASSIGN(TypeName) \</span></span><br><span class="line">	TypeName(<span class="keyword">const</span> TypeName&amp;); \</span><br><span class="line">	<span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> TypeName&amp;)</span><br><span class="line">class Foo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo(<span class="keyword">int</span> f);</span><br><span class="line">	~Foo();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	DISALLOW_COPY_AND_ASSIGN(Foo);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在将类作为STL 容器值得时候，你可能有使类可拷贝的冲动。类似情况下，真正该做的是使用指针指向STL 容器中的对象，可以考虑使用std::tr1::shared_ptr。</p>
</li>
<li><p>struct 被用在仅包含数据的消极对象（passive objects）上，可能包括有关联的常量，但没有存取数据成员之外的函数功能，而存取功能通过直接访问实现而无需方法调用，这儿提到的方法是指只用于处理数据成员的，如构造函数、析构函数、Initialize()、Reset()、Validate()。</p>
</li>
<li><p>如果需要更多的函数功能，class 更适合，如果不确定的话，直接使用class。</p>
</li>
<li><p>如果与STL 结合，对于仿函数（functors）和特性（ traits）可以不用class 而是使用struct。</p>
</li>
<li><p>所有继承必须是public 的，如果想私有继承的话，应该采取包含基类实例作为成员的方式作为替代。</p>
</li>
<li><p>在含有虚析构函数的父类中，定义虚构函数绝对必要。</p>
</li>
<li><p>限定仅在子类访问的成员函数为protected，需要注意的是数据成员应始终为私有。当重定义派生的虚函时，在派生类中明确声明其为virtual。根本原因：如果遗漏virtual，阅读者需要检索类的所有祖先以确定该函数否为虚函数（译者注，虽然不影响其为虚函数的本质）</p>
</li>
<li><p>一般不要重载操作符，尤其是赋值操作（operator=）比较阴险，应避免重载。如果需要的话，可以定义类似Equals()、CopyFrom()等函数。</p>
</li>
<li><p>函数长度在40行内比较好，但是对于逻辑比较复杂的函数，没有这个要求。</p>
</li>
</ol>
<h1 id="变量声明顺序"><a href="#变量声明顺序" class="headerlink" title="变量声明顺序"></a>变量声明顺序</h1><ol>
<li>public</li>
<li>protected</li>
<li>private</li>
<li>没一个块中，声明次序如下：<ul>
<li>typdefs和enums</li>
<li>常量</li>
<li>构造函数</li>
<li>析构函数</li>
<li>成员函数，含静态成员函数</li>
<li>数据成员，含静态数据成员</li>
</ul>
</li>
<li>宏<code>DISALLOW_COPY_AND_ASSIGN</code>置于private块之后，作为类的最后部分，参考拷贝构造函数</li>
<li>.cc文件中，函数的定义应尽可能和声明次序一致。</li>
</ol>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><ol>
<li>static_cast：和C 风格转换相似可做值的强制转换，或指针的父类到子类的明确的向上转换；</li>
<li>const_cast：移除const 属性；</li>
<li>reinterpret_cast：指针类型和整型或其他指针间不安全的相互转换，仅在你对所做一切了然于心时使用；</li>
<li>dynamic_cast：除测试外不要使用，除单元测试外，如果你需要在运行时确定类型信息，说明设计有缺陷（参考RTTI）</li>
</ol>
<h1 id="Google特有的风情"><a href="#Google特有的风情" class="headerlink" title="Google特有的风情"></a>Google特有的风情</h1><ol>
<li>不推荐使用智能指针；</li>
<li>可以使用scoped_ptr代替智能指针，使用时尽量局部化，并且，安全第一；</li>
<li><strong>事实上这是一个硬性约定：输入参数为值或常数引用，输出参数为指针；输入参数可以是常数指针，但不能使用非常数引用形参。<br>在强调参数不是拷贝而来，在对象生命期内必须一直存在时可以使用常数指针，最好将这些在注释中详细说明。bind2nd 和mem_fun 等STL 适配器不接受引用形参，这种情况下也必须以指针形参声明函数。</strong></li>
<li>所有参数必须明确指定，强制程序员考虑API 和传入的各参数值，避免使用可能不为程序员所知的缺省参数。</li>
<li>禁止使用异常。</li>
</ol>
<h1 id="其他C-特性"><a href="#其他C-特性" class="headerlink" title="其他C++特性"></a>其他C++特性</h1><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><ol>
<li>只在记录日志时使用流；</li>
<li>流是printf和scanf的替代；</li>
<li>使用流还有很多利弊，代码一致性胜过一切，不要在代码中使用流；</li>
<li>最后的多数决定是printf + read/write</li>
</ol>
<h2 id="前置自增和自减"><a href="#前置自增和自减" class="headerlink" title="前置自增和自减"></a>前置自增和自减</h2><ol>
<li>对于迭代器和其他模板对象使用前缀形式（++i）的自增、自减运算符；</li>
<li>不考虑返回值的话，前置自增（++i）通常要比后置自增（i++）效率更高，因为后置的自增自减需要对表达式的值i 进行一次拷贝，如果i 是迭代器或其他非数值类型，拷贝的代价是比较大的。既然两种自增方式动作一样（译者注，不考虑表达式的值，相信你知道我在说什么），为什么不直接使用前置自增呢。</li>
<li>对简单数值（非对象）来说，两种都无所谓，对迭代器和模板类型来说，要使用前置自增（自减）；</li>
</ol>
<p>##　Const的使用</p>
<ol>
<li>在声明的变量或参数前加上关键字const 用于指明变量值不可修改（如const intfoo），为类中的函数加上const 限定表明该函数不会修改类成员变量的状态（如class Foo{ int Bar(char c) const; };）。</li>
<li>在以下情况下可以考虑使用const<ul>
<li>如果函数不会修改传入的引用或指针类型的参数，这样的参数应该为const；</li>
<li>尽可能将函数声明为const，访问韩式应该总是const，其他函数如果不会修改任何数据成员也应该是const，不要调用非const函数，不要返回对数据成员的非const指针或引用；</li>
<li>如果数据成员在对象构造之后不再改变，可将其定义为const。</li>
</ul>
</li>
</ol>
<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><ol>
<li><p>提倡使用精确宽度的整形替代int，因为int在不同类型的操作系统中其位数是不同的。，通常人们认为short 是16 位，int 是32 位，long 是32位，long long 是64 位。</p>
</li>
<li><p>&lt;stdint.h&gt;定义了int16_t、uint32_t、int64_t 等整型，在需要确定大小的整型时可以使用它们代替short、unsigned long long 等；，在C 整型中，只使用int。适当情况下，推荐使用标准类型如size_t 和ptrdiff_t。</p>
</li>
<li><p>不要使用uint32_t 等无符号整型，除非你是在表示一个位组（bit pattern）而不是一个数值。即使数值不会为负值也不要使用无符号类型。使用断言来保护数据。</p>
</li>
<li><p>在C 语言中，无符号整形通常会导致Bug。如，以下情况会导致死循环，原因是，当i减到0时，由于它是无符号整数，当其变为-1时，它的二进制形式为32个1，在判断i&gt;=0时，会将其看为2^31 - 1，而不是-1，从而导致死循环。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">100</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i); </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出如下：</span></span><br><span class="line"><span class="comment">......</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">-1</span></span><br><span class="line"><span class="comment">-2</span></span><br><span class="line"><span class="comment">-3</span></span><br><span class="line"><span class="comment">-4</span></span><br><span class="line"><span class="comment">-5</span></span><br><span class="line"><span class="comment">-6</span></span><br><span class="line"><span class="comment">......</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>打印整型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TODO</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>sizeof(void *) != sizeof(int)，，如果需要一个指针大小的整数要使用intptr_t</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">void</span>*));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">* 8 // 指针</span></span><br><span class="line"><span class="comment">* 4 // int</span></span><br><span class="line"><span class="comment">/</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="7">
<li><p>需要对结构对齐加以留心，尤其是对于存储在磁盘上的结构体。在64 位系统中，任何拥有int64_t/uint64_t 成员的类/结构体将默认被处理为8 字节对齐。如果32 位和64 位代码共用磁盘上的结构体，需要确保两种体系结构下的结构体的对齐一致。大多数编译器提供了调整结构体对齐的方案。gcc 中可使用<strong>attribute</strong>((packed))，MSVC 提供了#pragma pack()和__declspec(align())（译者注，解决方案的项目属性里也可以直接设置）</p>
</li>
<li><p>创建64 位常量时使用LL 或ULL 作为后缀</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int64_t</span> my_value = <span class="number">0x123456789</span>LL;</span><br><span class="line"><span class="keyword">uint64_t</span> my_mask = <span class="number">3U</span>LL &lt;&lt; <span class="number">48</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="预处理宏"><a href="#预处理宏" class="headerlink" title="预处理宏"></a>预处理宏</h2><p>使用宏时要谨慎，尽量以内联函数，枚举和常量代替。在C++中，宏不像C中那么重要，宏内敛效率关键代码（performance-criticalcode）可以内联函数替代；宏存储常量可以const 变量替代；宏“缩写”长变量名可以引用<br>替代；</p>
<p>宏可以做一些其他技术无法实现的事情，如字符串化使用#， 连接（concatenation，译者注，使用##）等等，不过在使用前，考虑以下能不能不使用宏实现相同的效果。</p>
<ol>
<li>不要在.h 文件中定义宏；</li>
<li>使用前正确#define，使用后正确#undef</li>
<li>不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称</li>
<li>不使用会导致不稳定的C++构造（unbalanced C++ constructs，译者注）的宏</li>
</ol>
<h2 id="0-和-NULL"><a href="#0-和-NULL" class="headerlink" title="0 和 NULL"></a>0 和 NULL</h2><ol>
<li>整数用0</li>
<li>实数用0.0</li>
<li>指针用NULL或者nullptr</li>
<li>字符用<code>\0</code></li>
</ol>
<h2 id="Sizeof"><a href="#Sizeof" class="headerlink" title="Sizeof"></a>Sizeof</h2><p>尽可能用sizeof(varname)代替sizeof(type)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Struct data;</span><br><span class="line"><span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line"><span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="keyword">sizeof</span>(Struct));</span><br></pre></td></tr></table></figure>



<h2 id="Boost"><a href="#Boost" class="headerlink" title="Boost"></a>Boost</h2><p>只使用Boost中被认可的库。</p>
<ol>
<li>Compressed Pair：boost/compressed_pair.hpp；</li>
<li>Pointer Container：boost/ptr_container 不包括ptr_array.hpp 和序列化（serialization）;</li>
<li><strong>Call Traits</strong> from boost/call_traits.hpp;</li>
<li><strong>The Boost Graph Library (BGL)</strong> from boost_graph，除了serializetion(adj_list_serialize.hpp)和parallel/distributed algorithms（boost/graph/parallel）和data structures（boost/graph/distributed/*）</li>
<li><strong>Property Map</strong> from boost/property_map,  除了parallel/distributed property maps(boost/property_map/parallel/*)</li>
<li><strong>Iterator</strong> from boost/iterator</li>
<li><strong>Bimap</strong> from boost/bitmap</li>
<li><strong>Statistical Distributions and Functions</strong> from boost/math/distributions</li>
<li><strong>Multi-index</strong> from boost/multi_index</li>
<li><strong>Heap</strong> from boost/heap</li>
<li><strong>Container</strong> from boost/container/flat_map 和 boost/container/flat_set</li>
<li><strong>Intrusive</strong> from boost/intrusive</li>
<li>The part of <strong>Polygon</strong> that deals with Voronoi diagram construction and doesn’t depend on the<br>rest of Polygon: boost/polygon/voronoi_builder.hpp,boost/polygon/voronoi_diagram.hpp,<br>and boost/polygon/voronoi_geometry_type.hpp</li>
<li>下面两个也是允许的，但是它们已经被C++11放弃了<ol>
<li><strong>Array</strong> from boost/array.hpp</li>
<li><strong>Pointer Container</strong> from boost/ptr_container: use containers of <strong>std::unique_ptr</strong> instead</li>
</ol>
</li>
</ol>
<h2 id="Aliases"><a href="#Aliases" class="headerlink" title="Aliases"></a>Aliases</h2><p>推荐使用Aliases，因为它能使得API更加清晰，下面有三种Aliases的形式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Foo Bar;</span><br><span class="line"><span class="keyword">using</span> Bar = Foo;</span><br><span class="line"><span class="keyword">using</span> other_namespace::Foo;</span><br></pre></td></tr></table></figure>



<p>但是它也有一些缺点，因此在使用时，必须在文件中声明怎么使用这些新的类型。</p>
<p>下面的代码是推荐的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> a &#123;</span><br><span class="line"><span class="comment">// Used to store field measurements. DataPoint may change from Bar* to some internal type.</span></span><br><span class="line"><span class="comment">// Client code should treat it as an opaque pointer.</span></span><br><span class="line"><span class="keyword">using</span> DataPoint = foo::bar::Bar*;</span><br><span class="line"><span class="comment">// A set of measurements. Just an alias for user convenience.</span></span><br><span class="line"><span class="keyword">using</span> TimeSeries = <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;DataPoint, <span class="built_in">std</span>::hash&lt;DataPoint&gt;,</span><br><span class="line">DataPointComparator&gt;;</span><br><span class="line">&#125; <span class="comment">// namespace a</span></span><br></pre></td></tr></table></figure>



<p>下面的代码是不推荐的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> a &#123;</span><br><span class="line"><span class="comment">// Bad: none of these say how they should be used.</span></span><br><span class="line"><span class="keyword">using</span> DataPoint = foo::bar::Bar*;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">unordered_set</span>; <span class="comment">// Bad: just for local convenience</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::hash; <span class="comment">// Bad: just for local convenience</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">unordered_set</span>&lt;DataPoint, hash&lt;DataPoint&gt;, DataPointComparator&gt; TimeSeries;</span><br><span class="line">&#125; <span class="comment">// namespace a</span></span><br></pre></td></tr></table></figure>

<p>但是在函数内部、类的私有部分、明确的中间类型的namspace以及在.cc文件中，aliases是推荐的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In a .cc file</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">unordered_set</span>;</span><br></pre></td></tr></table></figure>





<h2 id="Braced-Initializer-List"><a href="#Braced-Initializer-List" class="headerlink" title="Braced Initializer List"></a>Braced Initializer List</h2><p>直接使用大括号初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vector takes a braced-init-list of elements.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v&#123;<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// Basically the same, ignoring some small technicalities.</span></span><br><span class="line"><span class="comment">// You may choose to use either form.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v = &#123;<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// Usable with &#x27;new&#x27; expressions.</span></span><br><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&#123;<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// A map can take a list of pairs. Nested braced-init-lists work.</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m = &#123;&#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;2&quot;</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// A braced-init-list can be implicitly converted to a return type.</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">test_function</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; &#125;</span><br><span class="line"><span class="comment">// Iterate over a braced-init-list.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>&#125;) &#123;&#125;</span><br><span class="line"><span class="comment">// Call a function using a braced-init-list.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFunction2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">TestFunction2(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>可以为类定义大括号初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyType</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// std::initializer_list references the underlying init list.</span></span><br><span class="line">    <span class="comment">// It should be passed by value.</span></span><br><span class="line">    MyType(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; init_list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : init_list) append(i);</span><br><span class="line">    &#125;</span><br><span class="line">	MyType&amp; <span class="keyword">operator</span>=(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; init_list) &#123;</span><br><span class="line">    	clear();</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i : init_list) append(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MyType m&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>有些类的构造函数即使没有声明大括号类型的构造函数，也可可以进行转化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d&#123;<span class="number">1.23</span>&#125;;</span><br><span class="line"><span class="comment">// Calls ordinary constructor as long as MyOtherType has no</span></span><br><span class="line"><span class="comment">// std::initializer_list constructor.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOtherType</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyOtherType</span><span class="params">(<span class="built_in">string</span>)</span></span>;</span><br><span class="line">    MyOtherType(<span class="keyword">int</span>, <span class="built_in">string</span>);</span><br><span class="line">&#125;;</span><br><span class="line">MyOtherType m = &#123;<span class="number">1</span>, <span class="string">&quot;b&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// If the constructor is explicit, you can&#x27;t use the &quot;= &#123;&#125;&quot; form.</span></span><br><span class="line">MyOtherType m&#123;<span class="string">&quot;b&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>不要使用大括号赋值法为auto类型的变量赋值，因为这种是不可控的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> d = &#123;<span class="number">1.23</span>&#125;; <span class="comment">// Bad --- d is a std::initializer_list&lt;double&gt;</span></span><br><span class="line"><span class="keyword">auto</span> d = <span class="keyword">double</span>&#123;<span class="number">1.23</span>&#125;; <span class="comment">// Good -- d is a double, not a std::initializer_list.</span></span><br></pre></td></tr></table></figure>

<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>尽可能使用lambda表达式，当函数参数是一个函数时，用lambda表达式比较合适</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::sort(v.begin(), v.end(), [](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">	<span class="keyword">return</span> Weight(x) &lt; Weight(y);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li>在STL中常用lambda表达式</li>
<li>如果一个lambda表达式的长度超过5行，考虑使用命名的lambda表达式或者函数进行替代。</li>
</ol>
<h1 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h1><h2 id="通用命名规则"><a href="#通用命名规则" class="headerlink" title="通用命名规则"></a>通用命名规则</h2><ol>
<li><p>函数命名、变量命名、文件命名应具有描述性，不要过度缩写，类型和变量应该是名词，函数名可以用“命令性”动词</p>
</li>
<li><p>尽可能给出描述性名称，不要节约空间，让别人很快理解你的代码更重要，好的命名选择：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num_errors; <span class="comment">// Good.</span></span><br><span class="line"><span class="keyword">int</span> num_completed_connections; <span class="comment">// Good.</span></span><br></pre></td></tr></table></figure>

<p>坏的命名：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n; <span class="comment">// Bad - meaningless.</span></span><br><span class="line"><span class="keyword">int</span> nerr; <span class="comment">// Bad - ambiguous abbreviation.</span></span><br><span class="line"><span class="keyword">int</span> n_comp_conns; <span class="comment">// Bad - ambiguous abbreviation.</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>函数名通常是指令性的，如OpenFile()、set_num_errors()，访问函数需要描述的更细致，要与其访问的变量相吻合.</p>
</li>
<li><p>缩写</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="comment">// These show proper names with no abbreviations.</span></span><br><span class="line"><span class="keyword">int</span> num_dns_connections; <span class="comment">// Most people know what &quot;DNS&quot; stands for.</span></span><br><span class="line"><span class="keyword">int</span> price_count_reader; <span class="comment">// OK, price count. Makes sense.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad!</span></span><br><span class="line"><span class="comment">// Abbreviations can be confusing or ambiguous outside a small group.</span></span><br><span class="line"><span class="keyword">int</span> wgc_connections; <span class="comment">// Only your group knows what this stands for.</span></span><br><span class="line"><span class="keyword">int</span> pc_reader; <span class="comment">// Lots of things can be abbreviated &quot;pc&quot;.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要用省略字母的缩写：</span></span><br><span class="line"><span class="keyword">int</span> error_count; <span class="comment">// Good.</span></span><br><span class="line"><span class="keyword">int</span> error_cnt; <span class="comment">// Bad.</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h2><ol>
<li>文件名要全部小写，可以包含下划线（_）或短线（-），按项目约定来。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 以下都可以</span><br><span class="line">my_useful_class.cc</span><br><span class="line">my-useful-class.cc</span><br><span class="line">myusefulclass.cc</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>C++文件以.cc 结尾，头文件以.h 结尾。</p>
</li>
<li><p>不要使用已经存在于/usr/include 下的文件名（译者注，对UNIX、Linux 等系统而言），如db.h；</p>
</li>
<li><p>通常，尽量让文件名更加明确，http_server_logs.h 就比logs.h 要好，定义类时文件名一般成对出现，如foo_bar.h 和foo_bar.cc，对应类FooBar;</p>
</li>
<li><p>内联函数必须放在.h 文件中，如果内联函数比较短，就直接放在.h 中。如果代码比较长，可以放到以-inl.h 结尾的文件中。对于包含大量内联代码的类，可以有三个文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">url_table.h <span class="comment">// The class declaration.</span></span><br><span class="line">url_table.cc <span class="comment">// The class definition.</span></span><br><span class="line">url_table-inl.h <span class="comment">// Inline functions that include lots of code.</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="类型命名"><a href="#类型命名" class="headerlink" title="类型命名"></a>类型命名</h2><ol>
<li>类型命名每个单词以大写字母开头，不包含下划线： MyExcitingClass, MyExcitingEnum</li>
<li>类型命名每个单词以大写字母开头，不包含下划线：MyExcitingClass、MyExcitingEnum。所有类型命名——类、结构体、类型定义（typedef）、枚举——使用相同约定。</li>
</ol>
<h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h2><ol>
<li><p>变量名一律小写，单词间以下划线相连，类的成员变量以下划线结尾</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> table_name; <span class="comment">// OK - uses underscore.</span></span><br><span class="line"><span class="built_in">string</span> tablename; <span class="comment">// OK - all lowercase.</span></span><br><span class="line"><span class="built_in">string</span> tableName; <span class="comment">// Bad - mixed case.</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>结构体的数据成员可以和普通变量一样，不用像类那样接下划线：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UrlTableProperties</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> num_entries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对全局变量没有特别要求，少用就好，可以以g_或其他易与局部变量区分的标志为前缀。</p>
</li>
<li><p>常量命名：在名称前加k：kDaysInAWeek。所有编译时常量（无论是局部的、全局的还是类中的）和其他变量保持些许区别，k 后接大写字母开头的单词：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kDaysInAWeek = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h2><p>普通函数大小写混合，存取函数则要求与变量名匹配，MyExcitingFunction()、MyExcitingMethod()、my_exciting_member_variable()。</p>
<ol>
<li><p>普通函数:函数名以大写字母开头，每个单词首字母大写，没有下划线：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AddTableEntry()</span><br><span class="line">DeleteUrl()</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>存取函数要与存取的变量名匹配</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">num_entries</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> num_entries_; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set_num_entries</span><span class="params">(<span class="keyword">int</span> num_entries)</span> </span>&#123; num_entries_ = num_entries; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> num_entries_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他短小的内联函数名也可以使用小写字母，例如，在循环中调用这样的函数甚至都不需要<br>缓存其值，小写命名就可以接受。</p>
</li>
<li><p>从这一点上可以看出，小写的函数名意味着可以直接内联使用。</p>
</li>
</ol>
<h2 id="命名空间-1"><a href="#命名空间-1" class="headerlink" title="命名空间"></a>命名空间</h2><ol>
<li>命名空间的名称是全小写的，其命名基于项目名称和目录结构：google_awesome_project。</li>
</ol>
<h2 id="枚举命名"><a href="#枚举命名" class="headerlink" title="枚举命名"></a>枚举命名</h2><ol>
<li>枚举值应全部大写，单词间以下划线相连</li>
<li>枚举名称属于类型，因此大小写混合：UrlTableErrors。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> UrlTableErrors &#123;</span><br><span class="line">    OK = <span class="number">0</span>,</span><br><span class="line">    ERROR_OUT_OF_MEMORY,</span><br><span class="line">    ERROR_MALFORMED_INPUT,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="宏命名"><a href="#宏命名" class="headerlink" title="宏命名"></a>宏命名</h2><p>通常不推荐使用宏，如果使用，其命名像枚举命名一样全部大写使用下划线。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROUND(x) ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI_ROUNDED 3.0</span></span><br><span class="line">MY_EXCITING_ENUM_VALUE</span><br></pre></td></tr></table></figure>

<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><h2 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h2><ol>
<li><p>函数声明处(.h)注释描述函数功能，定义处(.cc)描述函数实现。</p>
</li>
<li><p>函数声明处注释的内容</p>
<ul>
<li>inputs（输入）及outputs（输出）</li>
<li>对类成员函数而言：函数调用期间对象是否需要保持引用参数，是否会释放这些参数</li>
<li>如果函数分配了空间，需要由调用者释放</li>
<li>参数是否可以为NULL</li>
<li>是否存在函数使用的性能隐忧（performance implications）；</li>
<li>如果函数是可重入的（re-entrant），其同步前提是什么</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns an iterator for this table. It is the client&#x27;s</span></span><br><span class="line"><span class="comment">// responsibility to delete the iterator when it is done with it,</span></span><br><span class="line"><span class="comment">// and it must not use the iterator once the GargantuanTable object</span></span><br><span class="line"><span class="comment">// on which the iterator was created has been deleted.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The iterator is initially positioned at the beginning of the table.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This method is equivalent to:</span></span><br><span class="line">    <span class="comment">// Iterator* iter = table-&gt;NewIterator();</span></span><br><span class="line">    <span class="comment">// iter-&gt;Seek(&quot;&quot;);</span></span><br><span class="line">    <span class="comment">// return iter;</span></span><br><span class="line"><span class="comment">// If you are going to immediately seek to another place in the</span></span><br><span class="line"><span class="comment">// returned iterator, it will be faster to use NewIterator()</span></span><br><span class="line"><span class="comment">// and avoid the extra seek.</span></span><br><span class="line"><span class="function">Iterator* <span class="title">GetIterator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每个函数定义时要以注释说明函数功能和实现要点，如使用的漂亮代码、实现的简要步骤、如此实现的理由、为什么前半部分要加锁而后半部分不需要。</p>
</li>
</ol>
<h2 id="变量注释"><a href="#变量注释" class="headerlink" title="变量注释"></a>变量注释</h2><ol>
<li>每个类数据成员都应该添加注释，，如果变量可以接受NULL 或-1等警戒值（sentinel values），须说明之</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// Keeps track of the total number of entries in the table.</span></span><br><span class="line"><span class="comment">// Used to ensure we do not go over the limit. -1 means</span></span><br><span class="line"><span class="comment">// that we don&#x27;t yet know how many entries the table has.</span></span><br><span class="line"><span class="keyword">int</span> num_total_entries_;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>全局变量和数据成员相似，所有全局变量（常量）也应注释说明含义及用</li>
</ol>
<h2 id="实现注释"><a href="#实现注释" class="headerlink" title="实现注释"></a>实现注释</h2><ol>
<li><p>对于实现代码中巧妙的、晦涩的、有趣的、重要的地方加以注释</p>
</li>
<li><p>代码前注释，出彩的或复杂的代码块前要加注释</p>
</li>
<li><p>比较隐晦的地方要在行尾加入注释，可以在代码之后<strong>空两格</strong>加行尾注释</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// If we have enough memory, mmap the data portion too.</span></span><br><span class="line">mmap_budget = max&lt;int64&gt;(<span class="number">0</span>, mmap_budget - index_-&gt;length());</span><br><span class="line"><span class="keyword">if</span> (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock))</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">// Error already logged.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>前后相邻几行都有注释，可以适当调整使之可读性更好：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">DoSomething(); <span class="comment">// Comment here so the comments line up.</span></span><br><span class="line">DoSomethingElseThatIsLonger(); <span class="comment">// Comment here so there are two spaces between</span></span><br><span class="line"><span class="comment">// the code and the comment.</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>向函数传入、布尔值或整数时,要注释说明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> success = CalculateSomething(interesting_value,</span><br><span class="line">			<span class="number">10</span>,</span><br><span class="line">			<span class="literal">false</span>,</span><br><span class="line">			<span class="literal">NULL</span>); <span class="comment">// What are these arguments??</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> success = CalculateSomething(interesting_value,</span><br><span class="line">			<span class="number">10</span>, <span class="comment">// Default base value.</span></span><br><span class="line">			<span class="literal">false</span>, <span class="comment">// Not the first time we&#x27;re calling</span></span><br><span class="line">			<span class="keyword">this</span>.</span><br><span class="line">			<span class="literal">NULL</span>); <span class="comment">// No callback.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用常量或描述性变量：</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kDefaultBaseValue = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> kFirstTimeCalling = <span class="literal">false</span>;</span><br><span class="line">Callback *null_callback = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">bool</span> success = CalculateSomething(interesting_value,</span><br><span class="line">			kDefaultBaseValue,</span><br><span class="line">			kFirstTimeCalling,</span><br><span class="line">			null_callback)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="6">
<li>注意永远不要用自然语言翻译代码作为注释</li>
</ol>
]]></content>
      <categories>
        <category>codeing</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>code style</tag>
      </tags>
  </entry>
</search>
